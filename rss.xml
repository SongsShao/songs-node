<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>note</title>
  
  <subtitle>This is Batype&#39;s note website</subtitle>
  <link href="https://note.batype.com/rss.xml" rel="self"/>
  
  <link href="https://note.batype.com/"/>
  <updated>2024-04-29T09:28:23.663Z</updated>
  <id>https://note.batype.com/</id>
  
  <author>
    <name>songshao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾回收：垃圾数据是如何自动回收的？</title>
    <link href="https://note.batype.com/browser/javascript/v8/garbage-collection.html"/>
    <id>https://note.batype.com/browser/javascript/v8/garbage-collection.html</id>
    <published>2024-04-29T07:58:49.026Z</published>
    <updated>2024-04-29T09:28:23.663Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/browser/javascript/v8/stackAndHeap.html">栈空间和堆空间：数据是如何存储的</a>文章中，我们提到了 JavaScript 中的数据是如何存储的，并通过例子分析了<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。通过这种分配方式，我们解决了数据的内存分配的问题。</p><p>不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p><h2 id="不同语言的垃圾回收策略"><a href="#不同语言的垃圾回收策略" class="headerlink" title="不同语言的垃圾回收策略"></a>不同语言的垃圾回收策略</h2><p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p><p>如 C/C++ 就是使用手动回收策略，<strong>何时分配内存、何时销毁内存都是由代码控制的</strong>，你可以参考下面这段 C 代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆中分配内存</span></span><br><span class="line"><span class="type">char</span>* p =  (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">2048</span>);  <span class="comment">//在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//使用p指向的内存</span></span><br><span class="line"> {</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用结束后，销毁这段内存</span></span><br><span class="line"><span class="built_in">free</span>(p)；</span><br><span class="line">p = <span class="literal">NULL</span>；</span><br></pre></td></tr></tbody></table></figure><p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</p><p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p><p>对于 JavaScript 而言，也正是这个 “自动” 释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p><p>那么在本文，我们将围绕 “JavaScript 的数据是如何回收的” 这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍 “栈中的垃圾数据” 和 “堆中的垃圾数据” 是如何回收的。</p><h2 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h2><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = {<span class="attr">name</span>:<span class="string">"极客邦"</span>}</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>){</span><br><span class="line">      <span class="keyword">var</span> c = <span class="number">2</span></span><br><span class="line">      <span class="keyword">var</span> d = {<span class="attr">name</span>:<span class="string">"极客时间"</span>}</span><br><span class="line">    }</span><br><span class="line">    <span class="title function_">showName</span>()</span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f5a4b0ea9cb1403b921c4.png" alt="执行到showName函数时的内存模型"></p><p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p><p>在<a href="/browser/javascript/v8/stackAndHeap.html">栈空间和堆空间：数据是如何存储的</a>文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p><p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p><p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：</p><p><img data-src="https://pic.imgdb.cn/item/662f63c40ea9cb1403ce7e6c.png" alt="从栈中回收showName执行上下文"></p><p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p><h2 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h2><p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f64080ea9cb1403cf0d91.png" alt="foo函数执行结束后的内存状态"></p><p>从图中可以看出，1003 和 1050 这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p><p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p><h2 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h2><p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下<strong>代际假说（The Generational Hypothesis）</strong>的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p><p>代际假说有以下两个特点：</p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li><li>第二个是不死的对象，会活得更久。</li></ul><p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p><p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p><p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p><p>所以，在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p><p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li><strong>副垃圾回收器</strong>，主要负责新生代的垃圾回收。</li><li><strong>主垃圾回收器</strong>，主要负责老生代的垃圾回收。</li></ul><h2 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h2><p>现在你知道了 V8 把堆分成两个区域 —— 新生代和老生代，并分别使用两个不同的垃圾回收器。其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p><p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p><p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p><p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p><h2 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h2><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p><p>新生代中用 <strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f65610ea9cb1403d18a1c.png" alt="新生区要划分为对象区域和空闲区域"></p><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为<strong>了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h2 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h2><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p><p><strong>首先</strong>是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p><p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f668e0ea9cb1403d39fec.png" alt="标记过程"></p><p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p><p><img data-src="https://pic.imgdb.cn/item/662f66c50ea9cb1403d40a6a.png" alt="标记清除过程"></p><p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法 —— <strong>标记 - 整理（Mark-Compact）</strong>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/662f66f60ea9cb1403d463dc.png" alt="标记整理过程"></p><h2 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h2><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f67750ea9cb1403d54c0e.png" alt="全停顿"></p><p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f67b70ea9cb1403d5c414.png" alt="增量标记算法"></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就讲到这里，下面我们就来总结下今天的主要内容。</p><p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p><p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p><p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p><p>生活中处理事情的原则也与之类似，古人很早就说过 “两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>]]></content>
    
    
    <summary type="html">对于前端开发者来说，JavaScript的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道JavaScript的内存机制是什么。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="javascript" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/javascript/"/>
    
    <category term="v8" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/javascript/v8/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript" scheme="https://note.batype.com/tags/javascript/"/>
    
    <category term="v8" scheme="https://note.batype.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>栈空间和堆空间：数据是如何存储的？</title>
    <link href="https://note.batype.com/browser/javascript/v8/stackAndHeap.html"/>
    <id>https://note.batype.com/browser/javascript/v8/stackAndHeap.html</id>
    <published>2024-04-29T02:26:09.781Z</published>
    <updated>2024-04-29T09:28:27.683Z</updated>
    
    <content type="html"><![CDATA[<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p><p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p><p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p><p>今天我们讲述第一部分的内容 ——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。</p><h2 id="让人疑惑的代码"><a href="#让人疑惑的代码" class="headerlink" title="让人疑惑的代码"></a>让人疑惑的代码</h2><p>首先，我们先看下面这两段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = {<span class="attr">name</span>:<span class="string">"极客时间"</span>}</span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    a.<span class="property">name</span> = <span class="string">"极客邦"</span> </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p><p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p><p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 {name:” 极客邦”}。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p><p>要彻底弄清楚这个问题，我们就得先从 “JavaScript 是什么类型的语言” 讲起。</p><h2 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript 是什么类型的语言</h2><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span>* b = <span class="string">"极客时间"</span>;</span><br><span class="line">   <span class="type">bool</span> c = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。<strong>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言</strong>。</p><p>相反地，<strong>我们把在运行过程中需要检查数据类型的语言称为动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p><p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a</span><br></pre></td></tr></tbody></table></figure><p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为<strong>隐式类型转换</strong>。而<strong>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</strong>。在这点上，C 和 JavaScript 都是弱类型语言。</p><p>对于各种语言的类型，你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/662f08c70ea9cb14030a18d5.png" alt="语言类型图"></p><h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript 的数据类型</h2><p>现在我们知道了，<strong>JavaScript 是一种弱类型的、动态的语言</strong>。那这些特点意味着什么呢？</p><ul><li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li><li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。<br>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line">bar = <span class="string">"极客时间"</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line">bar = {<span class="attr">name</span>:<span class="string">"极客时间"</span>}</span><br></pre></td></tr></tbody></table></figure><p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p><p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用 “typeof” 运算符。具体使用方式如下所示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar)  <span class="comment">//undefined</span></span><br><span class="line">bar = <span class="number">12</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//number</span></span><br><span class="line">bar = <span class="string">"极客时间"</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar)<span class="comment">//string</span></span><br><span class="line">bar = <span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//boolean</span></span><br><span class="line">bar = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br><span class="line">bar = {<span class="attr">name</span>:<span class="string">"极客时间"</span>}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar) <span class="comment">//object</span></span><br></pre></td></tr></tbody></table></figure><p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p><p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td> Boolean</td><td> 只有 true 和 false 两个值。</td></tr><tr><td>Null</td><td> 只有一个值 null。</td></tr><tr><td>Undefined</td><td> 一个没有被赋值的变量会有个默认值 undefined，变量提升时的默认值也是  undefined。</td></tr><tr><td>Number</td><td> 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值，-（263-1） 到 263-1。</td></tr><tr><td>BigInt</td><td>JavaScript 中一个新的数字类型，可以用任意精度表示整数。使用 BigInt，即使超出 Number 的安全整数范围限制，也可以安全地存储和操作。</td></tr><tr><td>String</td><td> 用于表示文本数据。不同于类 C 语言，JavaScript 的字符串是不可更改的。</td></tr><tr><td>Symbol</td><td> 符号类型是唯一的并且是不可修改的，通常用来作为 Object 的 key。</td></tr><tr><td>Object</td><td> 在 JavaScript 里，对象可以被看作是一组属性的集合。</td></tr></tbody></table><p>了解这些类型之后，还有三点需要你注意一下。</p><p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p><p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = {</span><br><span class="line">    <span class="attr">name</span>:<span class="string">'极客时间'</span>,</span><br><span class="line">    <span class="attr">update</span>:<span class="keyword">function</span>(<span class="params"></span>){....}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p><p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p><p><img data-src="https://pic.imgdb.cn/item/662f365a0ea9cb140367ced0.png" alt="JavaScript内存模型"></p><p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间</strong>、<strong>栈空间</strong>和<strong>堆空间</strong>。</p><p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p><h3 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h3><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"极客时间"</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = {<span class="attr">name</span>:<span class="string">"极客时间"</span>}</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">}</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p><p><img data-src="https://pic.imgdb.cn/item/662f39710ea9cb1403700ee8.png" alt="执行到第3行时的调用栈状态图"></p><p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p><p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在 “堆” 中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p><p><img data-src="https://pic.imgdb.cn/item/662f39c70ea9cb140370a882.png" alt="对象类型是“堆”来存储"></p><p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p><p>好了，现在你应该知道了<strong>原始类型的数据值都是直接保存在 “栈” 中的，引用类型的值是存放在 “堆” 中的</strong>。不过你也许会好奇，为什么一定要分 “堆” 和 “栈” 两个存储空间呢？所有数据直接存放在 “栈” 中不就可以了吗？</p><p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/662f3adb0ea9cb140372c501.png" alt="调用栈中切换执行上下文状态"></p><p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p><p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p><p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p><p>所以 <code>d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/662f3b720ea9cb140373eef6.png" alt="引用赋值"></p><p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p><h2 id="再谈闭包"><a href="#再谈闭包" class="headerlink" title="再谈闭包"></a>再谈闭包</h2><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p><p>例如下面这段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"极客时间"</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> innerBar = { </span><br><span class="line">        <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">newName</span>){</span><br><span class="line">            myName = newName</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(test1)</span><br><span class="line">            <span class="keyword">return</span> myName</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> innerBar</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>()</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">"极客邦"</span>)</span><br><span class="line">bar.<span class="title function_">getName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">getName</span>())</span><br></pre></td></tr></tbody></table></figure><p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p><p>但是在那篇文章中，我们介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p><p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p><ol><li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li><li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个 “closure (foo)” 的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li><li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到 “closure (foo)” 对象中。这时候堆中的 “closure (foo)” 对象中就包含了 myName 和 test1 两个变量了。</li><li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。<br>通过上面的分析，我们可以画出执行到 foo 函数中 “return innerBar” 语句时的调用栈状态，如下图所示：</li></ol><p><img data-src="https://pic.imgdb.cn/item/662f3cce0ea9cb140376c689.png" alt="闭包的产生过程"></p><p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 “closure (foo)” 对象，所以即使 foo 函数退出了，“ closure (foo)” 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 <code>bar.setName</code> 或者 <code>bar.getName</code> 时，创建的执行上下文中就包含了 “closure (foo)”。</p><p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p><p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类 —— 原始类型和引用类型。</p><p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p><p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p><p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>]]></content>
    
    
    <summary type="html">对于前端开发者来说，JavaScript的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道JavaScript的内存机制是什么。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="javascript" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/javascript/"/>
    
    <category term="v8" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/javascript/v8/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript" scheme="https://note.batype.com/tags/javascript/"/>
    
    <category term="v8" scheme="https://note.batype.com/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>什么是 JavaScript 的调用栈</title>
    <link href="https://note.batype.com/browser/javascript/stack.html"/>
    <id>https://note.batype.com/browser/javascript/stack.html</id>
    <published>2024-04-17T08:48:12.857Z</published>
    <updated>2024-04-18T08:42:55.733Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p><p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">b,c</span>){</span><br><span class="line">  <span class="keyword">return</span> b+c</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addAll</span>(<span class="params">b,c</span>){</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">10</span></span><br><span class="line">result = <span class="title function_">add</span>(b,c)</span><br><span class="line"><span class="keyword">return</span>  a+result+d</span><br><span class="line">}</span><br><span class="line"><span class="title function_">addAll</span>(<span class="number">3</span>,<span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure><p>在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p><p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p><p>第一步，创建全局上下文，并将其压入栈底。如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/66208e950ea9cb1403d68448.png" alt="全局执行上下文压栈"></p><p>从图中你也可以看出，变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</p><p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662090130ea9cb1403e0909e.png" alt="赋值操作改变执行上下文中的值"></p><p>接下来，第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662090720ea9cb1403e2eec8.png" alt="执行addAll函数时的调用栈"></p><p>addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</p><p>然后接着往下执行，第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662090a30ea9cb1403e425b4.png" alt="执行add函数时的调用栈"></p><p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662090c80ea9cb1403e523a9.png" alt="add函数执行结束时的调用栈"></p><p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/662090f60ea9cb1403e639d6.png" alt="addAll函数执行结束时的调用栈"></p><p>至此，整个 JavaScript 流程执行结束了。</p><p>好了，现在你应该知道了<strong>调用栈是 JavaScript 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p><h2 id="在开发中，如何利用好调用栈"><a href="#在开发中，如何利用好调用栈" class="headerlink" title="在开发中，如何利用好调用栈"></a>在开发中，如何利用好调用栈</h2><p>鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。</p><h3 id="如何利用浏览器查看调用栈的信息"><a href="#如何利用浏览器查看调用栈的信息" class="headerlink" title="如何利用浏览器查看调用栈的信息"></a>如何利用浏览器查看调用栈的信息</h3><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p><p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开 “开发者工具”，点击 “Source” 标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边 “call stack” 来查看当前的调用栈的情况，如下图：</p><p><img data-src="https://pic.imgdb.cn/item/6620919e0ea9cb1403ea1c3f.png" alt="查看函数调用关系"></p><p>从图中可以看出，右边的 “call stack” 下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以<strong>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的</strong>。</p><p>除了通过断点来查看调用栈，你还可以使用 console.trace () 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace ()，你就可以看到控制台输出的结果，如下图：</p><p><img data-src="https://pic.imgdb.cn/item/662091dd0ea9cb1403ebbedf.png" alt="使用trace函数输出当前调用栈信息"></p><h3 id="栈溢出（Stack-Overflow）"><a href="#栈溢出（Stack-Overflow）" class="headerlink" title="栈溢出（Stack Overflow）"></a>栈溢出（Stack Overflow）</h3><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</p><p>特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">division</span>(<span class="params">a,b</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">division</span>(a,b)</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">division</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><p>当执行时，就会抛出栈溢出错误，如下图：</p><p><img data-src="https://pic.imgdb.cn/item/662092120ea9cb1403ed1894.png" alt="栈溢出错误"></p><p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p><p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p><p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"极客世界"</span></span><br><span class="line">    <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">let</span> myName = <span class="string">"Chrome浏览器"</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">var</span> myName = <span class="string">"极客邦"</span></span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">        <span class="title function_">bar</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"极客时间"</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></tbody></table></figure><h2 id="调用栈分析"><a href="#调用栈分析" class="headerlink" title="调用栈分析"></a>调用栈分析</h2><p><img data-src="https://pic.imgdb.cn/item/661f8ef80ea9cb140395bde2.png" alt="调用栈分析图"></p><p>当 <code>foo</code> 在执行时</p><ol><li>会先去它当前所在的 <code>if</code> 词法环境中查找；</li><li>在去 <code>bar</code> 所在的词法环境中查找；</li><li>再去 <code>bar</code> 所在的变量环境中查找；</li><li>全局执行上下文中的词法环境中查找；</li><li>最后在变量环境下去查找。</li></ol><p>最终输出：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">JavaScript引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="javascript" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/javascript/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript" scheme="https://note.batype.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染流程</title>
    <link href="https://note.batype.com/browser/protocol/http/render.html"/>
    <id>https://note.batype.com/browser/protocol/http/render.html</id>
    <published>2024-04-16T06:18:49.538Z</published>
    <updated>2024-04-16T09:57:46.690Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/browser/protocol/http-navigation.html">上一篇文章</a>中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你 “看透” 页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局等等。</p><p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p><p><img data-src="https://pic.imgdb.cn/item/661e19540ea9cb1403fbcf01.png" alt="渲染流程示意图"></p><p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p><p>这中间的<strong>渲染模块</strong>就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p><p><img data-src="https://pic.imgdb.cn/item/661e19680ea9cb1403fbf33d.png" alt="HTML、CSS和JavaScript关系图"></p><p>从上图可以看出，HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。比如上面的 <code>&lt;p&gt;</code> 标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容。</p><p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为<strong>层叠样式表，是由选择器和属性组成</strong>，比如图中的 p 选择器，它会把 HTML 里面 <code>&lt;p&gt;</code> 标签的内容选择出来，然后再把选择器的属性值应用到 <code>&lt;p&gt;</code> 标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把 <code>&lt;p&gt;</code> 标签的内容显示为红色。</p><p>至于 <strong>JavaScript（简称为 JS），使用它可以使网页的内容 “动” 起来</strong>，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p><p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e26820ea9cb1403168ad3.png" alt="渲染流水线示意图"></p><p>按照渲染的时间顺序，流水线可以分为如下几个子阶段：构建 DOM 数、计算样式、布局节点、分层、绘制、分块、光栅化和合成。接下来，在介绍每一段的过程中，你应该注意关注以下三点内容：</p><ul><li>开始每个子阶段都有输入内容；</li><li>然后每个子阶段有其他处理过程；</li><li>最终每个子阶段会生成输出内容。<br>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</li></ul><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 ——DOM 树。</p><p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p><p><img data-src="https://pic.imgdb.cn/item/661e269f0ea9cb140316b3e5.png" alt="树结构示意图"></p><p>从图中可以看出，树这种结构非常像我们现实生活中的 “树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p><p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e275a0ea9cb140317df8e.png" alt="DOM树构建过程示意图"></p><p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p><p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的 “开发者工具”，选择 “Console” 标签来打开控制台，然后在控制台里面输入 “document” 后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e278f0ea9cb14031835ea.png" alt="DOM可视化"></p><p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p><p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">"p"</span>)[<span class="number">0</span>].<span class="property">innerText</span> = <span class="string">"black"</span></span><br></pre></td></tr></tbody></table></figure><p>这行代码的作用是把第一个 <code>&lt;p&gt;</code> 标签的内容修改为 black，具体执行结果你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e27e70ea9cb140318cb4e.png" alt="通过JavaScript修改DOM"></p><p>从图中可以看出，在执行了一段修改第一个 <code>&lt;p&gt;</code> 标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。</p><p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p><h2 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h2><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p><h3 id="1-把CSS转换为浏览器能够理解的结构"><a href="#1-把CSS转换为浏览器能够理解的结构" class="headerlink" title="1. 把CSS转换为浏览器能够理解的结构"></a>1. 把 CSS 转换为浏览器能够理解的结构</h3><p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e28840ea9cb140319c468.png" alt="HTML加载CSS的三种方式"></p><p>从图中可以看出，CSS 样式来源主要有三种：</p><ul><li>通过 link 引用的外部 CSS 文件；</li><li><code>&lt;style&gt;</code> 标记内的 CSS；</li><li>元素的 style 属性内嵌的 CSS<br>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 ——styleSheets</strong>。</li></ul><p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p><p><img data-src="https://pic.imgdb.cn/item/661e289f0ea9cb140319f7af.png" alt="styleSheets"></p><p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p><h3 id="2-转换样式表中的属性值，使其标准化"><a href="#2-转换样式表中的属性值，使其标准化" class="headerlink" title="2. 转换样式表中的属性值，使其标准化"></a>2. 转换样式表中的属性值，使其标准化</h3><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p><p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {   <span class="attribute">font-size</span>: <span class="number">2em</span>        }</span><br><span class="line"><span class="selector-tag">p</span> {      <span class="attribute">color</span>: blue;          }</span><br><span class="line"><span class="selector-tag">span</span>  {  <span class="attribute">display</span>: none         }</span><br><span class="line"><span class="selector-tag">div</span> {    <span class="attribute">font-weight</span>: bold     }</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> { <span class="attribute">color</span>: green;         }</span><br><span class="line"><span class="selector-tag">div</span> {    <span class="attribute">color</span>: red;           }</span><br></pre></td></tr></tbody></table></figure><p>可以看到上面的 CSS 文本中有很多属性值，如 <code>2em</code>、<code>blue</code>、<code>bold</code>，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p><p>那标准化后的属性值是什么样子的？</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {   <span class="attribute">font-size</span>: <span class="number">36px</span>       }</span><br><span class="line"><span class="selector-tag">p</span> {      <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>) }</span><br><span class="line"><span class="selector-tag">span</span>  {  <span class="attribute">display</span>: none         }</span><br><span class="line"><span class="selector-tag">div</span> {    <span class="attribute">font-weight</span>: <span class="number">700</span>      }</span><br><span class="line"><span class="selector-tag">div</span>  <span class="selector-tag">p</span> { <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>) }</span><br><span class="line"><span class="selector-tag">div</span> {    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>) }</span><br></pre></td></tr></tbody></table></figure><p>可以看到，2em 被解析成了 32px，red 被解析成了 rgb (255,0,0)，bold 被解析成了 700……</p><h3 id="3-计算出DOM树中每个节点的具体样式"><a href="#3-计算出DOM树中每个节点的具体样式" class="headerlink" title="3. 计算出DOM树中每个节点的具体样式"></a>3. 计算出 DOM 树中每个节点的具体样式</h3><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p><p>这就涉及到 CSS 的继承规则和层叠规则了。</p><p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {  <span class="attribute">font-size</span>: <span class="number">20px</span>             }</span><br><span class="line"><span class="selector-tag">p</span> {     <span class="attribute">color</span>: blue;                }</span><br><span class="line"><span class="selector-tag">span</span>  { <span class="attribute">display</span>: none               }</span><br><span class="line"><span class="selector-tag">div</span> {   <span class="attribute">font-weight</span>: bold;<span class="attribute">color</span>:red }</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> { <span class="attribute">color</span>: green;               }</span><br></pre></td></tr></tbody></table></figure><p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e2c530ea9cb14031eba5c.png" alt="计算后DOM的样式"></p><p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p><p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，再选择 “style” 子标签，你会看到如下界面：</p><p><img data-src="https://pic.imgdb.cn/item/661e2c820ea9cb14031edcbd.png" alt="样式的继承过程界面"></p><p>这个界面展示的信息很丰富，大致可描述为如下。</p><ul><li>首先，可以选择要查看的<strong>元素的样式（位于图中的区域 2 中）</strong>，在图中的第 1 个区域中点击对应的元素，就可以在下面的区域查看该元素的样式了。比如这里我们选择的元素是 <code>&lt;p&gt;</code> 标签，位于 <code>html.body.div.</code> 这个路径下面。</li><li>其次，可以从<strong>样式来源（位于图中的区域 3 中）</strong>中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。<strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式</strong>。</li><li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。<br>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</li></ul><p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称 “层叠样式表” 正是强调了这一点</strong>。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。</p><p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p><p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，然后再选择 “Computed” 子标签，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e2cb90ea9cb14031f29e4.png" alt="DOM元素最终计算的样式"></p><p>上图红色方框中显示了 <code>html.body.div.p</code> 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了。</p><h2 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h2><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p><p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p><h3 id="1-创建布局树"><a href="#1-创建布局树" class="headerlink" title="1. 创建布局树"></a>1. 创建布局树</h3><p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 <code>display:none</code> 属性的元素。所以在<strong>显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p><p>我们结合下图来看看布局树的构造过程：</p><p><img data-src="https://pic.imgdb.cn/item/661e2f090ea9cb1403231904.png" alt="布局树构造过程示意图"></p><p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 <code>body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树。</li></ul><h3 id="2-布局计算"><a href="#2-布局计算" class="headerlink" title="2. 布局计算"></a>2. 布局计算</h3><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p><p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p><p>答案依然是否定的。</p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p><p>要想直观地理解什么是图层，你可以打开 Chrome 的 “开发者工具”，选择 “Layers” 标签，就可以可视化页面的分层情况，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e3b160ea9cb1403381d0c.png" alt="渲染引擎给页面多图层示意图"></p><p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e3b7a0ea9cb140338effe.png" alt="图层叠加的最终展示页面"></p><p>现在你知道了<strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e3bdf0ea9cb140339b58c.png" alt="布局树和图层树关系示意图"></p><p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层</strong>。</p><p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p><p><img data-src="https://pic.imgdb.cn/item/661e3c340ea9cb14033a6f64.png" alt="层叠上下文示意图"></p><p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p><p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层</strong>。</p><p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> {</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow</span>:auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: gray;</span></span><br><span class="line"><span class="language-css">        } </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这里我们把 div 的大小限定为 <code>200 * 200</code> 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 <code>200 * 200</code> 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：</p><p><img data-src="https://pic.imgdb.cn/item/661e3e1d0ea9cb14033e8787.png" alt="剪裁执行结果"></p><p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e3e350ea9cb14033eb626.png" alt="被裁剪的内容会出现在单独一层"></p><p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p><h2 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p><p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p><p>通常，你会把你的绘制操作分解为三步：</p><ol><li>绘制蓝色背景；</li><li>在中间绘制一个红色的圆；</li><li>再在圆上绘制绿色三角形。<br>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</li></ol><p><img data-src="https://pic.imgdb.cn/item/661e3ebc0ea9cb14033fe7b4.png" alt="绘制列表"></p><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p><p>你也可以打开 “开发者工具” 的 “Layers” 标签，选择 “document” 层，来实际体验下绘制列表，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e3f250ea9cb14034112d7.png" alt="一个图层的绘制列表"></p><p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p><h2 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p><img data-src="https://pic.imgdb.cn/item/661e3fbc0ea9cb140342453f.png" alt="渲染进程中的合成线程和主线程"></p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p><p>那我们得先来看看什么是视口，你可以参看下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e403d0ea9cb1403435f72.png" alt="视口"></p><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块</strong>（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e40a20ea9cb1403440a1c.png" alt="图层被划分为图块示意图"></p><p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661e40fb0ea9cb140344bde8.png" alt="合成线程提交图块给栅格化线程池"></p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e412d0ea9cb140345186c.png" alt="GPU栅格化"></p><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><h2 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 ——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p><h2 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h2><p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p><p><img data-src="https://pic.imgdb.cn/item/661e41d80ea9cb1403463b38.png" alt="完整的渲染流水线示意图"></p><p>结合上图，我们可以大致总结为：</p><ul><li>渲染进程将 HTML 内容转化为浏览器可以识别的 DOM 树结构；</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式；</li><li>创建布局树，并计算元素的布局信息；</li><li>对布局树进行分层，并生成分层树；</li><li>为每个图床生成<strong>绘制列表</strong>，并将其提交到合成线程；</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转化成位图；</li><li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程；</li><li>浏览器根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念 ——<strong>“重排”“重绘” 和 “合成”</strong>。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p><h3 id="1-更新了元素的几何属性（重排）"><a href="#1-更新了元素的几何属性（重排）" class="headerlink" title="1. 更新了元素的几何属性（重排）"></a>1. 更新了元素的几何属性（重排）</h3><p>你可先参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e4a980ea9cb140354fc18.png" alt="更新元素的几何属性"></p><p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p><h3 id="2-更新元素的绘制属性（重绘）"><a href="#2-更新元素的绘制属性（重绘）" class="headerlink" title="2. 更新元素的绘制属性（重绘）"></a>2. 更新元素的绘制属性（重绘）</h3><p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e4af50ea9cb140355ae73.png" alt="更新元素背景"></p><p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p><h3 id="3-直接合成阶段"><a href="#3-直接合成阶段" class="headerlink" title="3. 直接合成阶段"></a>3. 直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。具体流程参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661e4b6d0ea9cb14035676b3.png" alt="避开重排和重绘"></p><p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p><p>通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。</p>]]></content>
    
    
    <summary type="html">HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML文件、CSS文件、JavaScript文件、图片、视频等。此外，HTTP也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解HTTP。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="http" scheme="https://note.batype.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>导航流程：从输入 URL 到页面展示，这中间发生了什么？</title>
    <link href="https://note.batype.com/browser/protocol/http-navigation.html"/>
    <id>https://note.batype.com/browser/protocol/http-navigation.html</id>
    <published>2024-04-15T06:19:53.177Z</published>
    <updated>2024-04-16T01:59:28.681Z</updated>
    
    <content type="html"><![CDATA[<p>“在浏览器里，从输入 URL 到页面展示，这中间发生了什么？” 这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。所以我在面试应聘者时也必问这道题，但遗憾的是大多数人只能回答其中部分零散的知识点，并不能将这些知识点串联成线，无法系统而又全面地回答这个问题。</p><p>那么今天我们就一起来探索下这个流程，下图是我梳理出的 “从输入 URL 到页面展示完整流程示意图”：</p><p><img data-src="https://pic.imgdb.cn/item/661ccfd568eb9357138671dd.png" alt="从输入URL到页面展示完整流程示意图"></p><p>从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾一下浏览器进程、渲染进程和网络进程的主要职责：</p><ul><li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能；</li><li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能；</li><li>渲染进程的主要责任是从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这是因为 Chrome 会让渲染进程运行在安全沙箱里的原因，就是为了保证系统的安全。</li></ul><p>回顾了浏览器的进程架构后，我们在结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中的和信节点用蓝色背景标记出来了。这个过程可以大致描述为如下。</p><ul><li>首先，浏览器进程收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程；</li><li>然后，在网络进程中发起真正的 URL 请求；</li><li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程；</li><li>浏览器进程接收到网络进程的数据之后，发送 “提交导航（CommitNavigation）” 消息到渲染进程；</li><li>渲染进程接收到 “接收导航” 的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li><li>最后渲染进程会向浏览器进程 “确认提交”，这便是告诉浏览器进程：“已经准备好接受和解析页面数据了”；</li><li>浏览器接收到渲染进程 “提交文档” 的消息后，便开始移除之前的旧文档的文档，然后更新浏览器进程中的页面状态。<br>这其中，<strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong>。</li></ul><h2 id="从URL输入到页面展示"><a href="#从URL输入到页面展示" class="headerlink" title="从URL输入到页面展示"></a>从 URL 输入到页面展示</h2><p>现在我们知道了浏览器几个主要进程的职责，还有在导航过程中需要经历的几个主要的阶段，下面就来详细分析下这些阶段，同时就解答了开头所说的那道经典的面试题。</p><h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><p>当用户在地址栏中输入一个人查询关键字时，地址栏会判断当前输入的关键字时<strong>搜索内容</strong>，还是 <strong>URL 请求</strong>。</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL；</li><li>如果判断输入内容符合 URL 规则，比如输入的是 <code>time.geekbang.org</code>，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <code>https://time.geekbang.org</code>。</li></ul><p>当用户输入关键字并键入回车后，这意味着当前页面将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许在页面退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如前页面可能有未提交完成的表单等情况，因此用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览不再执行任何后续工作。</p><p>当前浏览器没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：</p><p><img data-src="https://pic.imgdb.cn/item/661ce02468eb9357139f54ab.png" alt="开始加载URL浏览器状态"></p><p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。单此时图中的页面依旧还是之前打开的页面内容，并没有立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="URL请求过程"><a href="#URL请求过程" class="headerlink" title="URL请求过程"></a>URL 请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的请求流程。那具体流程是怎样的呢？</p><p>首先，网络进程会查询本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程，如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 请求，以获取请求域名的服务器 IP 地址。如果协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。浏览器建立之后，浏览器会构建请求行、请求头信息，并把和该域名相关的 Cookies 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p><h4 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1. 重定向"></a>1. 重定向</h4><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p><p>比如，我们在终端里输入以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://time.geekbang.org</span><br></pre></td></tr></tbody></table></figure><p><code>curl -I + URL</code> 的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p><p><img data-src="https://pic.imgdb.cn/item/661ced8a68eb935713b268a1.png" alt="响应行返回状态码301"></p><p>从图中可以看出，极客时间服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。</p><p>下面我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure><p>我们看到服务器返回如下信息：</p><p><img data-src="https://pic.imgdb.cn/item/661ceeb568eb935713b3acc1.png" alt="响应行返回状态码200"></p><p>从图中可以看出，服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p><p>好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p><h4 id="2-响应数据类型处理"><a href="#2-响应数据类型处理" class="headerlink" title="2. 响应数据类型处理"></a>2. 响应数据类型处理</h4><p>在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</p><p>答案是 Content-Type。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p><p>这里我们还是以极客时间为例，看看极客时间官网返回的 Content-Type 值是什么。在终端输入以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure><p>返回信息如下图：</p><p><img data-src="https://pic.imgdb.cn/item/661cef7e68eb935713b43ae4.png" alt="含有HTML格式的Content-Type"></p><p>从图中可以看到，响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。</p><p>接下来我们再来利用 curl 来请求极客时间安装包的地址，如下所示：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk</span><br></pre></td></tr></tbody></table></figure><p>请求后返回的响应头信息如下：</p><p><img data-src="https://pic.imgdb.cn/item/661cefa368eb935713b44e1d.png" alt="含有stream格式的Content-Type"></p><p>从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照<strong>下载类型</strong>来处理该请求。</p><p>需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p><p>所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是 <strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h3 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h3><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p><p>比如我从极客时间的首页里面打开了另外一个页面 —— 算法训练营，我们看下图的 Chrome 的任务管理器截图：</p><p><img data-src="https://pic.imgdb.cn/item/661cf5a068eb935713bb62d4.png" alt="多个页面运行在一个渲染进程中"></p><p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。</p><p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p><p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://time.geekbang.org</span><br><span class="line">https://www.geekbang.org</span><br><span class="line">https://www.geekbang.org:8080</span><br></pre></td></tr></tbody></table></figure><p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。</p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果<strong>从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫 process-per-site-instance。</p><p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开 InfoQ 的官网（<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vJUVGJUJDJTg5JUVGJUJDJThD">https://www.infoq.cn/），<i class="fa fa-external-link-alt"></i></span> 因为 infoq.cn 和 geekbang.org 不属于同一站点，所以 infoq.cn 会使用一个新的渲染进程，你可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/661cf5bf68eb935713bb95e2.png" alt="非同一站点使用不同的渲染进程"></p><p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有<strong>相同的协议和根域名</strong>，所以它们属于<strong>同一站点</strong>，并运行在同一个渲染进程中；而 infoq.cn 的根域名不同于 geekbang.org，也就是说 InfoQ 和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p><p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程；</li><li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><h3 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h3><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起 “提交文档” 的消息；</li><li>渲染进程接收到 “提交文档” 的消息后，会和网络进程建立传输数据的 “管道”；</li><li>等文档数据传输完成之后，渲染进程会返回 “确认提交” 的消息给浏览器进程；</li><li>浏览器进程在收到 “确认提交” 的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>其中，当渲染进程<strong>确认提交</strong>之后，更新内容如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/661cf74768eb935713bdca7e.png" alt="导航完成状态"></p><p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p><p>到这里，一个完整的导航流程就 “走” 完了，这之后就要进入渲染阶段了。</p><h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p><p><img data-src="https://pic.imgdb.cn/item/661cf76a68eb935713be0285.png" alt="渲染结束"></p><p>至此，一个完整的页面就生成了。那文章开头的 “从输入 URL 到页面展示，这中间发生了什么？” 这个过程及其 “串联” 的问题也就解决了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p><ul><li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li><li>Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li><li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li></ul><p>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。</p>]]></content>
    
    
    <summary type="html">“在浏览器里，从输入URL到页面展示，这中间发生了什么？ ”这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web等一系列的知识。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="http" scheme="https://note.batype.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 请求流程</title>
    <link href="https://note.batype.com/browser/protocol/http/flow.html"/>
    <id>https://note.batype.com/browser/protocol/http/flow.html</id>
    <published>2024-04-11T06:15:40.880Z</published>
    <updated>2024-04-16T06:19:36.779Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。</p><p>不知道你是否有过下面这些疑问：</p><ol><li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li><li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li></ol><p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识。</p><h2 id="浏览器端发起HTTP请求流程"><a href="#浏览器端发起HTTP请求流程" class="headerlink" title="浏览器端发起HTTP请求流程"></a>浏览器端发起 HTTP 请求流程</h2><p>如果你在浏览器地址栏里键入极客时间网站的地址：<code>http://time.geekbang.org/index.html</code>，那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细 “追踪” 下。</p><h3 id="1-构建请求"><a href="#1-构建请求" class="headerlink" title="1. 构建请求"></a>1. 构建请求</h3><p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP1.1</span><br></pre></td></tr></tbody></table></figure><h3 id="2-查找缓存"><a href="#2-查找缓存" class="headerlink" title="2. 查找缓存"></a>2. 查找缓存</h3><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p><p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p><ul><li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li><li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li></ul><p>当然，如果缓存查找失败，就会进入网络请求过程了。</p><h3 id="3-准备IP地址和端口"><a href="#3-准备IP地址和端口" class="headerlink" title="3. 准备IP地址和端口"></a>3. 准备 IP 地址和端口</h3><p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 <strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用 <strong>TCP/IP 作传输层协议</strong>将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 <strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的</strong>，你可以结合下图更好地理解这二者的关系。</p><p><img data-src="https://pic.imgdb.cn/item/6617817268eb93571332e6ba.png" alt="HTTP和TCP的关系图"></p><p>那接下来你可以思考这么 “一连串” 问题：</p><ul><li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li><li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li><li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li></ul><p>在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 47.108.140.70, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做 “<strong>域名系统</strong>”，简称 <strong>DNS</strong>（Domain Name System）。</p><p>所以，这样一路推导下来，你会发现在<strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了 <strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p><p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p><h3 id="4-等待TCP队列"><a href="#4-等待TCP队列" class="headerlink" title="4. 等待TCP队列"></a>4. 等待 TCP 队列</h3><p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p><p>答案依然是 “不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p><p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p><h3 id="5-建立TCP连接"><a href="#5-建立TCP连接" class="headerlink" title="5. 建立TCP连接"></a>5. 建立 TCP 连接</h3><p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p><h3 id="6-发送HTTP请求"><a href="#6-发送HTTP请求" class="headerlink" title="6. 发送HTTP请求"></a>6. 发送 HTTP 请求</h3><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p><p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p><p><img data-src="https://pic.imgdb.cn/item/6617825968eb93571334d43f.png" alt="HTTP请求数据格式"></p><p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p><p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p><p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p><p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p><h2 id="服务器端处理HTTP请求流程"><a href="#服务器端处理HTTP请求流程" class="headerlink" title="服务器端处理HTTP请求流程"></a>服务器端处理 HTTP 请求流程</h2><p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。</p><h3 id="1-返回请求"><a href="#1-返回请求" class="headerlink" title="1. 返回请求"></a>1. 返回请求</h3><p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i  https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure><p>注意这里加上了 <code>-i</code> 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p><p><img data-src="https://pic.imgdb.cn/item/661792e568eb9357134fa9f3.png" alt="服务器响应的数据格式"></p><p>首先服务器会返回响应行，包括协议版本和状态码。</p><p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p><ul><li>最常用的状态码是 200，表示处理成功；</li><li>如果没有找到页面，则会返回 404。</li></ul><p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p><p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p><p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p><p>以上这些就是服务器响应浏览器的具体过程。</p><h3 id="2-断开连接"><a href="#2-断开连接" class="headerlink" title="2. 断开连接"></a>2. 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive </span><br></pre></td></tr></tbody></table></figure><p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p><h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h3><p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 <code>geekbang.org</code> 后，你会发现最终打开的页面地址是 <code>https://www.geekbang.org</code>。</p><p>这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 <code>geekbang.org</code> 会返回什么内容？</p><p>在控制台输入如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I geekbang.org</span><br></pre></td></tr></tbody></table></figure><p>注意这里输入的参数是 - I，和 - i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p><p><img data-src="https://pic.imgdb.cn/item/6617935568eb9357135076d5.jpg" alt="服务器返回响应行和响应头（含重定向格式）"></p><p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <code>https://www.geekbang.org</code> 了。</p><p>不过也不要认为这种跳转是必然的。如果你打开 <code>https://12306.cn</code>，你会发现这个站点是打不开的。这是因为 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 <code>https://www.12306.cn</code> 才能打开页面。</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p><h3 id="1-为什么很多站点第二次打开速度会很快？"><a href="#1-为什么很多站点第二次打开速度会很快？" class="headerlink" title="1. 为什么很多站点第二次打开速度会很快？"></a>1. 为什么很多站点第二次打开速度会很快？</h3><p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p><p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，<strong>DNS 缓存</strong>和<strong>页面资源缓存</strong>这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p><p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p><p><img data-src="https://pic.imgdb.cn/item/661793fc68eb93571351b089.png" alt="缓存查找流程示意图"></p><p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p><p>从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:Max-age=2000</span><br></pre></td></tr></tbody></table></figure><p>这也就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p><p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match:"4f80f-13c-3a1xb12a"</span><br></pre></td></tr></tbody></table></figure><p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p><ul><li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li><li> 如果资源有更新，服务器就直接返回最新资源给浏览器。</li></ul><p>关于缓存的细节内容特别多，具体细节你可以参考这篇 HTTP 缓存，在这里我就不赘述了。</p><p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。</p><h3 id="2-登录状态是如何保持的？"><a href="#2-登录状态是如何保持的？" class="headerlink" title="2. 登录状态是如何保持的？"></a>2. 登录状态是如何保持的？</h3><p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p><ul><li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li><li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure><ul><li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。</li><li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure><ul><li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的 “Cookie” 字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li><li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li></ul><p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p><p><img data-src="https://pic.imgdb.cn/item/6617947368eb93571352ffc1.png" alt="Cookie流程图"></p><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p><p>为了便于你理解，我画了下面这张详细的 “HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p><p><img data-src="https://pic.imgdb.cn/item/661794b368eb9357135378b3.png" alt="HTTP请求流程示意图"></p><p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p><p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p><p>通过今天系统的讲解，想必你已经了解了一个 HTTP 完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p><p>另外，你应该也看出来了本篇文章是有很多分析问题的思路在里面的。所以在学习过程中，你也要学会提问，通过最终要做什么和现在有什么，去一步步分析并提出一些问题，让疑问带领着你去学习，抓住几个本质的问题就可以学透相关知识点，让你能站在更高维度去查看整体框架。希望它能成为你的一个学习技巧吧！</p><h2 id="思考时间"><a href="#思考时间" class="headerlink" title="思考时间"></a>思考时间</h2><p>最后，还是留给你个思考题：结合今天所讲 HTTP 请求的各个阶段，如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>]]></content>
    
    
    <summary type="html">HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如HTML文件、CSS文件、JavaScript文件、图片、视频等。此外，HTTP也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解HTTP。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="http" scheme="https://note.batype.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Admin 如何配合部署到线上</title>
    <link href="https://note.batype.com/2024/04/03/Hexo-Admin-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A/"/>
    <id>https://note.batype.com/2024/04/03/Hexo-Admin-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A/</id>
    <published>2024-04-03T09:36:50.000Z</published>
    <updated>2024-04-03T09:47:05.535Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo Admin 是一个为 Hexo 博客框架提供的一个管理界面，允许用户通过一个比较直观的 Web 界面来写文章和管理博客。若要将使用 Hexo Admin 编辑的博客部署到线上，需要遵循一些标准的步骤。以下是一个基本的流程：</p><h3 id="安装-Hexo-Admin"><a href="#安装-Hexo-Admin" class="headerlink" title="安装 Hexo Admin"></a>安装 Hexo Admin</h3><p>安装 Hexo Admin 插件前，请确保你的 Hexo 博客已经在本地运行。</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></tbody></table></figure><p>然后，重新启动你的 Hexo 服务器：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure><p>在浏览器中打开 <code>http://localhost:4000/admin</code>，你应该能看到 Hexo Admin 的管理界面。</p><h3 id="配置-Hexo-Admin"><a href="#配置-Hexo-Admin" class="headerlink" title="配置 Hexo Admin"></a>配置 Hexo Admin</h3><p>Hexo Admin 默认情况下没有密码保护，如果你希望你的编辑界面更加安全，可以在你的 <code>_config.yml</code> 配置文件中对 Hexo Admin 进行配置：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">myUsername</span></span><br><span class="line">  <span class="attr">password_hash:</span> <span class="string">myPasswordHash</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">mySecret</span></span><br></pre></td></tr></tbody></table></figure><p><code>password_hash</code> 是你密码的 bcrypt 哈希，可以使用在线 bcrypt 工具生成。<code>secret</code> 用于签署 cookie，可以是任何随机字符串。</p><h3 id="部署博客到线上"><a href="#部署博客到线上" class="headerlink" title="部署博客到线上"></a>部署博客到线上</h3><p>Hexo 默认支持多种部署选项，如 Git、Heroku、Netlify、AWS S3 等，你可以使用以下命令来部署你的博客：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>为了使用 <code>hexo deploy</code>，需要在你的博客根目录下的 <code>_config.yml</code> 文件中正确配置你的部署方法。例如，如果使用 Git 部署，你的配置可能如下所示：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>]</span><br></pre></td></tr></tbody></table></figure><p>这需要你已经设置了对应的 Git 仓库，并且你的本地环境能够推送到这个仓库。</p><h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p>很多人选择将博客托管在像 GitHub Pages 或 Netlify 这样的平台上，并设置持续集成来自动化部署过程。每当你向 Git 仓库推送新的内容，CI 工具会自动运行 <code>hexo generate</code> 生成网站静态文件，并将它们部署到服务器上。这样，你只需关注内容编辑，不用手动进行部署。</p><p>如果你在本机上使用 Hexo Admin 编辑内容，你可以在编辑完成后使用 Git 命令提交并推送更改到远端仓库：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"Add new post"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><p>之后，你配置的 CI 工具（如 Travis CI、GitHub Actions 等）会自动捕捉到新的提交，并开始部署流程。</p><p>请注意，留意 Hexo Admin 插件是否开放于公共网络。若你的 Hexo server 在生产模式对外开放，记得配置安全措施，如密码保护以防止未经授权的访问。</p>]]></content>
    
    
    <summary type="html">Hexo Admin 是一个为 Hexo 博客框架提供的一个管理界面，允许用户通过一个比较直观的Web界面来写文章和管理博客。若要将使用 Hexo Admin 编辑的博客部署到线上，需要遵循一些标准的步骤。</summary>
    
    
    
    <category term="hexo" scheme="https://note.batype.com/categories/hexo/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="hexo" scheme="https://note.batype.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>事件循环（Event Loop）</title>
    <link href="https://note.batype.com/javascript/eventloop.html"/>
    <id>https://note.batype.com/javascript/eventloop.html</id>
    <published>2024-04-03T09:17:29.919Z</published>
    <updated>2024-04-03T09:17:29.919Z</updated>
    
    <content type="html"><![CDATA[<p>事件循环（Event Loop）是计算机程序中的一个设计模式，用于处理异步操作，特别是在图形用户界面程序和服务器端应用程序中。事件循环模式通过等待并分派事件或回调函数来驱动程序的执行流程，而不是通过直接执行代码的方式。</p><p>在编程领域，事件循环通常余非阻塞 I/O 和异步编程模型结合使用。这种模式允许程序在等待一个长时间操作（如网络请求或磁盘 I/O）完成时继续处理其他任务。一旦长时间操作完成，相关的回调函数就会被放入事件循环中等待执行。</p><p>事件循环的基本工作原理如下：</p><ol><li>事件循环开始时，它首先检查是否有任何事件或回调函数需要执行。</li><li>如果没有事件或回调函数需要执行，事件循环将进入休眠状态，等待新事件或回调函数的到来。</li><li>当有事件或回调函数需要执行时，事件循环从等待队列中取出事件或回调函数，并将其放入执行队列中。</li><li>事件循环从执行队列中取出事件或回调函数，并执行它们。</li><li>执行完成后，事件循环将事件或回调函数从执行队列中移除，并继续等待新的事件或回调函数。</li></ol><p>在 JavaScript 中，事件循环通常由 JavaScript 引擎和宿主环境（如浏览器或 Node.js）共同实现。JavaScript 引擎负责执行代码，而宿主环境负责管理事件和回调函数。</p><p>如下代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'2'</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'3'</span>);</span><br><span class="line">    }, <span class="number">0</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'4'</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>执行过程：</p><ol><li>现将 <code>console.log('1');</code> 放入执行队列中，并立即执行。</li><li>将 <code>setTimeout(() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }, 0);</code> 放入宏任务队列中。</li><li>将 <code>console.log('4');</code> 放入执行队列中，并立即执行。</li><li>将 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code> 放入微任务队列中；</li><li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code>；</li><li>将 <code>console.log('2');</code> 放入执行队列中，并立即执行。</li><li>将 <code>setTimeout(() =&gt; { console.log('3'); }, 0);</code> 放入宏任务队列中；</li><li>将 <code>() =&gt; { console.log('3'); }</code> 放入微任务队列中；</li><li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('3'); }</code>；</li><li>将 <code>console.log('3');</code> 放入执行队列中，并立即执行。</li></ol><p>微任务（Microtask）和宏任务（Macrotask）是 JavaScript 中事件循环机制的两个重要概念，它们决定了异步代码的执行时机和顺序。以下是微任务和宏任务的主要区别以及它们各自包含的任务类型：</p><h3 id="微任务（Microtask）"><a href="#微任务（Microtask）" class="headerlink" title="微任务（Microtask）"></a>微任务（Microtask）</h3><ol><li><p><strong>定义</strong>：<br>微任务是一类非常小的任务，它们通常与当前执行栈中的代码有关，并且总是在当前执行栈清空后立即执行。</p></li><li><p><strong>特点</strong>：</p><ul><li>微任务具有高优先级，它们总是在宏任务之前执行。</li><li>微任务可以快速响应状态的变化，因为它们在每次事件循环迭代的末尾执行。</li><li>微任务的执行不会阻塞后续代码的执行。</li></ul></li><li><p><strong>包含的任务类型</strong>：</p><ul><li><code>Promise</code> 的<code>.then()</code> 回调函数。</li><li><code>MutationObserver</code> 的回调函数。</li><li>手动添加的微任务，例如使用 <code>queueMicrotask()</code> 函数。</li></ul></li></ol><h3 id="宏任务（Macrotask）"><a href="#宏任务（Macrotask）" class="headerlink" title="宏任务（Macrotask）"></a>宏任务（Macrotask）</h3><ol><li><p><strong>定义</strong>：<br>宏任务是一类较大的任务，它们通常与用户交互或 I/O 操作有关，并且总是在微任务执行完毕后执行。</p></li><li><p><strong>特点</strong>：</p><ul><li>宏任务具有较低的优先级，它们总是在微任务之后执行。</li><li>宏任务的执行可能会阻塞后续代码的执行，因为它们通常涉及到等待外部事件或资源。</li><li>宏任务的执行次数通常比微任务多，因为每次事件循环迭代可能包含多个宏任务。</li></ul></li><li><p><strong>包含的任务类型</strong>：</p><ul><li><code>setTimeout</code> 和 <code>setInterval</code> 的回调函数。</li><li><code>requestAnimationFrame</code> 的回调函数。</li><li><code>setImmediate</code>（在 Node.js 中可用）的回调函数。</li><li>浏览器事件，如点击、滚动、键盘输入等。</li><li>网络请求、文件读写等 I/O 操作完成后的回调函数。</li></ul></li></ol><h3 id="事件循环中的执行顺序"><a href="#事件循环中的执行顺序" class="headerlink" title="事件循环中的执行顺序"></a>事件循环中的执行顺序</h3><p>在 JavaScript 的事件循环中，微任务和宏任务按照以下顺序执行：</p><ol><li>执行当前执行栈中的所有同步代码。</li><li>清空当前执行栈。</li><li>执行所有微任务队列中的微任务。</li><li>执行所有宏任务队列中的宏任务。</li><li>重复步骤 1-4，直到微任务和宏任务队列都为空。</li></ol><p>这种机制确保了 JavaScript 能够以非阻塞的方式处理异步事件，同时保证了高优先级任务（如用户交互和状态变化）能够及时响应。开发者可以利用微任务和宏任务的特性来优化代码性能和用户体验。</p><p>下面实例代码包括微任务和宏任务：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 同步代码执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="comment">// 3. 宏任务执行</span></span><br><span class="line"><span class="keyword">const</span> timeoutId = <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="comment">// 4. 微任务执行</span></span><br><span class="line">    <span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'2'</span>);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">    }, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 3. 宏任务执行</span></span><br><span class="line"><span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(</span><br><span class="line">    <span class="comment">// 4. 微任务执行</span></span><br><span class="line">    <span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'3'</span>);</span><br><span class="line">        <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    }, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 1. 同步代码执行</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'5'</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">'6'</span>);</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 2. 微任务执行</span></span><br><span class="line"><span class="title function_">promise</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">})</span><br><span class="line"><span class="comment">// 1. 同步代码执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'4'</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>大家猜一下下面<strong>实例 3</strong> 的结果：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">const</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'2'</span>);</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">    (<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'8'</span>);</span><br><span class="line">    })();</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'9'</span>);</span><br><span class="line">}, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'5'</span>);</span><br><span class="line">    (<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'10'</span>);</span><br><span class="line">    })();</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">'6'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'3'</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    (<span class="function">()=&gt;</span> {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'7'</span>);</span><br><span class="line">    })();</span><br><span class="line">})</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'4'</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">事件循环（Event Loop）是计算机程序中的一个设计模式，用于处理异步操作，特别是在图形用户界面程序和服务器端应用程序中。事件循环模式通过等待并分派事件或回调函数来驱动程序的执行流程，而不是通过直接执行代码的方式。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="Event Loop" scheme="https://note.batype.com/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 详解</title>
    <link href="https://note.batype.com/browser/protocol/http.html"/>
    <id>https://note.batype.com/browser/protocol/http.html</id>
    <published>2024-04-03T09:17:29.917Z</published>
    <updated>2024-04-11T06:15:15.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP（Hypertext-Transfer-Protocol）基本信息"><a href="#HTTP（Hypertext-Transfer-Protocol）基本信息" class="headerlink" title="HTTP（Hypertext Transfer Protocol）基本信息"></a>HTTP（Hypertext Transfer Protocol）基本信息</h3><p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本数据的协议。它是一种客户端 - 服务器协议，客户端发送请求，服务器返回响应。HTTP 是 Web 的基础，用于在 Web 浏览器和 Web 服务器之间传输数据。</p><p>以下是 HTTP 的一些关键概念和详解：</p><ol><li><p>请求和响应</p><p> HTTP 通信是基于请求 - 响应模型。客户端发送 HTTP 请求到服务器，服务器处理请求并返回 HTTP 响应。</p></li><li><p>URL（Uniform Resource Locator）</p><p> URL 是用于标识资源的地址。它由协议类型（如 http:// 或 https://）、域名或 IP 地址、端口号（可选）、路径和查询参数组成。<br> URL（Uniform Resource Locator）是用于标识资源的地址。</p><p> 下面是一个 URL 的图解示例：</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│                        URL                          │</span><br><span class="line">├───────────┬─────────────┬─────────┬───────┬───────┤</span><br><span class="line">│  协议类型   │    域名/IP   │ 端口号  │  路径  │ 查询参数 │</span><br><span class="line">├───────────┴─────────────┴─────────┴───────┴───────┤</span><br><span class="line">│                     示例：                           │</span><br><span class="line">│   https://www.example.com:8080/path/to/resource?q=1 │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></tbody></table></figure><ul><li>协议类型（Protocol）：指定使用的协议，如 HTTP、HTTPS、FTP 等。</li><li>域名或 IP 地址（Domain/IP）：标识资源所在的主机名或 IP 地址。</li><li>端口号（Port）：可选项，用于指定与服务器通信的端口号，默认使用协议的默认端口号（如 HTTP 的默认端口号是 80）。</li><li>路径（Path）：指定资源在服务器上的路径，用斜杠（/）分隔不同的目录或文件。</li><li>查询参数（Query Parameters）：可选项，用于向服务器传递额外的参数，以键值对的形式出现，多个参数使用 &amp; 符号分隔。</li></ul><p> 在示例中，URL 是以 HTTPS 协议访问的，域名为<span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbSzkvb/nlKjkuoY4MDgw56uv5Y+j5Y+3Lui3r+W+hOS4ui9wYXRoL3RvL3Jlc291cmNlJUVGJUJDJThDJUU2JTlGJUE1JUU4JUFGJUEyJUU1JThGJTgyJUU2JTk1JUIwJUU0JUI4JUJBcT0xJUUzJTgwJTgy"> www.example.com，使用了 8080 端口号。路径为 /path/to/resource，查询参数为 q=1。<i class="fa fa-external-link-alt"></i></span></p><p> URL 的结构可以根据不同的协议和应用场景有所变化，但基本的组成部分是协议类型、域名或 IP 地址、端口号、路径和查询参数。通过 URL，我们可以定位和访问互联网上的各种资源。</p></li><li><p>HTTP 方法</p><p> HTTP 定义了一组方法，用于指定对资源的操作类型。常见的 HTTP 方法有 GET（获取资源）、POST（提交数据创建资源）、PUT（更新资源）、DELETE（删除资源）、PATCH（更新资源）、OPTIONS（获取资源支持的 HTTP 方法）、HEAD（获取资源头信息）。</p><ul><li><p><strong>GET</strong>：用于获取资源。客户端发送 GET 请求到服务器，服务器返回请求的资源。GET 请求通常不应该对服务器端产生副作用，即不应该修改服务器上的数据。</p></li><li><p><strong>POST</strong>：用于提交数据创建资源。客户端发送 POST 请求到服务器，请求创建一个新的资源。POST 请求通常用于提交表单数据、上传文件等操作。</p></li><li><p><strong>PUT</strong>：用于更新资源。客户端发送 PUT 请求到服务器，请求更新指定的资源。PUT 请求应该是幂等的，即多次执行相同的 PUT 请求结果应该是一致的。</p></li><li><p><strong>DELETE</strong>：用于删除资源。客户端发送 DELETE 请求到服务器，请求删除指定的资源。</p></li><li><p><strong>PATCH</strong>：用于局部更新资源。客户端发送 PATCH 请求到服务器，请求对指定的资源进行部分更新。</p></li><li><p><strong>HEAD</strong>：类似于 GET 请求，但只返回响应头信息，不返回响应体。HEAD 请求常用于获取资源的元数据，如文件大小、修改时间等，而不需要获取完整的资源内容。</p></li><li><p><strong>OPTIONS</strong>：用于获取服务器支持的 HTTP 方法和其他选项。客户端发送 OPTIONS 请求到服务器，服务器返回支持的方法和其他信息，用于客户端了解服务器的功能和配置</p></li></ul></li><li><p>请求头</p><p> HTTP 请求包含一组请求头，用于传递关于请求的元数据，如 User-Agent（客户端标识）、Content-Type（请求体的数据类型）、Authorization（身份验证信息）等。</p></li><li><p>响应头</p><p> HTTP 响应也包含一组响应头，用于传递关于响应的元数据，如 Content-Type（响应体的数据类型）、Content-Length（响应体长度）、Cache-Control（缓存策略）等。</p></li><li><p>状态码</p><p> HTTP 响应包含一个状态码，用于表示请求的处理结果。常见的状态码有 200（成功）、404（资源未找到）、500（服务器内部错误）等。</p><p> 以下是 HTTP 状态码的分类：</p><ul><li>1xx（信息性状态码）：表示接收的请求正在处理。</li><li>2xx（成功状态码）：表示请求成功被服务器接收、理解、并接受。</li><li>3xx（重定向状态码）：需要后续操作才能完成这一请求。</li><li>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成。</li><li>5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。</li></ul></li><li><p>请求体和响应体</p><p> 某些 HTTP 请求和响应可能包含一个可选的消息体，用于传递数据。请求体通常用于 POST 或 PUT 请求发送数据，而响应体用于返回请求的结果数据。</p></li><li><p>Cookie</p><p> Cookie 是一种在客户端和服务器之间传递的小型数据，用于跟踪和识别用户。服务器可以通过设置响应头中的 Set-Cookie 字段来发送 Cookie 给客户端，客户端在后续的请求中会自动将 Cookie 包含在请求头中发送给服务器。</p></li><li><p>缓存</p><p> HTTP 支持缓存机制，可以减少对服务器的请求次数，提高性能。服务器可以通过设置响应头中的 Cache-Control 字段来控制缓存策略，客户端可以通过设置请求头中的 If-Modified-Since 或 If-None-Match 字段来验证缓存的有效性。</p></li></ol><p>HTTP 是一个无状态协议，每个请求和响应之间是相互独立的。为了跟踪用户状态，HTTP 引入了 Cookie 等机制。此外，HTTP 还支持 HTTPS（HTTP Secure）协议，通过加密和身份验证来提供更安全的通信。</p><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>HTTP 协议的请求报文和响应报文的基本结构相同，由三大部分组成：</p><ul><li>起始行（start line）： 描述请求或相应的基本信息；</li><li>头部字段集合（header）：使用  <code>key-value</code> 形式更详细地说明报文</li><li>消息体（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ul><p>HTTP 报文由请求报文和响应报文两种格式组成，它们的基本结构如下：</p><ol><li>请求报文格式：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;方法&gt; &lt;URL&gt; &lt;协议版本&gt;  : 请求行</span><br><span class="line">&lt;请求头部字段1&gt;: &lt;值1&gt;</span><br><span class="line">&lt;请求头部字段2&gt;: &lt;值2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;请求体&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>请求行</strong></p><ul><li>方法：指定请求的方法，如 GET、POST 等。</li><li>URL：请求的目标资源的 URL。</li><li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li></ul></li><li><p><strong>请求头部字段</strong></p><ul><li>包含了请求的各种附加信息，如 User-Agent、Content-Type 等。</li></ul></li><li><p><strong>空行</strong></p><ul><li>用于分隔请求头部和请求体。</li></ul></li><li><p><strong>请求体</strong></p><ul><li>可选项，包含了请求的主体内容，如 POST 请求中的表单数据、PUT 请求中的更新内容等。</li></ul></li></ul><ol start="2"><li>响应报文格式：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议版本&gt; &lt;状态码&gt; &lt;状态码描述&gt;: 响应行</span><br><span class="line">&lt;响应头部字段1&gt;: &lt;值1&gt;</span><br><span class="line">&lt;响应头部字段2&gt;: &lt;值2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;空行&gt;</span><br><span class="line">&lt;响应体&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>响应行</strong></p><ul><li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li><li>状态码：表示服务器对请求的处理结果，如 200 表示成功，404 表示资源未找到等。</li><li>状态码描述：对状态码的简短描述。</li></ul></li><li><p><strong>响应头部字段</strong></p><ul><li>包含了响应的各种附加信息，如 Content-Type、Content-Length 等。</li></ul></li><li><p><strong>空行</strong></p><ul><li>用于分隔响应头部和响应体。</li></ul></li><li><p><strong>响应体</strong></p><ul><li>包含了响应的主体内容，如 HTML 页面、JSON 数据等。</li></ul></li></ul><p>HTTP 报文的格式是文本格式，使用 ASCII 编码。请求报文由客户端发送到服务器，响应报文由服务器返回给客户端。报文中的请求头部和响应头部字段提供了关于请求和响应的元数据信息，而请求体和响应体则包含了具体的数据内容。通过这种报文格式，客户端和服务器可以进行有效的通信和数据交换。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="1xx（信息性状态码）"><a href="#1xx（信息性状态码）" class="headerlink" title="1xx（信息性状态码）"></a>1xx（信息性状态码）</h4><p><code>1xx</code> 状态码是 <code>HTTP</code> 协议中的信息性状态码，表示请求已被接受，但还未完成。通常情况下，服务器会在响应中发送一些额外的信息，以帮助客户端了解请求的状态。</p><p>常见的 1xx 状态码包括：</p><ul><li>100 Continue（继续）：表示服务器已经收到请求的头部，并且客户端应该继续发送请求的主题部分。</li><li>101 Switching Protocols（切换协议）：表示服务器已经理解客户端的请求，并将切换到不同的协议，如从 <code>HTTP</code> 切换到 <code>WebSocket</code>。 </li><li>102 Processing（处理中）：表示服务器正在处理请求，但尚未完成。</li><li>103 Early Hints（早期提示）：表示服务器已经开始处理请求，但仍在生成响应的过程中，可以在响应头部发送一些提示信息。</li></ul><p>这些 1xx 状态码主要用于在请求 - 响应过程中提供一些中间状态信息，以便客户端和服务器能够更好地进行通信和处理。</p><h4 id="2xx（成功状态码）"><a href="#2xx（成功状态码）" class="headerlink" title="2xx（成功状态码）"></a>2xx（成功状态码）</h4><p>2xx 状态码是 HTTP 协议中的成功状态码，表示服务器成功处理了客户端的请求。</p><p>以下是一些常见的 2xx 状态码：</p><ul><li><p>200 OK（成功）：表示请求已成功处理，并返回了请求的内容。</p></li><li><p>201 Created（已创建）：表示请求已成功处理，并在服务器上创建了新的资源。</p></li><li><p>202 Accepted（已接受）：表示服务器已经接受了请求，但尚未完成处理。通常用于异步操作，告知客户端请求已接受，但处理尚未完成。</p></li><li><p>204 No Content（无内容）：表示服务器成功处理了请求，但没有返回任何内容。通常用于不需要返回具体内容的请求，如 DELETE 请求。</p></li></ul><p>这些 2xx 状态码表示客户端的请求已经成功处理，并且服务器能够提供相应的响应。不同的 2xx 状态码可以提供不同的信息，客户端可以根据这些状态码来判断请求的结果和下一步的操作。</p><h4 id="3xx（重定向状态码）"><a href="#3xx（重定向状态码）" class="headerlink" title="3xx（重定向状态码）"></a>3xx（重定向状态码）</h4><p>3xx 状态码是 HTTP 协议中的重定向状态码，用于指示客户端需要采取进一步的操作来完成请求。</p><p>以下是一些常见的 3xx 状态码：</p><ul><li>300 Multiple Choices（多种选择）：表示请求有多个可供选择的响应，客户端可以选择其中一个进行访问；</li><li>301 Moved Permanently（永久重定向）：表示请求的资源以永久移动到新的 <code>URL</code>，客户端应该使用新的 <code>URL</code> 进行访问；</li><li>302 Found（临时重定向）：表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。与 <code>301</code> 状态码类似，但是 <code>302</code> 状态码表示重定向是临时的；</li><li>304 Not Modified（未修改）：表示客户端发送的条件请求（如带有 <code>If-Modified-Since</code> 头部）的资源未发生修改，可以使用缓存的版本；</li><li>307 Temporary Redirect（临时重定向）：与 <code>302</code> 状态码类似，表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问；</li><li>308 Permanent Redirect（永久重定向）：与 <code>301</code> 状态码类似，表示请求的资源已永久移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。</li></ul><p>这些 3xx 状态码用于在客户端和服务器之间进行资源重定向，指示客户端采取进一步的操作来获取所需的资源。具体使用哪个 3xx 状态码取决于服务器的配置和需求。</p><h4 id="4xx（客户端错误状态码）"><a href="#4xx（客户端错误状态码）" class="headerlink" title="4xx（客户端错误状态码）"></a>4xx（客户端错误状态码）</h4><p><code>4xx</code> 状态码是 <code>HTTP</code> 协议中的客户端错误码，表示客户端发送的请求有错误。</p><p>以下是一些常见的 <code>4xx</code> 状态码:</p><ul><li>400 Bad Request（错误请求）： 表示服务器无法理解客户端发送的请求，通常是由于请求语法错误或缺少不要的参数；</li><li>401 Unauthorized（未授权）：表示客户端请求需要进行身份验证，但未提供有效的身份验证凭证；</li><li>403 Forbidden（禁止访问）： 表示客户端请求的资源被服务器拒绝访问，通常是由于权限限制或者访问被禁止；</li><li>404 Not Found（未找到）：表示客户端请求的资源在服务器上未找到；</li><li>405 Method Not Allowed（方法不允许）：表示客户端使用了服务器不支持的请求方法；</li><li>408 Request Timeout（请求超时）：表示客户端发送的请求在服务器等待时间内没有得到响应。</li></ul><p>这些 4xx 状态码指示客户端发送的请求存在错误或无法成功处理。客户端可以根据这些状态码来判断请求的错误类型，并采取相应的操作进行修正或处理。</p><h4 id="5xx（服务端错误状态码）"><a href="#5xx（服务端错误状态码）" class="headerlink" title="5xx（服务端错误状态码）"></a>5xx（服务端错误状态码）</h4><p><code>5xx</code> 状态码是 <code>HTTP</code> 协议中的服务端错误状态码，表示服务器在处理请求时发生了错误。</p><p>以下是一些常见的 <code>5xx</code> 状态码：</p><ul><li>500 Internal Server Error（服务器内部错误）：表示服务器在处理请求时发生了未知的内部错误；</li><li>501 Not Implemented（未实现）：表示服务器不支持客户端的功能或者请求的方法；</li><li>502 Bad Gateway（错误的网关）：表示服务器作为网关或代理时从上游服务器接收到无效的响应；</li><li>503 Service Unavailable（服务器不可用）：表示服务器当前无法处理请求，通常是由于服务器过载或者维护；</li><li>504 Gateway Timeout（网关超时）：表示服务器作为网关或代理时未及时从上游服务器接收到响应。</li></ul><p>这些 5xx 状态码指示服务器在处理请求时出现了错误或无法提供所需的服务。客户端可以根据这些状态码来判断服务器的状态，并采取相应的操作，如等待一段时间后重试请求或联系服务器管理员进行修复。</p>]]></content>
    
    
    <summary type="html">HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本数据的协议。它是一种客户端-服务器协议，客户端发送请求，服务器返回响应。HTTP是Web的基础，用于在Web浏览器和Web服务器之间传输数据</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="http" scheme="https://note.batype.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>TCP（Transmission Control Protocol，传输控制协议）</title>
    <link href="https://note.batype.com/browser/protocol/tcp.html"/>
    <id>https://note.batype.com/browser/protocol/tcp.html</id>
    <published>2024-03-28T02:15:31.678Z</published>
    <updated>2024-04-08T10:15:57.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP（Transmission-Control-Protocol，传输控制协议）"><a href="#TCP（Transmission-Control-Protocol，传输控制协议）" class="headerlink" title="TCP（Transmission Control Protocol，传输控制协议）"></a>TCP（Transmission Control Protocol，传输控制协议）</h2><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，广泛用于互联网中的数据传输。它是 TCP/IP 模型中的核心协议之一，与 IP（Internet Protocol，互联网协议）协同工作，负责在多个网络设备之间传输数据。</p><p>TCP 协议的主要特点和功能包括：</p><ol><li><p>面向连接:</p><p> 在数据传输开始之前，TCP 需要在两端建立一个连接，通常通过三次握手（three-way handshake）过程完成。</p></li><li><p>可靠性传输:</p><p> TCP 提供可靠的数据传输服务，确保数据无差错、不丢失、不重复，并且按序到达。它通过序列号、确认应答（ACKs）、超时重传等机制实现这一点。</p></li><li><p>流量控制:</p><p> TCP 使用滑动窗口协议来进行流量控制，防止快速发送方淹没慢速接收方。</p></li><li><p>拥塞控制:</p><p> TCP 实现拥塞控制算法，如慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery），以避免网络拥塞。</p></li><li><p>全双工通信:</p><p> TCP 提供全双工服务，意味着数据可以在两个方向上同时传输，双方都可以是发送者和接收者。</p></li><li><p>顺序控制和数据重组:</p><p> TCP 在数据包传输中使用序列号对数据包进行排序，确保接收端可以根据这些序列号将数据重新组合成原始的数据流。</p></li><li><p>错误检测:</p><p> TCP 头部包含校验和（checksum）字段，用于检测数据在传输过程中的任何错误。</p></li><li><p>连接管理:</p><p> TCP 协议管理和维护连接的生命周期，包括连接的建立、数据传输和连接的终止（通常通过四次挥手（four-way handshake）过程实现）。</p></li></ol><p>在 TCP/IP 协议栈中，TCP 位于传输层，正上方是应用层，应用层协议如 HTTP、FTP 等使用 TCP 来保证数据传输的可靠性；正下方是网络层，网络层协议如 IP 负责将数据包路由到正确的目的地。TCP 处理的是端到端的通信，确保数据能够在应用程序之间准确无误地传输。</p><p>由于 TCP 提供的可靠性和面向连接的特性，它广泛用于需要保证数据完整性和正确顺序的应用场景，如网页浏览、文件传输、电子邮件发送等。</p><p>下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p><p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了 “建立连接”“传输数据” 和 “断开连接” 三个阶段。</p><p><img data-src="https://pic.imgdb.cn/item/6613c26168eb9357131cee1d.png" alt="一个TCP连接的生命周期"></p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP 三次握手</h2><p>TCP 三次握手（Three-way Handshake）是建立 TCP/IP 网络连接的标准过程，其目的是在两个网络主机之间创建一个可靠的连接。这个过程确保了双方都准备好接收和发送数据，并且同步了双方的初始序列号，用于数据包的正确排序和可靠传输。下面是 TCP 三次握手的详细步骤：</p><h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><p><strong>客户端发送 SYN 包</strong>:</p><p>客户端选择一个初始序列号（ISN）并向服务器发送一个 SYN（同步）包。这个 SYN 包包含客户端的初始序列号，并且 SYN 标志位被设置为 1，其他标志位（如 ACK）被设置为 0。</p><h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN-ACK"></a>第二次握手：SYN-ACK</h3><p><strong>服务器回应 SYN-ACK 包</strong>:</p><p>服务器接收到 SYN 包后，发送一个 SYN-ACK（同步 - 确认）包作为回应。该包含有服务器自己的初始序列号，同时将客户端的初始序列号加 1，并在 ACK 字段中回传此值，以确认接收到客户端的 SYN。此时，SYN 和 ACK 标志位都被设置为 1。</p><h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><p><strong>客户端发送 ACK 包</strong>:</p><p>客户端收到 SYN-ACK 包后，将服务器的序列号加 1，并将这个值放在 ACK 包的确认字段中，发送给服务器。这个 ACK 包的 ACK 标志位设置为 1，表示确认。</p><h3 id="握手完成"><a href="#握手完成" class="headerlink" title="握手完成"></a>握手完成</h3><p><strong>连接建立</strong>:</p><p>服务器接收到客户端的 ACK 包后，三次握手完成，客户端和服务器之间建立了一个双向的可靠连接。之后，数据可以在双方之间开始传输。</p><p>这个过程的关键在于两次增量序列号的交换，这保证了双方都能确认对方已准备好进行通信，并且正确地维护了 TCP 的状态信息。三次握手可以防止历史连接的初始化数据段突然出现在当前连接中，从而导致不可预料的问题。</p><p>简化的表示如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端                     服务器</span><br><span class="line">  |-----SYN(X)------------&gt;|</span><br><span class="line">  |&lt;----SYN(Y), ACK(X+1)---|</span><br><span class="line">  |-----ACK(Y+1)----------&gt;|</span><br></pre></td></tr></tbody></table></figure><p>其中，X 和 Y 分别是客户端和服务器选择的初始序列号。</p><p>值得注意的是，TCP 三次握手仅仅是建立连接的一部分，数据传输会在三次握手之后开始，而在数据传输结束后，TCP 用另一个独立的四次挥手（Four-way Handshake）过程来关闭连接。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP 四次挥手</h2><p>TCP（传输控制协议）四次挥手是用于终止一个已经建立的 TCP 连接的过程。这个过程确保了双方都能够完成数据传输并且正确关闭连接。以下是 TCP 四次挥手的详细步骤：</p><h3 id="第一次挥手：FIN-WAIT-1"><a href="#第一次挥手：FIN-WAIT-1" class="headerlink" title="第一次挥手：FIN_WAIT_1"></a>第一次挥手：FIN_WAIT_1</h3><ul><li>假设客户端决定关闭连接，它发送一个 FIN（结束）标志的 TCP 段给服务器，表示客户端已经没有数据要发送了。</li><li>客户端进入 FIN_WAIT_1 状态，等待服务器的确认。</li></ul><h3 id="第二次挥手：CLOSE-WAIT"><a href="#第二次挥手：CLOSE-WAIT" class="headerlink" title="第二次挥手：CLOSE_WAIT"></a>第二次挥手：CLOSE_WAIT</h3><ul><li>服务器收到这个 FIN 段后，发送一个 ACK（确认）标志的 TCP 段作为回应，确认已经收到客户端的终止请求。</li><li>服务器进入 CLOSE_WAIT 状态，此时客户端收到 ACK 后进入 FIN_WAIT_2 状态。</li><li>此时，客户端到服务器的连接已经关闭，但是服务器如果还有数据要发送，可以继续发送。</li></ul><h3 id="第三次挥手：LAST-ACK"><a href="#第三次挥手：LAST-ACK" class="headerlink" title="第三次挥手：LAST_ACK"></a>第三次挥手：LAST_ACK</h3><ul><li>当服务器完成数据发送后，它也会决定关闭连接，发送一个 FIN 标志的 TCP 段给客户端。</li><li>服务器进入 LAST_ACK 状态，等待客户端的确认。</li></ul><h3 id="第四次挥手：TIME-WAIT"><a href="#第四次挥手：TIME-WAIT" class="headerlink" title="第四次挥手：TIME_WAIT"></a>第四次挥手：TIME_WAIT</h3><ul><li>客户端收到服务器的 FIN 段后，发送一个 ACK 标志的 TCP 段作为回应，确认已经收到服务器的终止请求。</li><li>客户端进入 TIME_WAIT 状态，持续 2 个最大段生命周期（MSL）的时间后，确保服务器能够接收到确认，然后关闭连接。</li><li>服务器收到 ACK 后，关闭连接，进入 CLOSED 状态。</li></ul><p>这个过程确保了双方都有机会完成数据传输并清理连接。如果在四次挥手过程中的任何一步发生网络延迟或丢包，TCP 协议会重试发送丢失的段，直到成功完成四次挥手过程。这个过程是 TCP 提供可靠传输服务的关键机制之一。</p><p>简化的表示如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 客户端                       服务器</span><br><span class="line">FIN_WAIT_1    |-----FIN----&gt;|</span><br><span class="line">FIN_WAIT_2    |&lt;----ACK-----| CLOSE_WAIT</span><br><span class="line">              |&lt;----FIN-----| LAST_ACK</span><br><span class="line">TIME_WAIT     |-----ACK----&gt;| CLOSED</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，广泛用于互联网中的数据传输。它是TCP/IP模型中的核心协议之一，与IP（Internet Protocol，互联网协议）协同工作，负责在多个网络设备之间传输数据。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="TCP" scheme="https://note.batype.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TLS（Transport Layer Security，传输层安全协议）三次握手</title>
    <link href="https://note.batype.com/browser/protocol/tls.html"/>
    <id>https://note.batype.com/browser/protocol/tls.html</id>
    <published>2024-03-27T02:19:17.176Z</published>
    <updated>2024-03-27T02:19:17.177Z</updated>
    
    <content type="html"><![CDATA[<p>TLS（Transport Layer Security，传输层安全协议）三次握手是建立安全层通信的一个过程，它确保了数据在两个通信实体之间的传输是加密和身份验证的。TLS 是一种安全协议，通常用于在网络中传输数据时提供保密性和数据完整性保护。TLS 也可以用作其他协议的底层安全层，例如 HTTPS（超文本传输安全协议）是 HTTP 协议的安全版本，它使用了 TLS/SSL 协议进行数据传输。</p><p>TLS 三次握手过程如下：</p><ol><li><p><strong>客户端 Hello（ClientHello）</strong>:</p><ul><li>客户端开始建立连接，发送一个 ClientHello 消息给服务器。这个消息包括客户端支持的 TLS 版本、一个客户端生成的随机数（ClientRandom），以及客户端支持的加密套件列表（cipher suites）。</li><li>客户端还可能会请求服务器的证书，以及其它与安全相关的信息。</li></ul></li><li><p><strong>服务器 Hello（ServerHello）</strong>:</p><ul><li>服务器收到 ClientHello 消息后，会从客户端提供的加密套件列表中选择一个加密算法，并在 ServerHello 消息中通知客户端。</li><li>服务器也会生成一个随机数（ServerRandom），并把自己的证书（包含公钥）发送给客户端。如果服务器需要对客户端进行身份验证，它也可以发送一个证书请求。</li></ul></li><li><p><strong>客户端验证（Client Verification）</strong>:</p><ul><li>客户端收到服务器的证书后，会验证其有效性（例如，检查证书是否过期，是否由受信任的证书颁发机构签发等）。</li><li>客户端会生成第三个随机数（ClientVerifyRandom），并使用服务器的公钥加密这个随机数，然后将加密后的数据发送给服务器（Pre-Master Secret）。</li><li>如果服务器请求了客户端证书，客户端也会发送自己的证书。</li></ul></li><li><p><strong>服务器完成（Server Finished）</strong>:</p><ul><li>服务器使用自己的私钥解密收到的 Pre-Master Secret。</li><li>服务器和客户端都将使用 ClientRandom、ServerRandom 和 ClientVerifyRandom 这三个随机数，通过一定的算法生成相同的会话密钥（Session Key）。</li><li>服务器发送 Finished 消息给客户端，这个消息是使用新生成的会话密钥加密的。</li></ul></li><li><p><strong>客户端完成（Client Finished）</strong>:</p><ul><li>客户端收到服务器的 Finished 消息后，使用会话密钥解密，并验证消息的正确性。</li><li>客户端也发送一个 Finished 消息给服务器，同样使用会话密钥加密。</li></ul></li></ol><p>完成以上步骤后，客户端和服务器就建立了一个安全的连接，可以开始安全地传输数据。需要注意的是，TLS 协议中的 “三次握手” 与 TCP 协议的三次握手是不同的概念。TLS 的三次握手是指在 TLS 密钥交换过程中的步骤，而 TCP 的三次握手是指在建立一个可靠的传输层连接的过程中的步骤。</p>]]></content>
    
    
    <summary type="html">TLS（Transport Layer Security，传输层安全协议）三次握手是建立安全层通信的一个过程，它确保了数据在两个通信实体之间的传输是加密和身份验证的。TLS是一种安全协议，通常用于在网络中传输数据时提供保密性和数据完整性保护。TLS也可以用作其他协议的底层安全层，例如HTTPS（超文本传输安全协议）是HTTP协议的安全版本，它使用了TLS/SSL协议进行数据传输。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="TLS" scheme="https://note.batype.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>服务器端渲染（Server-Side Rendering，简称 SSR）</title>
    <link href="https://note.batype.com/browser/render/ssr.html"/>
    <id>https://note.batype.com/browser/render/ssr.html</id>
    <published>2024-03-26T09:32:29.295Z</published>
    <updated>2024-03-26T09:35:20.565Z</updated>
    
    <content type="html"><![CDATA[<p>服务端渲染（Server-Side Rendering，简称 SSR）是一种 Web 应用的渲染方式，其中 HTML 是在服务器上生成的，并作为完整页面发送到客户端（通常是浏览器）。客户端然后解析和显示这个 HTML。这种方法与客户端渲染（Client-Side Rendering，简称 CSR）形成对比，在客户端渲染中，浏览器下载一个最小的 HTML 页面，随后使用 JavaScript 动态生成页面内容。</p><h2 id="服务端渲染的主要优势和特点包括"><a href="#服务端渲染的主要优势和特点包括" class="headerlink" title="服务端渲染的主要优势和特点包括"></a>服务端渲染的主要优势和特点包括</h2><ol><li><p>更快的首次加载:</p><p> 对于用户来说，SSR 可以更快地显示页面的首次可见内容，因为浏览器接收到的是已经渲染的页面。用户不需要等待所有的 JavaScript 加载、执行以及渲染完成。</p></li><li><p>搜索引擎优化（SEO）:</p><p> SSR 对 SEO 更加友好，因为搜索引擎爬虫可以直接抓取和索引服务器渲染的 HTML 内容。而在 CSR 中，爬虫可能需要等待 JavaScript 执行完成，有些搜索引擎的爬虫可能不会执行 JavaScript，这会影响内容的可索引性。</p></li><li><p>共享重复功能:</p><p> 使用 SSR，服务器可以为多个请求重用页面生成的结果，比如通过缓存，提高效率。</p></li><li><p>更好的性能:</p><p> 对于计算能力较低的设备，SSR 可以提供更好的性能体验，因为服务器通常比客户端设备拥有更强的处理能力。</p></li><li><p>简化前端复杂性:</p><p> SSR 应用可能不需要像完全的客户端应用那样复杂的 JavaScript 框架或库。</p></li><li><p>更好的用户体验:</p><p> 用户看到的是完整的页面，因此在页面变得可交互之前，他们可以先阅读内容，而不是看到一个空白屏幕或加载指示符。</p></li></ol><p>然而，服务端渲染也有一些潜在的缺点：</p><ol><li><p>服务器负载:</p><p> SSR 可能会增加服务器的负载，因为服务器必须为每个请求生成页面内容。</p></li><li><p>时间到首字节（TTFB）:</p><p> 虽然用户可以更快地看到内容，但是生成页面内容的服务器处理时间可能会导致更长的时间到首字节。</p></li><li><p>客户端 JavaScript 还是需要:</p><p> 即使页面在服务器上预先渲染，通常客户端 JavaScript 仍然需要以便为页面添加交互功能。</p></li><li><p>复杂的缓存策略:</p><p> 如果页面内容经常变化，实现有效的服务器缓存策略可能会变得复杂。</p></li><li><p>延迟的交互:</p><p> 用户可能能够看到页面内容，但要等到 JavaScript 下载和执行完成后，页面才变得可交互。</p></li></ol><p>SSR 在许多现代 Web 开发框架和库中都得到了支持，如 Next.js（基于 React）、Nuxt.js（基于 Vue.js）和 Angular Universal。这些工具都提供了简化服务端渲染工作流程的功能。</p>]]></content>
    
    
    <summary type="html">服务端渲染（Server-Side Rendering，简称 SSR）是一种 Web 应用的渲染方式，其中 HTML 是在服务器上生成的，并作为完整页面发送到客户端（通常是浏览器）。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="render" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/render/"/>
    
    <category term="SSR" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/render/SSR/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="SSR" scheme="https://note.batype.com/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 和 HTTP 的区别</title>
    <link href="https://note.batype.com/browser/protocol/http-https.html"/>
    <id>https://note.batype.com/browser/protocol/http-https.html</id>
    <published>2024-03-26T06:36:10.787Z</published>
    <updated>2024-03-26T09:32:12.702Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HTTP</strong>: 是一种无状态的请求 - 响应协议。是互联网上应用最广泛的一种通讯协议，基于 TCP ，可以使浏览器工作效率更为高效，减少网络传输。</p><p><strong>HTTPS</strong>: 是 HTTP 的加强版，可以认为是 HTTP + SSL (Secure Socket Layer)。 在 HTTP 的基础之上增加了一系列的安全机制。一方面可以保证数据传输的安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p><h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><ol><li><p>安全性</p><ul><li>HTTP 是明文传输协议，数据在传输过程中不加密，容易被篡改和窃听；</li><li>HTTPS 通过使用 SSL (Secure Sockets Layer) 和 TLS (Transport Layer Security) 协议对数据进行加密，确保数据在传输过程中的安全性，防止被窃听和篡改；</li></ul></li><li><p>数据传输协议</p><ul><li>HTTP 使用 TCP (Transmission Control Protocol) 作为传输协议，数据传输速度快；</li><li>HTTPS 在 HTTP 的基础之上加入了 SSL/TLS 协议，需要进行加解密操作，数据传输速度慢；</li></ul></li><li><p>端口号</p><ul><li>HTTP 默认端口号 80；</li><li>HTTPS 默认端口号 443；</li></ul></li><li><p>证书</p><ul><li>HTTPS 需要使用 SSL 证书，用于验证服务器的身份，并确保数据传输的安全；</li><li>HTTP 不需要使用证书。</li></ul></li></ol><h2 id="HTTP-执行机制"><a href="#HTTP-执行机制" class="headerlink" title="HTTP 执行机制"></a>HTTP 执行机制</h2><ol><li><p>客户端发起请求:</p><p> 客户端向服务器发送 HTTP 请求。这个请求可以是不同类型的，如 GET（请求数据），POST（提交数据），PUT（更新数据）等；</p></li><li><p>建立连接:</p><p> 客户端通过网络与服务器建立 TCP 连接，通常是到服务器的 80 端口。<br> 对于现代浏览器和服务器，通常使用更复杂的 TCP 握手过程，比如 TCP 快速打开（TFO）和 TLS 假开始（TLS False Start）。</p></li><li><p>发送请求:</p><p> 一旦 TCP 连接建立，客户端发送一个 HTTP 请求。HTTP 请求包括一个请求行（指明动作如 GET 或 POST）、请求头（包含元数据如 User-Agent、Accept、Content-Type 等）和请求体（对于 POST 请求，包含要提交的数据）。</p></li><li><p>服务器处理请求:</p><p> 服务器接收请求并根据请求类型处理它。服务器可能会查询数据库、读取文件或执行其他操作来生成响应。</p></li><li><p>服务器响应:</p><p> 服务器发送一个 HTTP 响应到客户端。响应包括一个状态行（包含状态码如 200 OK 或 404 Not Found）、响应头（包含元数据如 Content-Type、Cache-Control 等）和响应体（包含请求的资源的实际数据）。</p></li><li><p>关闭连接:</p><ul><li>在 HTTP/1.0 中，完成响应后，服务器关闭 TCP 连接；</li><li>在 HTTP/1.1 中，默认使用持久连接（keep-alive），连接在多个请求和响应之后保持打开状态，除非客户端或服务器决定关闭它；</li><li>在 HTTP/2 中，多个请求可以在同一个连接上并行无阻塞地进行，进一步提高效率。</li></ul></li><li><p>客户端处理响应:</p><p> 客户端接收响应并根据内容类型处理数据，如渲染 HTML 页面、解析 JSON 数据等。</p></li></ol><h2 id="HTTPS-执行机制"><a href="#HTTPS-执行机制" class="headerlink" title="HTTPS 执行机制"></a>HTTPS 执行机制</h2><ol><li><p>客户端请求:</p><p> 客户端通过在请求的 URL 中使用 “https://” 来发起一个 HTTPS 连接。</p></li><li><p>TLS 握手</p><p> 服务器在其端口 443 上监听 HTTPS 请求，并在收到请求时响应；<br> 服务器将其 TLS 证书发送给客户端。这个证书包含了服务器的公钥和证书颁发机构（CA）的签名；</p></li><li><p>证书验证:</p><p> 客户端验证服务器的证书是否有效，是否在有效期内，以及是否由受信任的 CA 签发。这个过程也包括检查证书的撤销状态。<br> 这一步，将执行以下步骤进行身份验证：</p><ul><li>验证证书链：客户端检查服务器证书是否由受信任的证书颁发机构（CA）签发，以及证书链是否有效；</li><li>检查有效期：客户端检查证书的有效期，确保证书当前有效期未过期；</li><li>检查撤销状态：客户端肯呢个会检查证书是否被撤销，这可以通过访问 CA 的在线证书状态协议 (OCSP) 服务器或者下载证书撤销列表 (CRL) 来完成；</li><li>验证数字签名：客户端使用 CA 的公钥来解密证书的数字签名，以确保它是由正确的 CA 签发且未被篡改；</li></ul></li><li><p>密钥交换</p><p> 一旦确认证书有效，客户端使用服务器的公钥来加密生成一个随机的会话密钥，并将其发送给服务器；<br> 服务器用其私钥解密这个会话密钥。现在，客户端和服务器端都有了共同的会话密钥，用于后续通信的加密；</p></li><li><p>加密通信</p><p> 使用会话密钥，客户端和服务器端之间的所有数据传输都将被加密。这保证了数据传输的机密性和完整性；<br> 客户端和服务器会使用对称加密算法来加密进一步的通信；</p></li><li><p>数据交换</p><p> 客户端和服务器现在可以完全的交换 HTTP 数据。客户端发送加密的 HTTP 请求，服务器以加密的 HTTP 响应回复；</p></li><li><p>会话结束</p><p> 一旦会话完成，客户端和服务器将结束连接并丢弃会话密钥，确保每一个连接都使用一个新的随机密钥。</p></li></ol>]]></content>
    
    
    <summary type="html">HTTPS 在 HTTP 的基础之上增加了一系列的安全机制。一方面可以保证数据传输的安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</summary>
    
    
    
    <category term="浏览器" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="protocol" scheme="https://note.batype.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/protocol/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="浏览器" scheme="https://note.batype.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="http" scheme="https://note.batype.com/tags/http/"/>
    
    <category term="https" scheme="https://note.batype.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>对象属性只读（递归）DeepReadonly</title>
    <link href="https://note.batype.com/typescript/questions/DeepReadonly.html"/>
    <id>https://note.batype.com/typescript/questions/DeepReadonly.html</id>
    <published>2024-03-13T02:35:53.195Z</published>
    <updated>2024-03-13T02:38:25.540Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个泛型 <code>DeepReadonly&lt;T&gt;</code>，它将对象的每个参数及其子对象递归地设为只读。</p><p>您可以假设在此挑战中我们仅处理对象。不考虑数组、函数、类等。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。</p><p>例如</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X = { </span><br><span class="line">    <span class="attr">x</span>: { </span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">        <span class="attr">b</span>: <span class="string">'hi'</span></span><br><span class="line">    }</span><br><span class="line">    <span class="attr">y</span>: <span class="string">'hey'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Expected</span> = { </span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">x</span>: { </span><br><span class="line">        <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">        <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="string">'hi'</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="string">'hey'</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Todo</span> = <span class="title class_">DeepReadonly</span>&lt;X&gt; <span class="comment">// should be same as `Expected`</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ol><li>属于基础类型则直接返回</li><li>数组、Map、Set 需要拆分其内容属性 </li></ol><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Primitive</span> = <span class="literal">undefined</span> | <span class="built_in">string</span> | <span class="literal">null</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="title class_">Function</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Primitive</span></span><br><span class="line">    ? T</span><br><span class="line">    : T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer U&gt;</span><br><span class="line">    ? <span class="title class_">ReadonlyArray</span>&lt;<span class="title class_">DeepReadonly</span>&lt;T&gt;&gt;</span><br><span class="line">    : T <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;infer K, infer V&gt;</span><br><span class="line">    ? <span class="title class_">ReadonlyMap</span>&lt;<span class="title class_">DeepReadonly</span>&lt;K&gt;, <span class="title class_">DeepReadonly</span>&lt;V&gt;&gt;</span><br><span class="line">    : T <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;infer U&gt;</span><br><span class="line">    ? <span class="title class_">ReadonlySet</span>&lt;<span class="title class_">DeepReadonly</span>&lt;U&gt;&gt;</span><br><span class="line">    : { <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[K]&gt; };</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">实现一个泛型 `DeepReadonly&lt;T&gt;`，它将对象的每个参数及其子对象递归地设为只读。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>对象部分属性只读 Readonly</title>
    <link href="https://note.batype.com/typescript/questions/Readonly2.html"/>
    <id>https://note.batype.com/typescript/questions/Readonly2.html</id>
    <published>2024-03-12T10:09:48.117Z</published>
    <updated>2024-03-12T10:12:06.729Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个泛型 <code>MyReadonly2&lt;T, K&gt;</code>，它带有两种类型的参数 <code>T</code> 和 <code>K</code>。</p><p>类型 <code>K</code> 指定 <code>T</code> 中要被设置为只读 (readonly) 的属性。如果未提供 <code>K</code>，则应使所有属性都变为只读，就像普通的 <code>Readonly&lt;T&gt;</code> 一样。</p><p>例如</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> {</span><br><span class="line"><span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line"><span class="attr">completed</span>: <span class="built_in">boolean</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">MyReadonly2</span>&lt;<span class="title class_">Todo</span>, <span class="string">'title'</span> | <span class="string">'description'</span>&gt; = {</span><br><span class="line"><span class="attr">title</span>: <span class="string">"Hey"</span>,</span><br><span class="line"><span class="attr">description</span>: <span class="string">"foobar"</span>,</span><br><span class="line"><span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">todo.<span class="property">title</span> = <span class="string">"Hello"</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br><span class="line">todo.<span class="property">description</span> = <span class="string">"barFoo"</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br><span class="line">todo.<span class="property">completed</span> = <span class="literal">true</span> <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>先取出需要 <code>readonly</code> 参数，然后在把不需要声明的参数用排除法加上。 </p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly2</span>&lt;T, D <span class="keyword">extends</span> keyof T&gt; = {</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> D]: T[P];</span><br><span class="line">} &amp; {</span><br><span class="line">    [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> D ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">实现一个泛型`MyReadonly2&lt;T, K&gt;`，它带有两种类型的参数`T`和`K`。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>对象属性只读 Readonly</title>
    <link href="https://note.batype.com/typescript/questions/Readonly.html"/>
    <id>https://note.batype.com/typescript/questions/Readonly.html</id>
    <published>2024-03-11T06:06:02.288Z</published>
    <updated>2024-03-11T06:09:33.577Z</updated>
    
    <content type="html"><![CDATA[<p>不要使用内置的 <code>Readonly&lt;T&gt;</code>，自己实现一个。</p><p>泛型 <code>Readonly&lt;T&gt;</code> 会接收一个 _泛型参数_，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。</p><p>也就是不可以再对该对象的属性赋值。</p><p>例如：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> {</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">MyReadonly</span>&lt;<span class="title class_">Todo</span>&gt; = {</span><br><span class="line">  <span class="attr">title</span>: <span class="string">"Hey"</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">"foobar"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">todo.<span class="property">title</span> = <span class="string">"Hello"</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br><span class="line">todo.<span class="property">description</span> = <span class="string">"barFoo"</span> <span class="comment">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = {</span><br><span class="line"><span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">不要使用内置的`Readonly&lt;T&gt;`，自己实现一个。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>实现类似 Vue 的类型支持的简化版本</title>
    <link href="https://note.batype.com/typescript/questions/SimpleVue.html"/>
    <id>https://note.batype.com/typescript/questions/SimpleVue.html</id>
    <published>2024-03-11T03:29:01.008Z</published>
    <updated>2024-03-11T03:31:12.644Z</updated>
    
    <content type="html"><![CDATA[<p>实现类似 Vue 的类型支持的简化版本。</p><p>通过提供一个函数 <code>SimpleVue</code>（类似于 <code>Vue.extend</code> 或 <code>defineComponent</code>），它应该正确地推断出 computed 和 methods 内部的 <code>this</code> 类型。</p><p>在此挑战中，我们假设 <code>SimpleVue</code> 接受只带有 <code>data</code>，<code>computed</code> 和 <code>methods</code> 字段的 Object 作为其唯一的参数，</p><ul><li><p><code>data</code> 是一个简单的函数，它返回一个提供上下文 <code>this</code> 的对象，但是你无法在 <code>data</code> 中获取其他的计算属性或方法。</p></li><li><p><code>computed</code> 是将 <code>this</code> 作为上下文的函数的对象，进行一些计算并返回结果。在上下文中应暴露计算出的值而不是函数。</p></li><li><p><code>methods</code> 是函数的对象，其上下文也为 <code>this</code>。函数中可以访问 <code>data</code>，<code>computed</code> 以及其他 <code>methods</code> 中的暴露的字段。 <code>computed</code> 与 <code>methods</code> 的不同之处在于 <code>methods</code> 在上下文中按原样暴露为函数。</p></li></ul><p><code>SimpleVue</code> 的返回值类型可以是任意的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="title class_">SimpleVue</span>({</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      <span class="attr">firstname</span>: <span class="string">'Type'</span>,</span><br><span class="line">      <span class="attr">lastname</span>: <span class="string">'Challenges'</span>,</span><br><span class="line">      <span class="attr">amount</span>: <span class="number">10</span>,</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">computed</span>: {</span><br><span class="line">    <span class="title function_">fullname</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstname</span> + <span class="string">' '</span> + <span class="variable language_">this</span>.<span class="property">lastname</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">methods</span>: {</span><br><span class="line">    <span class="title function_">hi</span>(<span class="params"></span>) {</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">fullname</span>.<span class="title function_">toLowerCase</span>())</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DataType</span>&lt;T&gt; = T <span class="keyword">extends</span> { <span class="title function_">data</span>(): infer D } ? D : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ComputedType</span>&lt;T, D&gt; = T <span class="keyword">extends</span> { <span class="attr">computed</span>: infer C }</span><br><span class="line">? {</span><br><span class="line">    [K <span class="keyword">in</span> keyof C]: C[K] <span class="keyword">extends</span> (<span class="attr">this</span>: D) =&gt; infer R ? R : <span class="built_in">never</span>;</span><br><span class="line">    }</span><br><span class="line">: {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MethodsType</span>&lt;T, D, C&gt; = T <span class="keyword">extends</span> { <span class="attr">methods</span>: infer M }</span><br><span class="line">? {</span><br><span class="line">    [K <span class="keyword">in</span> keyof M]: M[K] <span class="keyword">extends</span> (<span class="attr">this</span>: D &amp; C) =&gt; infer R ? R : <span class="built_in">never</span>;</span><br><span class="line">    }</span><br><span class="line">: {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title class_">SimpleVue</span>&lt;T&gt;(<span class="attr">options</span>: T): {</span><br><span class="line"><span class="attr">data</span>: <span class="title class_">DataType</span>&lt;T&gt;;</span><br><span class="line"><span class="attr">computed</span>: <span class="title class_">ComputedType</span>&lt;T, <span class="title class_">DataType</span>&lt;T&gt;&gt;;</span><br><span class="line"><span class="attr">methods</span>: <span class="title class_">MethodsType</span>&lt;T, <span class="title class_">DataType</span>&lt;T&gt;, <span class="title class_">ComputedType</span>&lt;T, <span class="title class_">DataType</span>&lt;T&gt;&gt;&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">通过提供一个函数`SimpleVue`（类似于`Vue.extend`或`defineComponent`），它应该正确地推断出 computed 和 methods 内部的`this`类型。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>获取只读属性 GetReadonlyKeys</title>
    <link href="https://note.batype.com/typescript/questions/GetReadonlyKeys.html"/>
    <id>https://note.batype.com/typescript/questions/GetReadonlyKeys.html</id>
    <published>2024-03-11T02:10:43.733Z</published>
    <updated>2024-03-11T02:15:53.532Z</updated>
    
    <content type="html"><![CDATA[<p>实现泛型 <code>GetReadonlyKeys&lt;T&gt;</code>，<code>GetReadonlyKeys&lt;T&gt;</code> 返回由对象 T 所有只读属性的键组成的联合类型。</p><p>例如</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> {</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="title class_">GetReadonlyKeys</span>&lt;<span class="title class_">Todo</span>&gt; <span class="comment">// expected to be "title" | "description"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol><li>映射类型：</li></ol><ul><li>使用了映射类型语法 <code>[P in keyof T]</code>，遍历 <code>T</code> 类型的所有键（包括公共和私有属性以及方法）。</li></ul><ol start="2"><li>条件类型与函数类型比较：</li></ol><ul><li>对于每个键 <code>P</code>，创建一个返回值为布尔类型的匿名函数类型 <code>&lt;I&gt;() =&gt; ...</code>。</li><li>第一个函数类型检查是否有一个对象类型，其具有属性 <code>I</code> 等于 <code>T[P]</code> 的类型，这实际上是为了确保当前键 <code>P</code> 的存在性。</li><li>第二个函数类型则检查是否有只读版本的对象类型，其中属性 I 是只读的且类型为 <code>T[P]</code>。</li></ul><ol start="3"><li>条件判断：</li></ol><ul><li>判断第一个函数类型是否能赋值给第二个函数类型，即判断 <code>T[P]</code> 是否是一个只读属性。</li><li>如果是，则结果为 <code>P</code>，表示该键 <code>P</code> 是只读属性。</li><li>否则，结果为 <code>never</code>，表示该键不是只读属性。</li></ul><ol start="4"><li>取可读属性键集合：</li></ol><ul><li>最终通过 <code>keyof</code> 运算符从映射类型中提取所有满足上述条件（即为只读属性）的键 <code>P</code> 构成的联合类型。</li></ul><ol start="5"><li>默认值 <code>never</code>：</li></ol><ul><li>如果没有符合条件的只读属性，则整个映射类型的结果是空对象类型，因此 <code>keyof {}</code> 将得到 <code>never</code> 类型。</li></ul><p>综上所述，<code>GetReadonlyKeys&lt;T&gt;</code> 类型会返回 T 中所有声明为只读属性的键名组成的联合类型。如果 <code>T</code> 没有只读属性，则返回类型为 <code>never</code>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetReadonlyKeys</span>&lt;T&gt; = keyof {</span><br><span class="line">    [</span><br><span class="line">        P <span class="keyword">in</span> keyof T <span class="keyword">as</span> (</span><br><span class="line">            &lt;I&gt;<span class="function">() =&gt;</span> I <span class="keyword">extends</span> ({ [I <span class="keyword">in</span> P]: T[I] }) ? <span class="literal">true</span> : <span class="built_in">never</span></span><br><span class="line">        ) <span class="keyword">extends</span> (</span><br><span class="line">            &lt;I&gt;<span class="function">() =&gt;</span> I <span class="keyword">extends</span> ({ <span class="keyword">readonly</span> [I <span class="keyword">in</span> P]: T[I] }) ? <span class="literal">true</span> : <span class="built_in">never</span></span><br><span class="line">        ) ? P : <span class="built_in">never</span></span><br><span class="line">    ] : <span class="built_in">never</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">实现泛型`GetReadonlyKeys&lt;T&gt;`，`GetReadonlyKeys&lt;T&gt;`返回由对象 `T` 所有只读属性的键组成的联合类型。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>实现 ReturnType</title>
    <link href="https://note.batype.com/typescript/questions/returntype.html"/>
    <id>https://note.batype.com/typescript/questions/returntype.html</id>
    <published>2024-03-08T09:58:10.562Z</published>
    <updated>2024-03-08T09:59:41.851Z</updated>
    
    <content type="html"><![CDATA[<p>不使用 <code>ReturnType</code> 实现 TypeScript 的 <code>ReturnType&lt;T&gt;</code> 泛型。</p><p>例如：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">v: <span class="built_in">boolean</span></span>) =&gt; {</span><br><span class="line">    <span class="keyword">if</span> (v)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a = <span class="title class_">MyReturnType</span>&lt;<span class="keyword">typeof</span> fn&gt; <span class="comment">// 应推导出 "1 | 2"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyReturnType</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Function</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R</span><br><span class="line">? R</span><br><span class="line">: <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">v: <span class="built_in">boolean</span></span>) =&gt; (v ? <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">v: <span class="built_in">boolean</span>, w: <span class="built_in">any</span></span>) =&gt; (v ? <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fnType = <span class="title class_">MyReturnType</span>&lt;<span class="keyword">typeof</span> fn&gt;;</span><br><span class="line"><span class="keyword">type</span> fnType1 = <span class="title class_">MyReturnType</span>&lt;<span class="keyword">typeof</span> fn1&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ComplexObject</span> = {</span><br><span class="line">    <span class="attr">a</span>: [<span class="number">12</span>, <span class="string">"foo"</span>];</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">"hello"</span>;</span><br><span class="line">    <span class="title function_">prev</span>(): <span class="built_in">number</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fnType2 = <span class="title class_">MyReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="title class_">ComplexObject</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">不使用 `ReturnType` 实现 TypeScript 的 `ReturnType&lt;T&gt;` 泛型。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>实现 Omit</title>
    <link href="https://note.batype.com/typescript/questions/omit.html"/>
    <id>https://note.batype.com/typescript/questions/omit.html</id>
    <published>2024-03-08T09:55:00.513Z</published>
    <updated>2024-03-11T02:12:07.017Z</updated>
    
    <content type="html"><![CDATA[<p>不使用 <code>Omit</code> 实现 <code>TypeScript</code> 的 <code>Omit&lt;T, K&gt;</code> 泛型。</p><p><code>Omit</code> 会创建一个省略 <code>K</code> 中字段的 <code>T</code> 对象。</p><p>例如：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> {</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">MyOmit</span>&lt;<span class="title class_">Todo</span>, <span class="string">'description'</span> | <span class="string">'title'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = {</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> {</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyOmit</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = {</span><br><span class="line">    [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> K ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-expect-error</span></span><br><span class="line"><span class="keyword">type</span> error = <span class="title class_">MyOmit</span>&lt;<span class="title class_">Todo</span>, <span class="string">"description"</span> | <span class="string">"invalid"</span>&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">不使用 `Omit` 实现 `TypeScript` 的 `Omit&lt;T, K&gt;` 泛型。</summary>
    
    
    
    <category term="前端" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/categories/%E5%89%8D%E7%AB%AF/TypeScript/type/"/>
    
    
    <category term="前端" scheme="https://note.batype.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TypeScript" scheme="https://note.batype.com/tags/TypeScript/"/>
    
    <category term="type" scheme="https://note.batype.com/tags/type/"/>
    
  </entry>
  
</feed>
