[{"title":"Hexo Admin 如何配合部署到线上","url":"/2024/04/03/Hexo-Admin-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A/","content":"<p>Hexo Admin 是一个为 Hexo 博客框架提供的一个管理界面，允许用户通过一个比较直观的 Web 界面来写文章和管理博客。若要将使用 Hexo Admin 编辑的博客部署到线上，需要遵循一些标准的步骤。以下是一个基本的流程：</p>\n<h3 id=\"安装-Hexo-Admin\"><a href=\"#安装-Hexo-Admin\" class=\"headerlink\" title=\"安装 Hexo Admin\"></a>安装 Hexo Admin</h3><p>安装 Hexo Admin 插件前，请确保你的 Hexo 博客已经在本地运行。</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-admin</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后，重新启动你的 Hexo 服务器：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在浏览器中打开 <code>http://localhost:4000/admin</code>，你应该能看到 Hexo Admin 的管理界面。</p>\n<h3 id=\"配置-Hexo-Admin\"><a href=\"#配置-Hexo-Admin\" class=\"headerlink\" title=\"配置 Hexo Admin\"></a>配置 Hexo Admin</h3><p>Hexo Admin 默认情况下没有密码保护，如果你希望你的编辑界面更加安全，可以在你的 <code>_config.yml</code> 配置文件中对 Hexo Admin 进行配置：</p>\n<figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">admin:</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> <span class=\"string\">myUsername</span></span><br><span class=\"line\">  <span class=\"attr\">password_hash:</span> <span class=\"string\">myPasswordHash</span></span><br><span class=\"line\">  <span class=\"attr\">secret:</span> <span class=\"string\">mySecret</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>password_hash</code> 是你密码的 bcrypt 哈希，可以使用在线 bcrypt 工具生成。<code>secret</code> 用于签署 cookie，可以是任何随机字符串。</p>\n<h3 id=\"部署博客到线上\"><a href=\"#部署博客到线上\" class=\"headerlink\" title=\"部署博客到线上\"></a>部署博客到线上</h3><p>Hexo 默认支持多种部署选项，如 Git、Heroku、Netlify、AWS S3 等，你可以使用以下命令来部署你的博客：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></tbody></table></figure>\n\n<p>为了使用 <code>hexo deploy</code>，需要在你的博客根目录下的 <code>_config.yml</code> 文件中正确配置你的部署方法。例如，如果使用 Git 部署，你的配置可能如下所示：</p>\n<figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">&lt;repository</span> <span class=\"string\">url&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> [<span class=\"string\">branch</span>]</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这需要你已经设置了对应的 Git 仓库，并且你的本地环境能够推送到这个仓库。</p>\n<h3 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h3><p>很多人选择将博客托管在像 GitHub Pages 或 Netlify 这样的平台上，并设置持续集成来自动化部署过程。每当你向 Git 仓库推送新的内容，CI 工具会自动运行 <code>hexo generate</code> 生成网站静态文件，并将它们部署到服务器上。这样，你只需关注内容编辑，不用手动进行部署。</p>\n<p>如果你在本机上使用 Hexo Admin 编辑内容，你可以在编辑完成后使用 Git 命令提交并推送更改到远端仓库：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add new post\"</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></tbody></table></figure>\n\n<p>之后，你配置的 CI 工具（如 Travis CI、GitHub Actions 等）会自动捕捉到新的提交，并开始部署流程。</p>\n<p>请注意，留意 Hexo Admin 插件是否开放于公共网络。若你的 Hexo server 在生产模式对外开放，记得配置安全措施，如密码保护以防止未经授权的访问。</p>\n","categories":["hexo"],"tags":["前端","hexo"]},{"title":"HTTP 详解","url":"//browser/protocol/http.html","content":"<h3 id=\"HTTP（Hypertext-Transfer-Protocol）基本信息\"><a href=\"#HTTP（Hypertext-Transfer-Protocol）基本信息\" class=\"headerlink\" title=\"HTTP（Hypertext Transfer Protocol）基本信息\"></a>HTTP（Hypertext Transfer Protocol）基本信息</h3><p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本数据的协议。它是一种客户端 - 服务器协议，客户端发送请求，服务器返回响应。HTTP 是 Web 的基础，用于在 Web 浏览器和 Web 服务器之间传输数据。</p>\n<p>以下是 HTTP 的一些关键概念和详解：</p>\n<ol>\n<li><p>请求和响应</p>\n<p> HTTP 通信是基于请求 - 响应模型。客户端发送 HTTP 请求到服务器，服务器处理请求并返回 HTTP 响应。</p>\n</li>\n<li><p>URL（Uniform Resource Locator）</p>\n<p> URL 是用于标识资源的地址。它由协议类型（如 http:// 或 https://）、域名或 IP 地址、端口号（可选）、路径和查询参数组成。<br> URL（Uniform Resource Locator）是用于标识资源的地址。</p>\n<p> 下面是一个 URL 的图解示例：</p>\n <figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────────────────────────────────────────────┐</span><br><span class=\"line\">│                        URL                          │</span><br><span class=\"line\">├───────────┬─────────────┬─────────┬───────┬───────┤</span><br><span class=\"line\">│  协议类型   │    域名/IP   │ 端口号  │  路径  │ 查询参数 │</span><br><span class=\"line\">├───────────┴─────────────┴─────────┴───────┴───────┤</span><br><span class=\"line\">│                     示例：                           │</span><br><span class=\"line\">│   https://www.example.com:8080/path/to/resource?q=1 │</span><br><span class=\"line\">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>协议类型（Protocol）：指定使用的协议，如 HTTP、HTTPS、FTP 等。</li>\n<li>域名或 IP 地址（Domain/IP）：标识资源所在的主机名或 IP 地址。</li>\n<li>端口号（Port）：可选项，用于指定与服务器通信的端口号，默认使用协议的默认端口号（如 HTTP 的默认端口号是 80）。</li>\n<li>路径（Path）：指定资源在服务器上的路径，用斜杠（/）分隔不同的目录或文件。</li>\n<li>查询参数（Query Parameters）：可选项，用于向服务器传递额外的参数，以键值对的形式出现，多个参数使用 &amp; 符号分隔。</li>\n</ul>\n<p> 在示例中，URL 是以 HTTPS 协议访问的，域名为<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbSzkvb/nlKjkuoY4MDgw56uv5Y+j5Y+3Lui3r+W+hOS4ui9wYXRoL3RvL3Jlc291cmNlJUVGJUJDJThDJUU2JTlGJUE1JUU4JUFGJUEyJUU1JThGJTgyJUU2JTk1JUIwJUU0JUI4JUJBcT0xJUUzJTgwJTgy\"> www.example.com，使用了 8080 端口号。路径为 /path/to/resource，查询参数为 q=1。<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p> URL 的结构可以根据不同的协议和应用场景有所变化，但基本的组成部分是协议类型、域名或 IP 地址、端口号、路径和查询参数。通过 URL，我们可以定位和访问互联网上的各种资源。</p>\n</li>\n<li><p>HTTP 方法</p>\n<p> HTTP 定义了一组方法，用于指定对资源的操作类型。常见的 HTTP 方法有 GET（获取资源）、POST（提交数据创建资源）、PUT（更新资源）、DELETE（删除资源）、PATCH（更新资源）、OPTIONS（获取资源支持的 HTTP 方法）、HEAD（获取资源头信息）。</p>\n<ul>\n<li><p><strong>GET</strong>：用于获取资源。客户端发送 GET 请求到服务器，服务器返回请求的资源。GET 请求通常不应该对服务器端产生副作用，即不应该修改服务器上的数据。</p>\n</li>\n<li><p><strong>POST</strong>：用于提交数据创建资源。客户端发送 POST 请求到服务器，请求创建一个新的资源。POST 请求通常用于提交表单数据、上传文件等操作。</p>\n</li>\n<li><p><strong>PUT</strong>：用于更新资源。客户端发送 PUT 请求到服务器，请求更新指定的资源。PUT 请求应该是幂等的，即多次执行相同的 PUT 请求结果应该是一致的。</p>\n</li>\n<li><p><strong>DELETE</strong>：用于删除资源。客户端发送 DELETE 请求到服务器，请求删除指定的资源。</p>\n</li>\n<li><p><strong>PATCH</strong>：用于局部更新资源。客户端发送 PATCH 请求到服务器，请求对指定的资源进行部分更新。</p>\n</li>\n<li><p><strong>HEAD</strong>：类似于 GET 请求，但只返回响应头信息，不返回响应体。HEAD 请求常用于获取资源的元数据，如文件大小、修改时间等，而不需要获取完整的资源内容。</p>\n</li>\n<li><p><strong>OPTIONS</strong>：用于获取服务器支持的 HTTP 方法和其他选项。客户端发送 OPTIONS 请求到服务器，服务器返回支持的方法和其他信息，用于客户端了解服务器的功能和配置</p>\n</li>\n</ul>\n</li>\n<li><p>请求头</p>\n<p> HTTP 请求包含一组请求头，用于传递关于请求的元数据，如 User-Agent（客户端标识）、Content-Type（请求体的数据类型）、Authorization（身份验证信息）等。</p>\n</li>\n<li><p>响应头</p>\n<p> HTTP 响应也包含一组响应头，用于传递关于响应的元数据，如 Content-Type（响应体的数据类型）、Content-Length（响应体长度）、Cache-Control（缓存策略）等。</p>\n</li>\n<li><p>状态码</p>\n<p> HTTP 响应包含一个状态码，用于表示请求的处理结果。常见的状态码有 200（成功）、404（资源未找到）、500（服务器内部错误）等。</p>\n<p> 以下是 HTTP 状态码的分类：</p>\n<ul>\n<li>1xx（信息性状态码）：表示接收的请求正在处理。</li>\n<li>2xx（成功状态码）：表示请求成功被服务器接收、理解、并接受。</li>\n<li>3xx（重定向状态码）：需要后续操作才能完成这一请求。</li>\n<li>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成。</li>\n<li>5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。</li>\n</ul>\n</li>\n<li><p>请求体和响应体</p>\n<p> 某些 HTTP 请求和响应可能包含一个可选的消息体，用于传递数据。请求体通常用于 POST 或 PUT 请求发送数据，而响应体用于返回请求的结果数据。</p>\n</li>\n<li><p>Cookie</p>\n<p> Cookie 是一种在客户端和服务器之间传递的小型数据，用于跟踪和识别用户。服务器可以通过设置响应头中的 Set-Cookie 字段来发送 Cookie 给客户端，客户端在后续的请求中会自动将 Cookie 包含在请求头中发送给服务器。</p>\n</li>\n<li><p>缓存</p>\n<p> HTTP 支持缓存机制，可以减少对服务器的请求次数，提高性能。服务器可以通过设置响应头中的 Cache-Control 字段来控制缓存策略，客户端可以通过设置请求头中的 If-Modified-Since 或 If-None-Match 字段来验证缓存的有效性。</p>\n</li>\n</ol>\n<p>HTTP 是一个无状态协议，每个请求和响应之间是相互独立的。为了跟踪用户状态，HTTP 引入了 Cookie 等机制。此外，HTTP 还支持 HTTPS（HTTP Secure）协议，通过加密和身份验证来提供更安全的通信。</p>\n<h3 id=\"HTTP-报文\"><a href=\"#HTTP-报文\" class=\"headerlink\" title=\"HTTP 报文\"></a>HTTP 报文</h3><p>HTTP 协议的请求报文和响应报文的基本结构相同，由三大部分组成：</p>\n<ul>\n<li>起始行（start line）： 描述请求或相应的基本信息；</li>\n<li>头部字段集合（header）：使用  <code>key-value</code> 形式更详细地说明报文</li>\n<li>消息体（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>\n</ul>\n<p>HTTP 报文由请求报文和响应报文两种格式组成，它们的基本结构如下：</p>\n<ol>\n<li>请求报文格式：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;方法&gt; &lt;URL&gt; &lt;协议版本&gt;  : 请求行</span><br><span class=\"line\">&lt;请求头部字段1&gt;: &lt;值1&gt;</span><br><span class=\"line\">&lt;请求头部字段2&gt;: &lt;值2&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;空行&gt;</span><br><span class=\"line\">&lt;请求体&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p><strong>请求行</strong></p>\n<ul>\n<li>方法：指定请求的方法，如 GET、POST 等。</li>\n<li>URL：请求的目标资源的 URL。</li>\n<li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li>\n</ul>\n</li>\n<li><p><strong>请求头部字段</strong></p>\n<ul>\n<li>包含了请求的各种附加信息，如 User-Agent、Content-Type 等。</li>\n</ul>\n</li>\n<li><p><strong>空行</strong></p>\n<ul>\n<li>用于分隔请求头部和请求体。</li>\n</ul>\n</li>\n<li><p><strong>请求体</strong></p>\n<ul>\n<li>可选项，包含了请求的主体内容，如 POST 请求中的表单数据、PUT 请求中的更新内容等。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>响应报文格式：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;协议版本&gt; &lt;状态码&gt; &lt;状态码描述&gt;: 响应行</span><br><span class=\"line\">&lt;响应头部字段1&gt;: &lt;值1&gt;</span><br><span class=\"line\">&lt;响应头部字段2&gt;: &lt;值2&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;空行&gt;</span><br><span class=\"line\">&lt;响应体&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p><strong>响应行</strong></p>\n<ul>\n<li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li>\n<li>状态码：表示服务器对请求的处理结果，如 200 表示成功，404 表示资源未找到等。</li>\n<li>状态码描述：对状态码的简短描述。</li>\n</ul>\n</li>\n<li><p><strong>响应头部字段</strong></p>\n<ul>\n<li>包含了响应的各种附加信息，如 Content-Type、Content-Length 等。</li>\n</ul>\n</li>\n<li><p><strong>空行</strong></p>\n<ul>\n<li>用于分隔响应头部和响应体。</li>\n</ul>\n</li>\n<li><p><strong>响应体</strong></p>\n<ul>\n<li>包含了响应的主体内容，如 HTML 页面、JSON 数据等。</li>\n</ul>\n</li>\n</ul>\n<p>HTTP 报文的格式是文本格式，使用 ASCII 编码。请求报文由客户端发送到服务器，响应报文由服务器返回给客户端。报文中的请求头部和响应头部字段提供了关于请求和响应的元数据信息，而请求体和响应体则包含了具体的数据内容。通过这种报文格式，客户端和服务器可以进行有效的通信和数据交换。</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><h4 id=\"1xx（信息性状态码）\"><a href=\"#1xx（信息性状态码）\" class=\"headerlink\" title=\"1xx（信息性状态码）\"></a>1xx（信息性状态码）</h4><p><code>1xx</code> 状态码是 <code>HTTP</code> 协议中的信息性状态码，表示请求已被接受，但还未完成。通常情况下，服务器会在响应中发送一些额外的信息，以帮助客户端了解请求的状态。</p>\n<p>常见的 1xx 状态码包括：</p>\n<ul>\n<li>100 Continue（继续）：表示服务器已经收到请求的头部，并且客户端应该继续发送请求的主题部分。</li>\n<li>101 Switching Protocols（切换协议）：表示服务器已经理解客户端的请求，并将切换到不同的协议，如从 <code>HTTP</code> 切换到 <code>WebSocket</code>。 </li>\n<li>102 Processing（处理中）：表示服务器正在处理请求，但尚未完成。</li>\n<li>103 Early Hints（早期提示）：表示服务器已经开始处理请求，但仍在生成响应的过程中，可以在响应头部发送一些提示信息。</li>\n</ul>\n<p>这些 1xx 状态码主要用于在请求 - 响应过程中提供一些中间状态信息，以便客户端和服务器能够更好地进行通信和处理。</p>\n<h4 id=\"2xx（成功状态码）\"><a href=\"#2xx（成功状态码）\" class=\"headerlink\" title=\"2xx（成功状态码）\"></a>2xx（成功状态码）</h4><p>2xx 状态码是 HTTP 协议中的成功状态码，表示服务器成功处理了客户端的请求。</p>\n<p>以下是一些常见的 2xx 状态码：</p>\n<ul>\n<li><p>200 OK（成功）：表示请求已成功处理，并返回了请求的内容。</p>\n</li>\n<li><p>201 Created（已创建）：表示请求已成功处理，并在服务器上创建了新的资源。</p>\n</li>\n<li><p>202 Accepted（已接受）：表示服务器已经接受了请求，但尚未完成处理。通常用于异步操作，告知客户端请求已接受，但处理尚未完成。</p>\n</li>\n<li><p>204 No Content（无内容）：表示服务器成功处理了请求，但没有返回任何内容。通常用于不需要返回具体内容的请求，如 DELETE 请求。</p>\n</li>\n</ul>\n<p>这些 2xx 状态码表示客户端的请求已经成功处理，并且服务器能够提供相应的响应。不同的 2xx 状态码可以提供不同的信息，客户端可以根据这些状态码来判断请求的结果和下一步的操作。</p>\n<h4 id=\"3xx（重定向状态码）\"><a href=\"#3xx（重定向状态码）\" class=\"headerlink\" title=\"3xx（重定向状态码）\"></a>3xx（重定向状态码）</h4><p>3xx 状态码是 HTTP 协议中的重定向状态码，用于指示客户端需要采取进一步的操作来完成请求。</p>\n<p>以下是一些常见的 3xx 状态码：</p>\n<ul>\n<li>300 Multiple Choices（多种选择）：表示请求有多个可供选择的响应，客户端可以选择其中一个进行访问；</li>\n<li>301 Moved Permanently（永久重定向）：表示请求的资源以永久移动到新的 <code>URL</code>，客户端应该使用新的 <code>URL</code> 进行访问；</li>\n<li>302 Found（临时重定向）：表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。与 <code>301</code> 状态码类似，但是 <code>302</code> 状态码表示重定向是临时的；</li>\n<li>304 Not Modified（未修改）：表示客户端发送的条件请求（如带有 <code>If-Modified-Since</code> 头部）的资源未发生修改，可以使用缓存的版本；</li>\n<li>307 Temporary Redirect（临时重定向）：与 <code>302</code> 状态码类似，表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问；</li>\n<li>308 Permanent Redirect（永久重定向）：与 <code>301</code> 状态码类似，表示请求的资源已永久移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。</li>\n</ul>\n<p>这些 3xx 状态码用于在客户端和服务器之间进行资源重定向，指示客户端采取进一步的操作来获取所需的资源。具体使用哪个 3xx 状态码取决于服务器的配置和需求。</p>\n<h4 id=\"4xx（客户端错误状态码）\"><a href=\"#4xx（客户端错误状态码）\" class=\"headerlink\" title=\"4xx（客户端错误状态码）\"></a>4xx（客户端错误状态码）</h4><p><code>4xx</code> 状态码是 <code>HTTP</code> 协议中的客户端错误码，表示客户端发送的请求有错误。</p>\n<p>以下是一些常见的 <code>4xx</code> 状态码:</p>\n<ul>\n<li>400 Bad Request（错误请求）： 表示服务器无法理解客户端发送的请求，通常是由于请求语法错误或缺少不要的参数；</li>\n<li>401 Unauthorized（未授权）：表示客户端请求需要进行身份验证，但未提供有效的身份验证凭证；</li>\n<li>403 Forbidden（禁止访问）： 表示客户端请求的资源被服务器拒绝访问，通常是由于权限限制或者访问被禁止；</li>\n<li>404 Not Found（未找到）：表示客户端请求的资源在服务器上未找到；</li>\n<li>405 Method Not Allowed（方法不允许）：表示客户端使用了服务器不支持的请求方法；</li>\n<li>408 Request Timeout（请求超时）：表示客户端发送的请求在服务器等待时间内没有得到响应。</li>\n</ul>\n<p>这些 4xx 状态码指示客户端发送的请求存在错误或无法成功处理。客户端可以根据这些状态码来判断请求的错误类型，并采取相应的操作进行修正或处理。</p>\n<h4 id=\"5xx（服务端错误状态码）\"><a href=\"#5xx（服务端错误状态码）\" class=\"headerlink\" title=\"5xx（服务端错误状态码）\"></a>5xx（服务端错误状态码）</h4><p><code>5xx</code> 状态码是 <code>HTTP</code> 协议中的服务端错误状态码，表示服务器在处理请求时发生了错误。</p>\n<p>以下是一些常见的 <code>5xx</code> 状态码：</p>\n<ul>\n<li>500 Internal Server Error（服务器内部错误）：表示服务器在处理请求时发生了未知的内部错误；</li>\n<li>501 Not Implemented（未实现）：表示服务器不支持客户端的功能或者请求的方法；</li>\n<li>502 Bad Gateway（错误的网关）：表示服务器作为网关或代理时从上游服务器接收到无效的响应；</li>\n<li>503 Service Unavailable（服务器不可用）：表示服务器当前无法处理请求，通常是由于服务器过载或者维护；</li>\n<li>504 Gateway Timeout（网关超时）：表示服务器作为网关或代理时未及时从上游服务器接收到响应。</li>\n</ul>\n<p>这些 5xx 状态码指示服务器在处理请求时出现了错误或无法提供所需的服务。客户端可以根据这些状态码来判断服务器的状态，并采取相应的操作，如等待一段时间后重试请求或联系服务器管理员进行修复。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"导航流程：从输入 URL 到页面展示，这中间发生了什么？","url":"//browser/protocol/http-navigation.html","content":"<p>“在浏览器里，从输入 URL 到页面展示，这中间发生了什么？” 这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。所以我在面试应聘者时也必问这道题，但遗憾的是大多数人只能回答其中部分零散的知识点，并不能将这些知识点串联成线，无法系统而又全面地回答这个问题。</p>\n<p>那么今天我们就一起来探索下这个流程，下图是我梳理出的 “从输入 URL 到页面展示完整流程示意图”：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ccfd568eb9357138671dd.png\" alt=\"从输入URL到页面展示完整流程示意图\"></p>\n<p>从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾一下浏览器进程、渲染进程和网络进程的主要职责：</p>\n<ul>\n<li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能；</li>\n<li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能；</li>\n<li>渲染进程的主要责任是从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这是因为 Chrome 会让渲染进程运行在安全沙箱里的原因，就是为了保证系统的安全。</li>\n</ul>\n<p>回顾了浏览器的进程架构后，我们在结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中的和信节点用蓝色背景标记出来了。这个过程可以大致描述为如下。</p>\n<ul>\n<li>首先，浏览器进程收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程；</li>\n<li>然后，在网络进程中发起真正的 URL 请求；</li>\n<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程；</li>\n<li>浏览器进程接收到网络进程的数据之后，发送 “提交导航（CommitNavigation）” 消息到渲染进程；</li>\n<li>渲染进程接收到 “接收导航” 的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li>\n<li>最后渲染进程会向浏览器进程 “确认提交”，这便是告诉浏览器进程：“已经准备好接受和解析页面数据了”；</li>\n<li>浏览器接收到渲染进程 “提交文档” 的消息后，便开始移除之前的旧文档的文档，然后更新浏览器进程中的页面状态。<br>这其中，<strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong>。</li>\n</ul>\n<h2 id=\"从URL输入到页面展示\"><a href=\"#从URL输入到页面展示\" class=\"headerlink\" title=\"从URL输入到页面展示\"></a>从 URL 输入到页面展示</h2><p>现在我们知道了浏览器几个主要进程的职责，还有在导航过程中需要经历的几个主要的阶段，下面就来详细分析下这些阶段，同时就解答了开头所说的那道经典的面试题。</p>\n<h3 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h3><p>当用户在地址栏中输入一个人查询关键字时，地址栏会判断当前输入的关键字时<strong>搜索内容</strong>，还是 <strong>URL 请求</strong>。</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL；</li>\n<li>如果判断输入内容符合 URL 规则，比如输入的是 <code>time.geekbang.org</code>，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <code>https://time.geekbang.org</code>。</li>\n</ul>\n<p>当用户输入关键字并键入回车后，这意味着当前页面将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许在页面退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如前页面可能有未提交完成的表单等情况，因此用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览不再执行任何后续工作。</p>\n<p>当前浏览器没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ce02468eb9357139f54ab.png\" alt=\"开始加载URL浏览器状态\"></p>\n<p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。单此时图中的页面依旧还是之前打开的页面内容，并没有立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>\n<h3 id=\"URL请求过程\"><a href=\"#URL请求过程\" class=\"headerlink\" title=\"URL请求过程\"></a>URL 请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的请求流程。那具体流程是怎样的呢？</p>\n<p>首先，网络进程会查询本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程，如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 请求，以获取请求域名的服务器 IP 地址。如果协议是 HTTPS，那么还需要建立 TLS 连接。</p>\n<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。浏览器建立之后，浏览器会构建请求行、请求头信息，并把和该域名相关的 Cookies 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>\n<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p>\n<h4 id=\"1-重定向\"><a href=\"#1-重定向\" class=\"headerlink\" title=\"1. 重定向\"></a>1. 重定向</h4><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p>\n<p>比如，我们在终端里输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -i http://time.geekbang.org</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>curl -I + URL</code> 的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ced8a68eb935713b268a1.png\" alt=\"响应行返回状态码301\"></p>\n<p>从图中可以看出，极客时间服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。</p>\n<p>下面我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们看到服务器返回如下信息：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ceeb568eb935713b3acc1.png\" alt=\"响应行返回状态码200\"></p>\n<p>从图中可以看出，服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p>\n<p>好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>\n<h4 id=\"2-响应数据类型处理\"><a href=\"#2-响应数据类型处理\" class=\"headerlink\" title=\"2. 响应数据类型处理\"></a>2. 响应数据类型处理</h4><p>在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</p>\n<p>答案是 Content-Type。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>\n<p>这里我们还是以极客时间为例，看看极客时间官网返回的 Content-Type 值是什么。在终端输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>返回信息如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cef7e68eb935713b43ae4.png\" alt=\"含有HTML格式的Content-Type\"></p>\n<p>从图中可以看到，响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。</p>\n<p>接下来我们再来利用 curl 来请求极客时间安装包的地址，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>请求后返回的响应头信息如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cefa368eb935713b44e1d.png\" alt=\"含有stream格式的Content-Type\"></p>\n<p>从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照<strong>下载类型</strong>来处理该请求。</p>\n<p>需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p>\n<p>所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是 <strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>\n<h3 id=\"准备渲染进程\"><a href=\"#准备渲染进程\" class=\"headerlink\" title=\"准备渲染进程\"></a>准备渲染进程</h3><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>\n<p>比如我从极客时间的首页里面打开了另外一个页面 —— 算法训练营，我们看下图的 Chrome 的任务管理器截图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf5a068eb935713bb62d4.png\" alt=\"多个页面运行在一个渲染进程中\"></p>\n<p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。</p>\n<p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>\n<p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">https://time.geekbang.org</span><br><span class=\"line\">https://www.geekbang.org</span><br><span class=\"line\">https://www.geekbang.org:8080</span><br></pre></td></tr></tbody></table></figure>\n\n<p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。</p>\n<p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果<strong>从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫 process-per-site-instance。</p>\n<p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开 InfoQ 的官网（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW5mb3EuY24vJUVGJUJDJTg5JUVGJUJDJThD\">https://www.infoq.cn/），<i class=\"fa fa-external-link-alt\"></i></span> 因为 infoq.cn 和 geekbang.org 不属于同一站点，所以 infoq.cn 会使用一个新的渲染进程，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf5bf68eb935713bb95e2.png\" alt=\"非同一站点使用不同的渲染进程\"></p>\n<p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有<strong>相同的协议和根域名</strong>，所以它们属于<strong>同一站点</strong>，并运行在同一个渲染进程中；而 infoq.cn 的根域名不同于 geekbang.org，也就是说 InfoQ 和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p>\n<p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p>\n<ul>\n<li>通常情况下，打开新的页面都会使用单独的渲染进程；</li>\n<li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>\n</ul>\n<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>\n<h3 id=\"提交文档\"><a href=\"#提交文档\" class=\"headerlink\" title=\"提交文档\"></a>提交文档</h3><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p>\n<ul>\n<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起 “提交文档” 的消息；</li>\n<li>渲染进程接收到 “提交文档” 的消息后，会和网络进程建立传输数据的 “管道”；</li>\n<li>等文档数据传输完成之后，渲染进程会返回 “确认提交” 的消息给浏览器进程；</li>\n<li>浏览器进程在收到 “确认提交” 的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>\n</ul>\n<p>其中，当渲染进程<strong>确认提交</strong>之后，更新内容如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf74768eb935713bdca7e.png\" alt=\"导航完成状态\"></p>\n<p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>\n<p>到这里，一个完整的导航流程就 “走” 完了，这之后就要进入渲染阶段了。</p>\n<h3 id=\"渲染阶段\"><a href=\"#渲染阶段\" class=\"headerlink\" title=\"渲染阶段\"></a>渲染阶段</h3><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf76a68eb935713be0285.png\" alt=\"渲染结束\"></p>\n<p>至此，一个完整的页面就生成了。那文章开头的 “从输入 URL 到页面展示，这中间发生了什么？” 这个过程及其 “串联” 的问题也就解决了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p>\n<ul>\n<li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li>\n<li>Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li>\n<li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li>\n</ul>\n<p>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"浏览器渲染流程","url":"//browser/protocol/http/render.html","content":"<p>在<a href=\"/browser/protocol/http-navigation.html\">上一篇文章</a>中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你 “看透” 页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局等等。</p>\n<p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e19540ea9cb1403fbcf01.png\" alt=\"渲染流程示意图\"></p>\n<p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>\n<p>这中间的<strong>渲染模块</strong>就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e19680ea9cb1403fbf33d.png\" alt=\"HTML、CSS和JavaScript关系图\"></p>\n<p>从上图可以看出，HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。比如上面的 <code>&lt;p&gt;</code> 标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容。</p>\n<p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为<strong>层叠样式表，是由选择器和属性组成</strong>，比如图中的 p 选择器，它会把 HTML 里面 <code>&lt;p&gt;</code> 标签的内容选择出来，然后再把选择器的属性值应用到 <code>&lt;p&gt;</code> 标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把 <code>&lt;p&gt;</code> 标签的内容显示为红色。</p>\n<p>至于 <strong>JavaScript（简称为 JS），使用它可以使网页的内容 “动” 起来</strong>，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p>\n<p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p>\n<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e26820ea9cb1403168ad3.png\" alt=\"渲染流水线示意图\"></p>\n<p>按照渲染的时间顺序，流水线可以分为如下几个子阶段：构建 DOM 数、计算样式、布局节点、分层、绘制、分块、光栅化和合成。接下来，在介绍每一段的过程中，你应该注意关注以下三点内容：</p>\n<ul>\n<li>开始每个子阶段都有输入内容；</li>\n<li>然后每个子阶段有其他处理过程；</li>\n<li>最终每个子阶段会生成输出内容。<br>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</li>\n</ul>\n<h2 id=\"构建-DOM-树\"><a href=\"#构建-DOM-树\" class=\"headerlink\" title=\"构建 DOM 树\"></a>构建 DOM 树</h2><p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 ——DOM 树。</p>\n<p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e269f0ea9cb140316b3e5.png\" alt=\"树结构示意图\"></p>\n<p>从图中可以看出，树这种结构非常像我们现实生活中的 “树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p>\n<p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e275a0ea9cb140317df8e.png\" alt=\"DOM树构建过程示意图\"></p>\n<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>\n<p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的 “开发者工具”，选择 “Console” 标签来打开控制台，然后在控制台里面输入 “document” 后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e278f0ea9cb14031835ea.png\" alt=\"DOM可视化\"></p>\n<p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p>\n<p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">\"p\"</span>)[<span class=\"number\">0</span>].<span class=\"property\">innerText</span> = <span class=\"string\">\"black\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这行代码的作用是把第一个 <code>&lt;p&gt;</code> 标签的内容修改为 black，具体执行结果你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e27e70ea9cb140318cb4e.png\" alt=\"通过JavaScript修改DOM\"></p>\n<p>从图中可以看出，在执行了一段修改第一个 <code>&lt;p&gt;</code> 标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。</p>\n<p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p>\n<h2 id=\"样式计算（Recalculate-Style）\"><a href=\"#样式计算（Recalculate-Style）\" class=\"headerlink\" title=\"样式计算（Recalculate Style）\"></a>样式计算（Recalculate Style）</h2><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p>\n<h3 id=\"1-把CSS转换为浏览器能够理解的结构\"><a href=\"#1-把CSS转换为浏览器能够理解的结构\" class=\"headerlink\" title=\"1. 把CSS转换为浏览器能够理解的结构\"></a>1. 把 CSS 转换为浏览器能够理解的结构</h3><p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e28840ea9cb140319c468.png\" alt=\"HTML加载CSS的三种方式\"></p>\n<p>从图中可以看出，CSS 样式来源主要有三种：</p>\n<ul>\n<li>通过 link 引用的外部 CSS 文件；</li>\n<li><code>&lt;style&gt;</code> 标记内的 CSS；</li>\n<li>元素的 style 属性内嵌的 CSS<br>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 ——styleSheets</strong>。</li>\n</ul>\n<p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e289f0ea9cb140319f7af.png\" alt=\"styleSheets\"></p>\n<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p>\n<h3 id=\"2-转换样式表中的属性值，使其标准化\"><a href=\"#2-转换样式表中的属性值，使其标准化\" class=\"headerlink\" title=\"2. 转换样式表中的属性值，使其标准化\"></a>2. 转换样式表中的属性值，使其标准化</h3><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p>\n<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {   <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>        }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {      <span class=\"attribute\">color</span>: blue;          }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  {  <span class=\"attribute\">display</span>: none         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">font-weight</span>: bold     }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>  <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: green;         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">color</span>: red;           }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到上面的 CSS 文本中有很多属性值，如 <code>2em</code>、<code>blue</code>、<code>bold</code>，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>那标准化后的属性值是什么样子的？</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {   <span class=\"attribute\">font-size</span>: <span class=\"number\">36px</span>       }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {      <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>) }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  {  <span class=\"attribute\">display</span>: none         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">font-weight</span>: <span class=\"number\">700</span>      }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>  <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">0</span>, <span class=\"number\">128</span>, <span class=\"number\">0</span>) }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到，2em 被解析成了 32px，red 被解析成了 rgb (255,0,0)，bold 被解析成了 700……</p>\n<h3 id=\"3-计算出DOM树中每个节点的具体样式\"><a href=\"#3-计算出DOM树中每个节点的具体样式\" class=\"headerlink\" title=\"3. 计算出DOM树中每个节点的具体样式\"></a>3. 计算出 DOM 树中每个节点的具体样式</h3><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p>\n<p>这就涉及到 CSS 的继承规则和层叠规则了。</p>\n<p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {  <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>             }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {     <span class=\"attribute\">color</span>: blue;                }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  { <span class=\"attribute\">display</span>: none               }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {   <span class=\"attribute\">font-weight</span>: bold;<span class=\"attribute\">color</span>:red }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: green;               }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2c530ea9cb14031eba5c.png\" alt=\"计算后DOM的样式\"></p>\n<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p>\n<p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，再选择 “style” 子标签，你会看到如下界面：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2c820ea9cb14031edcbd.png\" alt=\"样式的继承过程界面\"></p>\n<p>这个界面展示的信息很丰富，大致可描述为如下。</p>\n<ul>\n<li>首先，可以选择要查看的<strong>元素的样式（位于图中的区域 2 中）</strong>，在图中的第 1 个区域中点击对应的元素，就可以在下面的区域查看该元素的样式了。比如这里我们选择的元素是 <code>&lt;p&gt;</code> 标签，位于 <code>html.body.div.</code> 这个路径下面。</li>\n<li>其次，可以从<strong>样式来源（位于图中的区域 3 中）</strong>中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。<strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式</strong>。</li>\n<li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。<br>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</li>\n</ul>\n<p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称 “层叠样式表” 正是强调了这一点</strong>。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。</p>\n<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p>\n<p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，然后再选择 “Computed” 子标签，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2cb90ea9cb14031f29e4.png\" alt=\"DOM元素最终计算的样式\"></p>\n<p>上图红色方框中显示了 <code>html.body.div.p</code> 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了。</p>\n<h2 id=\"布局阶段\"><a href=\"#布局阶段\" class=\"headerlink\" title=\"布局阶段\"></a>布局阶段</h2><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p>\n<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>\n<h3 id=\"1-创建布局树\"><a href=\"#1-创建布局树\" class=\"headerlink\" title=\"1. 创建布局树\"></a>1. 创建布局树</h3><p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 <code>display:none</code> 属性的元素。所以在<strong>显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p>\n<p>我们结合下图来看看布局树的构造过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2f090ea9cb1403231904.png\" alt=\"布局树构造过程示意图\"></p>\n<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>\n<p>为了构建布局树，浏览器大体上完成了下面这些工作：</p>\n<ul>\n<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li>\n<li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 <code>body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树。</li>\n</ul>\n<h3 id=\"2-布局计算\"><a href=\"#2-布局计算\" class=\"headerlink\" title=\"2. 布局计算\"></a>2. 布局计算</h3><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p>\n<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>\n<p>答案依然是否定的。</p>\n<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>\n<p>要想直观地理解什么是图层，你可以打开 Chrome 的 “开发者工具”，选择 “Layers” 标签，就可以可视化页面的分层情况，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3b160ea9cb1403381d0c.png\" alt=\"渲染引擎给页面多图层示意图\"></p>\n<p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3b7a0ea9cb140338effe.png\" alt=\"图层叠加的最终展示页面\"></p>\n<p>现在你知道了<strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3bdf0ea9cb140339b58c.png\" alt=\"布局树和图层树关系示意图\"></p>\n<p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>\n<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>\n<p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层</strong>。</p>\n<p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3c340ea9cb14033a6f64.png\" alt=\"层叠上下文示意图\"></p>\n<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>\n<p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层</strong>。</p>\n<p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">div</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">width</span>: <span class=\"number\">200</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">height</span>: <span class=\"number\">200</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">overflow</span>:auto;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">background</span>: gray;</span></span><br><span class=\"line\"><span class=\"language-css\">        } </span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这里我们把 div 的大小限定为 <code>200 * 200</code> 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 <code>200 * 200</code> 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3e1d0ea9cb14033e8787.png\" alt=\"剪裁执行结果\"></p>\n<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3e350ea9cb14033eb626.png\" alt=\"被裁剪的内容会出现在单独一层\"></p>\n<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p>\n<h2 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>\n<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>\n<p>通常，你会把你的绘制操作分解为三步：</p>\n<ol>\n<li>绘制蓝色背景；</li>\n<li>在中间绘制一个红色的圆；</li>\n<li>再在圆上绘制绿色三角形。<br>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3ebc0ea9cb14033fe7b4.png\" alt=\"绘制列表\"></p>\n<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开 “开发者工具” 的 “Layers” 标签，选择 “document” 层，来实际体验下绘制列表，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3f250ea9cb14034112d7.png\" alt=\"一个图层的绘制列表\"></p>\n<p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p>\n<h2 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3fbc0ea9cb140342453f.png\" alt=\"渲染进程中的合成线程和主线程\"></p>\n<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>\n<p>那我们得先来看看什么是视口，你可以参看下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e403d0ea9cb1403435f72.png\" alt=\"视口\"></p>\n<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。</p>\n<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，<strong>合成线程会将图层划分为图块</strong>（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e40a20ea9cb1403440a1c.png\" alt=\"图层被划分为图块示意图\"></p>\n<p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e40fb0ea9cb140344bde8.png\" alt=\"合成线程提交图块给栅格化线程池\"></p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n<p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e412d0ea9cb140345186c.png\" alt=\"GPU栅格化\"></p>\n<p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p>\n<h2 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 ——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>\n<h2 id=\"渲染流水线大总结\"><a href=\"#渲染流水线大总结\" class=\"headerlink\" title=\"渲染流水线大总结\"></a>渲染流水线大总结</h2><p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e41d80ea9cb1403463b38.png\" alt=\"完整的渲染流水线示意图\"></p>\n<p>结合上图，我们可以大致总结为：</p>\n<ul>\n<li>渲染进程将 HTML 内容转化为浏览器可以识别的 DOM 树结构；</li>\n<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式；</li>\n<li>创建布局树，并计算元素的布局信息；</li>\n<li>对布局树进行分层，并生成分层树；</li>\n<li>为每个图床生成<strong>绘制列表</strong>，并将其提交到合成线程；</li>\n<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转化成位图；</li>\n<li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程；</li>\n<li>浏览器根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li>\n</ul>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念 ——<strong>“重排”“重绘” 和 “合成”</strong>。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p>\n<h3 id=\"1-更新了元素的几何属性（重排）\"><a href=\"#1-更新了元素的几何属性（重排）\" class=\"headerlink\" title=\"1. 更新了元素的几何属性（重排）\"></a>1. 更新了元素的几何属性（重排）</h3><p>你可先参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4a980ea9cb140354fc18.png\" alt=\"更新元素的几何属性\"></p>\n<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p>\n<h3 id=\"2-更新元素的绘制属性（重绘）\"><a href=\"#2-更新元素的绘制属性（重绘）\" class=\"headerlink\" title=\"2. 更新元素的绘制属性（重绘）\"></a>2. 更新元素的绘制属性（重绘）</h3><p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4af50ea9cb140355ae73.png\" alt=\"更新元素背景\"></p>\n<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p>\n<h3 id=\"3-直接合成阶段\"><a href=\"#3-直接合成阶段\" class=\"headerlink\" title=\"3. 直接合成阶段\"></a>3. 直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。具体流程参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4b6d0ea9cb14035676b3.png\" alt=\"避开重排和重绘\"></p>\n<p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p>\n<p>通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"HTTP 请求流程","url":"//browser/protocol/http/flow.html","content":"<p>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。</p>\n<p>不知道你是否有过下面这些疑问：</p>\n<ol>\n<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>\n<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>\n</ol>\n<p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识。</p>\n<h2 id=\"浏览器端发起HTTP请求流程\"><a href=\"#浏览器端发起HTTP请求流程\" class=\"headerlink\" title=\"浏览器端发起HTTP请求流程\"></a>浏览器端发起 HTTP 请求流程</h2><p>如果你在浏览器地址栏里键入极客时间网站的地址：<code>http://time.geekbang.org/index.html</code>，那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细 “追踪” 下。</p>\n<h3 id=\"1-构建请求\"><a href=\"#1-构建请求\" class=\"headerlink\" title=\"1. 构建请求\"></a>1. 构建请求</h3><p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GET /index.html HTTP1.1</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-查找缓存\"><a href=\"#2-查找缓存\" class=\"headerlink\" title=\"2. 查找缓存\"></a>2. 查找缓存</h3><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p>\n<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p>\n<ul>\n<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>\n<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>\n</ul>\n<p>当然，如果缓存查找失败，就会进入网络请求过程了。</p>\n<h3 id=\"3-准备IP地址和端口\"><a href=\"#3-准备IP地址和端口\" class=\"headerlink\" title=\"3. 准备IP地址和端口\"></a>3. 准备 IP 地址和端口</h3><p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 <strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用 <strong>TCP/IP 作传输层协议</strong>将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 <strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的</strong>，你可以结合下图更好地理解这二者的关系。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617817268eb93571332e6ba.png\" alt=\"HTTP和TCP的关系图\"></p>\n<p>那接下来你可以思考这么 “一连串” 问题：</p>\n<ul>\n<li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li>\n<li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li>\n<li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li>\n</ul>\n<p>在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 47.108.140.70, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做 “<strong>域名系统</strong>”，简称 <strong>DNS</strong>（Domain Name System）。</p>\n<p>所以，这样一路推导下来，你会发现在<strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了 <strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>\n<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>\n<h3 id=\"4-等待TCP队列\"><a href=\"#4-等待TCP队列\" class=\"headerlink\" title=\"4. 等待TCP队列\"></a>4. 等待 TCP 队列</h3><p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p>\n<p>答案依然是 “不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p>\n<p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>\n<h3 id=\"5-建立TCP连接\"><a href=\"#5-建立TCP连接\" class=\"headerlink\" title=\"5. 建立TCP连接\"></a>5. 建立 TCP 连接</h3><p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p>\n<h3 id=\"6-发送HTTP请求\"><a href=\"#6-发送HTTP请求\" class=\"headerlink\" title=\"6. 发送HTTP请求\"></a>6. 发送 HTTP 请求</h3><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p>\n<p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617825968eb93571334d43f.png\" alt=\"HTTP请求数据格式\"></p>\n<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p>\n<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p>\n<p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>\n<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p>\n<h2 id=\"服务器端处理HTTP请求流程\"><a href=\"#服务器端处理HTTP请求流程\" class=\"headerlink\" title=\"服务器端处理HTTP请求流程\"></a>服务器端处理 HTTP 请求流程</h2><p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。</p>\n<h3 id=\"1-返回请求\"><a href=\"#1-返回请求\" class=\"headerlink\" title=\"1. 返回请求\"></a>1. 返回请求</h3><p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -i  https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意这里加上了 <code>-i</code> 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661792e568eb9357134fa9f3.png\" alt=\"服务器响应的数据格式\"></p>\n<p>首先服务器会返回响应行，包括协议版本和状态码。</p>\n<p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p>\n<ul>\n<li>最常用的状态码是 200，表示处理成功；</li>\n<li>如果没有找到页面，则会返回 404。</li>\n</ul>\n<p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p>\n<p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p>\n<p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>\n<p>以上这些就是服务器响应浏览器的具体过程。</p>\n<h3 id=\"2-断开连接\"><a href=\"#2-断开连接\" class=\"headerlink\" title=\"2. 断开连接\"></a>2. 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Connection:Keep-Alive </span><br></pre></td></tr></tbody></table></figure>\n\n<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>\n<h3 id=\"3-重定向\"><a href=\"#3-重定向\" class=\"headerlink\" title=\"3. 重定向\"></a>3. 重定向</h3><p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 <code>geekbang.org</code> 后，你会发现最终打开的页面地址是 <code>https://www.geekbang.org</code>。</p>\n<p>这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 <code>geekbang.org</code> 会返回什么内容？</p>\n<p>在控制台输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I geekbang.org</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意这里输入的参数是 - I，和 - i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617935568eb9357135076d5.jpg\" alt=\"服务器返回响应行和响应头（含重定向格式）\"></p>\n<p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <code>https://www.geekbang.org</code> 了。</p>\n<p>不过也不要认为这种跳转是必然的。如果你打开 <code>https://12306.cn</code>，你会发现这个站点是打不开的。这是因为 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 <code>https://www.12306.cn</code> 才能打开页面。</p>\n<h2 id=\"问题解答\"><a href=\"#问题解答\" class=\"headerlink\" title=\"问题解答\"></a>问题解答</h2><p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p>\n<h3 id=\"1-为什么很多站点第二次打开速度会很快？\"><a href=\"#1-为什么很多站点第二次打开速度会很快？\" class=\"headerlink\" title=\"1. 为什么很多站点第二次打开速度会很快？\"></a>1. 为什么很多站点第二次打开速度会很快？</h3><p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>\n<p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，<strong>DNS 缓存</strong>和<strong>页面资源缓存</strong>这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p>\n<p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661793fc68eb93571351b089.png\" alt=\"缓存查找流程示意图\"></p>\n<p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p>\n<p>从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Cache-Control:Max-age=2000</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这也就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p>\n<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">If-None-Match:\"4f80f-13c-3a1xb12a\"</span><br></pre></td></tr></tbody></table></figure>\n\n<p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>\n<ul>\n<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li>\n<li> 如果资源有更新，服务器就直接返回最新资源给浏览器。</li>\n</ul>\n<p>关于缓存的细节内容特别多，具体细节你可以参考这篇 HTTP 缓存，在这里我就不赘述了。</p>\n<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。</p>\n<h3 id=\"2-登录状态是如何保持的？\"><a href=\"#2-登录状态是如何保持的？\" class=\"headerlink\" title=\"2. 登录状态是如何保持的？\"></a>2. 登录状态是如何保持的？</h3><p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p>\n<ul>\n<li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li>\n<li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。</li>\n<li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的 “Cookie” 字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li>\n<li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li>\n</ul>\n<p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617947368eb93571352ffc1.png\" alt=\"Cookie流程图\"></p>\n<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p>\n<p>为了便于你理解，我画了下面这张详细的 “HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661794b368eb9357135378b3.png\" alt=\"HTTP请求流程示意图\"></p>\n<p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p>\n<p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p>\n<p>通过今天系统的讲解，想必你已经了解了一个 HTTP 完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p>\n<p>另外，你应该也看出来了本篇文章是有很多分析问题的思路在里面的。所以在学习过程中，你也要学会提问，通过最终要做什么和现在有什么，去一步步分析并提出一些问题，让疑问带领着你去学习，抓住几个本质的问题就可以学透相关知识点，让你能站在更高维度去查看整体框架。希望它能成为你的一个学习技巧吧！</p>\n<h2 id=\"思考时间\"><a href=\"#思考时间\" class=\"headerlink\" title=\"思考时间\"></a>思考时间</h2><p>最后，还是留给你个思考题：结合今天所讲 HTTP 请求的各个阶段，如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？</p>\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"HTTPS 和 HTTP 的区别","url":"//browser/protocol/http-https.html","content":"<p><strong>HTTP</strong>: 是一种无状态的请求 - 响应协议。是互联网上应用最广泛的一种通讯协议，基于 TCP ，可以使浏览器工作效率更为高效，减少网络传输。</p>\n<p><strong>HTTPS</strong>: 是 HTTP 的加强版，可以认为是 HTTP + SSL (Secure Socket Layer)。 在 HTTP 的基础之上增加了一系列的安全机制。一方面可以保证数据传输的安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>\n<h2 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h2><ol>\n<li><p>安全性</p>\n<ul>\n<li>HTTP 是明文传输协议，数据在传输过程中不加密，容易被篡改和窃听；</li>\n<li>HTTPS 通过使用 SSL (Secure Sockets Layer) 和 TLS (Transport Layer Security) 协议对数据进行加密，确保数据在传输过程中的安全性，防止被窃听和篡改；</li>\n</ul>\n</li>\n<li><p>数据传输协议</p>\n<ul>\n<li>HTTP 使用 TCP (Transmission Control Protocol) 作为传输协议，数据传输速度快；</li>\n<li>HTTPS 在 HTTP 的基础之上加入了 SSL/TLS 协议，需要进行加解密操作，数据传输速度慢；</li>\n</ul>\n</li>\n<li><p>端口号</p>\n<ul>\n<li>HTTP 默认端口号 80；</li>\n<li>HTTPS 默认端口号 443；</li>\n</ul>\n</li>\n<li><p>证书</p>\n<ul>\n<li>HTTPS 需要使用 SSL 证书，用于验证服务器的身份，并确保数据传输的安全；</li>\n<li>HTTP 不需要使用证书。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"HTTP-执行机制\"><a href=\"#HTTP-执行机制\" class=\"headerlink\" title=\"HTTP 执行机制\"></a>HTTP 执行机制</h2><ol>\n<li><p>客户端发起请求:</p>\n<p> 客户端向服务器发送 HTTP 请求。这个请求可以是不同类型的，如 GET（请求数据），POST（提交数据），PUT（更新数据）等；</p>\n</li>\n<li><p>建立连接:</p>\n<p> 客户端通过网络与服务器建立 TCP 连接，通常是到服务器的 80 端口。<br> 对于现代浏览器和服务器，通常使用更复杂的 TCP 握手过程，比如 TCP 快速打开（TFO）和 TLS 假开始（TLS False Start）。</p>\n</li>\n<li><p>发送请求:</p>\n<p> 一旦 TCP 连接建立，客户端发送一个 HTTP 请求。HTTP 请求包括一个请求行（指明动作如 GET 或 POST）、请求头（包含元数据如 User-Agent、Accept、Content-Type 等）和请求体（对于 POST 请求，包含要提交的数据）。</p>\n</li>\n<li><p>服务器处理请求:</p>\n<p> 服务器接收请求并根据请求类型处理它。服务器可能会查询数据库、读取文件或执行其他操作来生成响应。</p>\n</li>\n<li><p>服务器响应:</p>\n<p> 服务器发送一个 HTTP 响应到客户端。响应包括一个状态行（包含状态码如 200 OK 或 404 Not Found）、响应头（包含元数据如 Content-Type、Cache-Control 等）和响应体（包含请求的资源的实际数据）。</p>\n</li>\n<li><p>关闭连接:</p>\n<ul>\n<li>在 HTTP/1.0 中，完成响应后，服务器关闭 TCP 连接；</li>\n<li>在 HTTP/1.1 中，默认使用持久连接（keep-alive），连接在多个请求和响应之后保持打开状态，除非客户端或服务器决定关闭它；</li>\n<li>在 HTTP/2 中，多个请求可以在同一个连接上并行无阻塞地进行，进一步提高效率。</li>\n</ul>\n</li>\n<li><p>客户端处理响应:</p>\n<p> 客户端接收响应并根据内容类型处理数据，如渲染 HTML 页面、解析 JSON 数据等。</p>\n</li>\n</ol>\n<h2 id=\"HTTPS-执行机制\"><a href=\"#HTTPS-执行机制\" class=\"headerlink\" title=\"HTTPS 执行机制\"></a>HTTPS 执行机制</h2><ol>\n<li><p>客户端请求:</p>\n<p> 客户端通过在请求的 URL 中使用 “https://” 来发起一个 HTTPS 连接。</p>\n</li>\n<li><p>TLS 握手</p>\n<p> 服务器在其端口 443 上监听 HTTPS 请求，并在收到请求时响应；<br> 服务器将其 TLS 证书发送给客户端。这个证书包含了服务器的公钥和证书颁发机构（CA）的签名；</p>\n</li>\n<li><p>证书验证:</p>\n<p> 客户端验证服务器的证书是否有效，是否在有效期内，以及是否由受信任的 CA 签发。这个过程也包括检查证书的撤销状态。<br> 这一步，将执行以下步骤进行身份验证：</p>\n<ul>\n<li>验证证书链：客户端检查服务器证书是否由受信任的证书颁发机构（CA）签发，以及证书链是否有效；</li>\n<li>检查有效期：客户端检查证书的有效期，确保证书当前有效期未过期；</li>\n<li>检查撤销状态：客户端肯呢个会检查证书是否被撤销，这可以通过访问 CA 的在线证书状态协议 (OCSP) 服务器或者下载证书撤销列表 (CRL) 来完成；</li>\n<li>验证数字签名：客户端使用 CA 的公钥来解密证书的数字签名，以确保它是由正确的 CA 签发且未被篡改；</li>\n</ul>\n</li>\n<li><p>密钥交换</p>\n<p> 一旦确认证书有效，客户端使用服务器的公钥来加密生成一个随机的会话密钥，并将其发送给服务器；<br> 服务器用其私钥解密这个会话密钥。现在，客户端和服务器端都有了共同的会话密钥，用于后续通信的加密；</p>\n</li>\n<li><p>加密通信</p>\n<p> 使用会话密钥，客户端和服务器端之间的所有数据传输都将被加密。这保证了数据传输的机密性和完整性；<br> 客户端和服务器会使用对称加密算法来加密进一步的通信；</p>\n</li>\n<li><p>数据交换</p>\n<p> 客户端和服务器现在可以完全的交换 HTTP 数据。客户端发送加密的 HTTP 请求，服务器以加密的 HTTP 响应回复；</p>\n</li>\n<li><p>会话结束</p>\n<p> 一旦会话完成，客户端和服务器将结束连接并丢弃会话密钥，确保每一个连接都使用一个新的随机密钥。</p>\n</li>\n</ol>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http","https"]},{"title":"浏览器缓存的全过程","url":"//browser/mechanism/cache.html","content":"<h3 id=\"浏览器缓存的全过程\"><a href=\"#浏览器缓存的全过程\" class=\"headerlink\" title=\"浏览器缓存的全过程\"></a>浏览器缓存的全过程</h3><p><img data-src=\"https://pic.imgdb.cn/item/65323b8ec458853aef72a6ad.png\" alt=\"浏览器缓存的全过程\"></p>\n<p>浏览器缓存的全过程涉及了几种不同的缓存机制，主要包括浏览器缓存和 HTTP 协议中定义的缓存控制策略。下面是浏览器缓存的全过程的概览：</p>\n<ol>\n<li><p>用户方法网页</p>\n<p> 浏览器根据用户请求的 URL 加载相应的网页；</p>\n</li>\n<li><p>浏览器检查缓存</p>\n<p> 浏览器首先检查它的本地缓存（强缓存），检查请求的资源是否已经缓存，并且缓存是否仍然有效（根据 Expires 和 Cache-Control 响应头）；</p>\n</li>\n</ol>\n","categories":["浏览器","缓存"],"tags":["前端","浏览器"]},{"title":"网络劫持有哪几种，如何防范？","url":"//browser/network/hijack.html","content":"<h5 id=\"⽹络劫持\"><a href=\"#⽹络劫持\" class=\"headerlink\" title=\"⽹络劫持\"></a>⽹络劫持</h5><ol>\n<li>DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持)</li>\n</ol>\n<ul>\n<li>DNS 强制解析：通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器</li>\n<li> 302 跳转的⽅式：通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的，再对劫持的内存发起 302 跳转的回复，引导⽤户获取内容</li>\n</ul>\n<ol start=\"2\">\n<li> HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告), 由于 http 明⽂传输，运营商会修改你的 http 响应内容 (即加⼴告)</li>\n</ol>\n<h5 id=\"如何防范网络劫持？\"><a href=\"#如何防范网络劫持？\" class=\"headerlink\" title=\"如何防范网络劫持？\"></a>如何防范网络劫持？</h5><p>DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS 劫持，⽽ http 劫持依然⾮常盛⾏，最有效的办法就是全站 HTTPS，将 HTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>\n<p>网络劫持指的是网络中的某个节点对数据进行恶意篡改和篡改，以达到非法获取用户信息或者控制用户设备的目的。以下是预防网络劫持的几个方法：</p>\n<ol>\n<li><p>使用 HTTPS：HTTPS 是一个安全的协议，对通信进行加密和身份验证，防止劫持者对数据进行篡改。使用 HTTPS 之前，可以使用 SSL 证书来验证服务器的身份。</p>\n</li>\n<li><p>使用 VPN：VPN 可以加密数据并建立一个虚拟私人网络，从而保护用户的数据和隐私。使用 VPN 可以防止网络劫持和嗅探攻击。</p>\n</li>\n<li><p>使用防火墙和反病毒软件：网络劫持者可能会通过恶意软件或病毒对用户设备进行攻击，使用防火墙和反病毒软件可以防止这种攻击。</p>\n</li>\n<li><p>更新操作系统和软件程序：最新版本的操作系统和软件程序通常包含了修复安全漏洞的补丁。不定期更新操作系统和软件程序可以减少遭受网络攻击的风险。</p>\n</li>\n<li><p>警惕钓鱼网站和不安全的链接：劫持者可能会伪造合法的网站或链接，引导用户向其提供个人信息或下载恶意软件。不要轻信不安全的链接，要时刻保持警惕。</p>\n</li>\n</ol>\n","categories":["浏览器","网路安全"],"tags":["前端","浏览器","网路安全"]},{"title":"浏览器的渲染进程的线程","url":"//browser/render/process.html","content":"<h4 id=\"浏览器的渲染进程的线程\"><a href=\"#浏览器的渲染进程的线程\" class=\"headerlink\" title=\"浏览器的渲染进程的线程\"></a>浏览器的渲染进程的线程</h4><p><img data-src=\"https://pic.imgdb.cn/item/6532800ac458853aef6782e0.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"GUI-渲染线程\"><a href=\"#GUI-渲染线程\" class=\"headerlink\" title=\"GUI 渲染线程\"></a>GUI 渲染线程</h5><p>GUI 渲染线程是在 GUI 应用程序中负责界面渲染的线程。负责渲染浏览器页面，解析 HTML、CSS，构建 DOM 树、构建 CSSOM 树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</p>\n<p>在许多 GUI 应用程序中，渲染线程通常会在主线程中运行，这可能会导致界面卡顿或响应时间过长。为了避免这种情况，一些框架和库已经实现了将 GUI 渲染线程与主线程分离的机制，例如 Android 中的 UI 线程和渲染线程分离机制。</p>\n<p>当渲染线程与主线程分离时，它可以专注于绘制和更新屏幕上的内容，而主线程则可以处理用户输入和其他逻辑。这样可以提高应用程序的响应速度和用户体验。</p>\n<p><strong>注意</strong>：GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p>\n<h5 id=\"JS-引擎线程\"><a href=\"#JS-引擎线程\" class=\"headerlink\" title=\"JS 引擎线程\"></a>JS 引擎线程</h5><p>JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析 Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个 JS 引擎线程在运行 JS 程序。</p>\n<p>在浏览器环境中，JavaScript 引擎线程负责解释和执行 JavaScript 代码，并将执行结果返回给主线程。JavaScript 引擎线程通常是单线程的，这意味着它只能同时执行一个任务。这就是为什么一些耗时的 JavaScript 代码可以阻止页面的渲染和响应。</p>\n<p>为了解决这个问题，浏览器引入了 Web Workers，使得可以使用多个 JavaScript 引擎线程来执行 JavaScript 代码。这些工作线程可以并行地执行 JavaScript 代码，并在完成任务后将结果返回给主线程，从而防止 JavaScript 代码阻塞页面的渲染和响应。</p>\n<p><strong>注意</strong>：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果 JS 执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<h5 id=\"时间触发线程\"><a href=\"#时间触发线程\" class=\"headerlink\" title=\"时间触发线程\"></a>时间触发线程</h5><p>时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当 JS 引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。</p>\n<p>时间触发线程在浏览器中起着非常重要的作用，因为它们可以帮助网站实现许多不同的功能，包括：</p>\n<ul>\n<li><p>启动定时器：当网页需要执行一些定时任务时，可以使用时间触发线程来启动定时器。</p>\n</li>\n<li><p>处理事件：当用户与网页交互时，例如点击按钮或提交表单，时间触发线程将负责处理这些事件并执行相应的回调函数。</p>\n</li>\n<li><p>处理异步请求：当网页需要从服务器获取数据时，可以使用时间触发线程来处理异步请求并执行回调函数。</p>\n</li>\n</ul>\n<p><strong>注意</strong>：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。</p>\n<h5 id=\"定时器触发进程\"><a href=\"#定时器触发进程\" class=\"headerlink\" title=\"定时器触发进程\"></a>定时器触发进程</h5><p>浏览器定时器触发进程是指浏览器中用来触发定时器的进程。在浏览器中，定时器可以使用 JavaScript 的 setTimeout () 和 setInterval () 方法来创建。当设置的时间到达后，浏览器会触发定时器，并执行对应的函数。</p>\n<p>定时器触发进程通常由内核管理，它会在特定时间间隔内不断运行，并检查是否有定时器需要触发。当定时器触发时，该进程会将需要执行的任务推入待执行队列中，然后通知主线程执行。主线程会不断检查待执行队列，如果有任务待执行，则将其取出并执行。</p>\n<p>需要<strong>注意</strong>的是，如果执行的任务需要较长时间才能完成，会导致主线程阻塞，影响页面的响应速度。因此，应该尽可能避免在定时器中执行复杂的任务，或者使用 Web Worker 在后台执行任务，以避免阻塞主线程。</p>\n<p><strong>注意</strong>：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。</p>\n<h5 id=\"异步-http-请求线程\"><a href=\"#异步-http-请求线程\" class=\"headerlink\" title=\"异步 http 请求线程\"></a>异步 http 请求线程</h5><p>在浏览器中，异步 HTTP 请求线程通常由浏览器内部的 JavaScript 引擎处理。当 JavaScript 代码发起一个异步 HTTP 请求时，浏览器会创建一个新的线程来处理该请求，该线程通常是浏览器的网络线程。在该线程中，浏览器会向服务器发送 HTTP 请求，并等待服务器返回响应。</p>\n<p>在等待服务器响应的同时，JavaScript 引擎会继续执行其他代码，不会被阻塞。当服务器返回响应后，浏览器会将响应数据传递给 JavaScript 引擎，在 JavaScript 线程中执行相应的回调函数，用来处理响应数据。</p>\n<p>需要注意的是，由于浏览器对跨域请求进行了限制，在异步 HTTP 请求线程中发起的跨域请求需要经过浏览器的安全机制进行处理，一般需要设置相关的请求头或者使用 JSONP 等技术来解决。</p>\n","categories":["浏览器","渲染"],"tags":["前端","浏览器","GUI"]},{"title":"RESTful 和 RPC 的区别","url":"//browser/restful/and/rpc.html","content":"<h4 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h4><p>RESTful 是一种基于 HTTP 协议，通过 URL、HTTP 方法和参数等方式来访问和操作资源的设计风格和架构方法。它是一种轻量级的、高效的、无状态的 Web 服务架构，可以用于设计和开发各种类型的 Web 应用程序和分布式系统。</p>\n<p>RESTful 的核心思想是资源的定义和管理，将系统中的资源抽象为一组 URI（统一资源标识符），通过 HTTP 方法来对资源进行访问和操作。常用的 HTTP 方法有 GET、POST、PUT、DELETE 等，它们分别对应着资源的查询、新增、更新和删除操作。</p>\n<p>RESTful 的优势在于它简单、灵活、可伸缩、易于维护和扩展。它采用标准的 HTTP 协议和常见的数据格式（如 JSON、XML 等），使得开发人员可以快速地开发出高效、可靠的 Web 服务，并且可以方便地与其他系统进行集成和交互。</p>\n<h4 id=\"RPC（Remote-Procedure-Call）\"><a href=\"#RPC（Remote-Procedure-Call）\" class=\"headerlink\" title=\"RPC（Remote Procedure Call）\"></a>RPC（Remote Procedure Call）</h4><p>RPC（Remote Procedure Call）即远程过程调用，是一种分布式系统中的通信协议。RPC 允许一个程序在另一个计算机上运行的程序请求服务，而不需要了解底层网络细节，就像本地调用一样。</p>\n<p>RPC 的原理是客户端发送请求给服务端，服务端执行相应的操作并返回结果给客户端。RPC 框架隐藏了底层的网络细节和通信协议，使得开发者可以像使用本地函数一样方便地调用远程函数。</p>\n<p>RPC 的优势在于它提供了高效、简单、可靠的远程调用机制，使得分布式系统开发更加便捷。同时，RPC 框架支持多种编程语言和跨平台，使得开发者可以使用不同的编程语言和技术栈来实现分布式系统。一些常用的 RPC 框架有 gRPC、Apache Thrift、Dubbo 等。</p>\n<h4 id=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"><a href=\"#RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\" class=\"headerlink\" title=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"></a>RESTful 和 RPC 是两种不同的远程调用方式，它们的区别主要包括以下几个方面：</h4><ol>\n<li><h5 id=\"设计理念：\"><a href=\"#设计理念：\" class=\"headerlink\" title=\"设计理念：\"></a>设计理念：</h5><ul>\n<li><p>RESTful：是基于 HTTP 协议设计的，着重于资源的定义和管理，通过 URL、HTTP 方法和参数等方式进行资源的访问和操作。</p>\n</li>\n<li><p>RPC：是基于函数调用的，着重于接口的定义和数据传输格式的规范，通过序列化和反序列化来实现远程调用。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"通信协议：\"><a href=\"#通信协议：\" class=\"headerlink\" title=\"通信协议：\"></a>通信协议：</h5><ul>\n<li><p>RESTful：使用 HTTP 协议进行通信，支持 GET、POST、PUT、DELETE 等 HTTP 方法。</p>\n</li>\n<li><p>RPC：使用自定义的协议进行通信，可以使用 TCP、UDP 等网络协议，也可以使用 HTTP 作为传输协议。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"数据传输格式：\"><a href=\"#数据传输格式：\" class=\"headerlink\" title=\"数据传输格式：\"></a>数据传输格式：</h5><ul>\n<li><p>RESTful：通常使用 JSON、XML 等文本格式进行数据传输。</p>\n</li>\n<li><p>RPC：通常使用二进制格式进行数据传输，传输效率更高。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"调用方式：\"><a href=\"#调用方式：\" class=\"headerlink\" title=\"调用方式：\"></a>调用方式：</h5><ul>\n<li><p>RESTful：通过 HTTP 方法进行资源的访问和操作，支持无状态的请求，可以使用缓存等机制提高性能和可伸缩性。</p>\n</li>\n<li><p>RPC：通过函数调用进行接口的访问和操作，需要保持请求和响应之间的状态，不支持缓存等机制。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，RESTful 更加适用于 Web 应用程序和分布式系统的开发，而 RPC 更加适用于高性能和低延迟的系统调用。</p>\n","categories":["浏览器","协议"],"tags":["前端","浏览器","RESTful","RPC","HTTP"]},{"title":"session-cookies 三个缓存 localStorage、sessionStorage、Cookies。","url":"//browser/session/cookies.html","content":"<h1 id=\"session-cookies\"><a href=\"#session-cookies\" class=\"headerlink\" title=\"session-cookies\"></a>session-cookies</h1><pre><code>session-cookies is localStorage、sessionStorage、Cookies。\n</code></pre>\n<p> <a href=\"https://badge.fury.io/js/session-cookies\"><img data-src=\"https://badge.fury.io/js/session-cookies.svg\"></a></p>\n<p>session-cookies This plugin is used to summarize the browser’s three caches localStorage, sessionStorage, Cookies.The plugin is designed to be quick and easy to use. Below is a summary of some apis.</p>\n<p>session-cookies 这个插件是用来汇总浏览器的三个缓存 localStorage、sessionStorage、Cookies。该插件注重使用方便快捷下面是一些 API 汇总说明。</p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">获取所有</th>\n<th align=\"center\">获取单个</th>\n<th align=\"center\">设置单个</th>\n<th align=\"center\">移除单个</th>\n<th align=\"center\">清除所有</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"> cookies</td>\n<td align=\"center\">getCookieList</td>\n<td align=\"center\">getCookie</td>\n<td align=\"center\">setCookie</td>\n<td align=\"center\">removeCookie</td>\n<td align=\"center\">clearCookie</td>\n</tr>\n<tr>\n<td align=\"center\">session</td>\n<td align=\"center\">getAllSessionStorage</td>\n<td align=\"center\">getSessionStorage</td>\n<td align=\"center\">setSessionStorage</td>\n<td align=\"center\">removeSessionStorage</td>\n<td align=\"center\">clearSessionStorage</td>\n</tr>\n<tr>\n<td align=\"center\">local</td>\n<td align=\"center\">getAllLocalStorage</td>\n<td align=\"center\">getLocalStorage</td>\n<td align=\"center\">setLocalStorage</td>\n<td align=\"center\">removeLocalStorage</td>\n<td align=\"center\">clearLocalStorage</td>\n</tr>\n</tbody></table>\n<h4 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm i session-cookies</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"获取所有Cookies\"><a href=\"#获取所有Cookies\" class=\"headerlink\" title=\"获取所有Cookies\"></a>获取所有 Cookies</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { cookies } <span class=\"keyword\">from</span> <span class=\"string\">'session-cookies'</span></span><br><span class=\"line\"></span><br><span class=\"line\">cookies.<span class=\"title function_\">getCookieList</span>(); <span class=\"comment\">// 返回JSON结果数据</span></span><br><span class=\"line\">cookies.<span class=\"title function_\">getCookie</span>(<span class=\"string\">'test'</span>); <span class=\"comment\">// 返回属性值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"设置单个\"><a href=\"#设置单个\" class=\"headerlink\" title=\"设置单个\"></a>设置单个</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">setCookie</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'1234567'</span>); <span class=\"comment\">// 设置属性为字符串需要JSON.stringify</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"移除单个\"><a href=\"#移除单个\" class=\"headerlink\" title=\"移除单个\"></a>移除单个</h5><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">removeCookie</span>(<span class=\"string\">'test'</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"清除所有\"><a href=\"#清除所有\" class=\"headerlink\" title=\"清除所有\"></a>清除所有</h5><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">clearCookie</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"附加API\"><a href=\"#附加API\" class=\"headerlink\" title=\"附加API\"></a>附加 API</h4><table>\n<thead>\n<tr>\n<th>根据 index 下标获取 key 值</th>\n<th>参数</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td> getLocalStorageKeyFindIndex</td>\n<td>index 下标</td>\n<td>返回 key</td>\n</tr>\n<tr>\n<td>getSessionStorageKeyFindIndex</td>\n<td>index 下标</td>\n<td>返回 key</td>\n</tr>\n</tbody></table>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { local } <span class=\"keyword\">from</span> <span class=\"string\">'session-cookies'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">local.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\">local.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'usename'</span>, <span class=\"string\">'songshao'</span>);</span><br><span class=\"line\">local.<span class=\"title function_\">getLocalStorageKeyFindIndex</span>(<span class=\"number\">0</span>); <span class=\"comment\">// test</span></span><br><span class=\"line\">local.<span class=\"title function_\">getLocalStorageKeyFindIndex</span>(<span class=\"number\">1</span>); <span class=\"comment\">// username</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Browsers\"><a href=\"#Browsers\" class=\"headerlink\" title=\"Browsers\"></a>Browsers</h3><figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 只能使用0.1.5 以后版本 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">'https://unpkg.com/session-cookies/lib/sessionCookies.js'</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 其他接口同上面使用只需要增加 sessionCookies 全局配置。</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    sessionCookies.<span class=\"property\">local</span>.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'123456'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","Cache"],"tags":["前端","浏览器","cookies","localStorage","sessionStorage","TypeScript"]},{"title":"服务器端渲染（Server-Side Rendering，简称 SSR）","url":"//browser/render/ssr.html","content":"<p>服务端渲染（Server-Side Rendering，简称 SSR）是一种 Web 应用的渲染方式，其中 HTML 是在服务器上生成的，并作为完整页面发送到客户端（通常是浏览器）。客户端然后解析和显示这个 HTML。这种方法与客户端渲染（Client-Side Rendering，简称 CSR）形成对比，在客户端渲染中，浏览器下载一个最小的 HTML 页面，随后使用 JavaScript 动态生成页面内容。</p>\n<h2 id=\"服务端渲染的主要优势和特点包括\"><a href=\"#服务端渲染的主要优势和特点包括\" class=\"headerlink\" title=\"服务端渲染的主要优势和特点包括\"></a>服务端渲染的主要优势和特点包括</h2><ol>\n<li><p>更快的首次加载:</p>\n<p> 对于用户来说，SSR 可以更快地显示页面的首次可见内容，因为浏览器接收到的是已经渲染的页面。用户不需要等待所有的 JavaScript 加载、执行以及渲染完成。</p>\n</li>\n<li><p>搜索引擎优化（SEO）:</p>\n<p> SSR 对 SEO 更加友好，因为搜索引擎爬虫可以直接抓取和索引服务器渲染的 HTML 内容。而在 CSR 中，爬虫可能需要等待 JavaScript 执行完成，有些搜索引擎的爬虫可能不会执行 JavaScript，这会影响内容的可索引性。</p>\n</li>\n<li><p>共享重复功能:</p>\n<p> 使用 SSR，服务器可以为多个请求重用页面生成的结果，比如通过缓存，提高效率。</p>\n</li>\n<li><p>更好的性能:</p>\n<p> 对于计算能力较低的设备，SSR 可以提供更好的性能体验，因为服务器通常比客户端设备拥有更强的处理能力。</p>\n</li>\n<li><p>简化前端复杂性:</p>\n<p> SSR 应用可能不需要像完全的客户端应用那样复杂的 JavaScript 框架或库。</p>\n</li>\n<li><p>更好的用户体验:</p>\n<p> 用户看到的是完整的页面，因此在页面变得可交互之前，他们可以先阅读内容，而不是看到一个空白屏幕或加载指示符。</p>\n</li>\n</ol>\n<p>然而，服务端渲染也有一些潜在的缺点：</p>\n<ol>\n<li><p>服务器负载:</p>\n<p> SSR 可能会增加服务器的负载，因为服务器必须为每个请求生成页面内容。</p>\n</li>\n<li><p>时间到首字节（TTFB）:</p>\n<p> 虽然用户可以更快地看到内容，但是生成页面内容的服务器处理时间可能会导致更长的时间到首字节。</p>\n</li>\n<li><p>客户端 JavaScript 还是需要:</p>\n<p> 即使页面在服务器上预先渲染，通常客户端 JavaScript 仍然需要以便为页面添加交互功能。</p>\n</li>\n<li><p>复杂的缓存策略:</p>\n<p> 如果页面内容经常变化，实现有效的服务器缓存策略可能会变得复杂。</p>\n</li>\n<li><p>延迟的交互:</p>\n<p> 用户可能能够看到页面内容，但要等到 JavaScript 下载和执行完成后，页面才变得可交互。</p>\n</li>\n</ol>\n<p>SSR 在许多现代 Web 开发框架和库中都得到了支持，如 Next.js（基于 React）、Nuxt.js（基于 Vue.js）和 Angular Universal。这些工具都提供了简化服务端渲染工作流程的功能。</p>\n","categories":["浏览器","render","SSR"],"tags":["前端","浏览器","SSR"]},{"title":"如何实现浏览器内多个标签页之间的通信？","url":"//browser/tab/to/tab.html","content":"<p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>\n<ul>\n<li>使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>\n<li>使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>\n<li>使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>\n<li>使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用 postMessage 方法，进行通信。</li>\n</ul>\n","categories":["浏览器","通讯"],"tags":["前端","浏览器","性能优化"]},{"title":"TCP（Transmission Control Protocol，传输控制协议）","url":"//browser/protocol/tcp.html","content":"<h2 id=\"TCP（Transmission-Control-Protocol，传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol，传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol，传输控制协议）\"></a>TCP（Transmission Control Protocol，传输控制协议）</h2><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，广泛用于互联网中的数据传输。它是 TCP/IP 模型中的核心协议之一，与 IP（Internet Protocol，互联网协议）协同工作，负责在多个网络设备之间传输数据。</p>\n<p>TCP 协议的主要特点和功能包括：</p>\n<ol>\n<li><p>面向连接:</p>\n<p> 在数据传输开始之前，TCP 需要在两端建立一个连接，通常通过三次握手（three-way handshake）过程完成。</p>\n</li>\n<li><p>可靠性传输:</p>\n<p> TCP 提供可靠的数据传输服务，确保数据无差错、不丢失、不重复，并且按序到达。它通过序列号、确认应答（ACKs）、超时重传等机制实现这一点。</p>\n</li>\n<li><p>流量控制:</p>\n<p> TCP 使用滑动窗口协议来进行流量控制，防止快速发送方淹没慢速接收方。</p>\n</li>\n<li><p>拥塞控制:</p>\n<p> TCP 实现拥塞控制算法，如慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery），以避免网络拥塞。</p>\n</li>\n<li><p>全双工通信:</p>\n<p> TCP 提供全双工服务，意味着数据可以在两个方向上同时传输，双方都可以是发送者和接收者。</p>\n</li>\n<li><p>顺序控制和数据重组:</p>\n<p> TCP 在数据包传输中使用序列号对数据包进行排序，确保接收端可以根据这些序列号将数据重新组合成原始的数据流。</p>\n</li>\n<li><p>错误检测:</p>\n<p> TCP 头部包含校验和（checksum）字段，用于检测数据在传输过程中的任何错误。</p>\n</li>\n<li><p>连接管理:</p>\n<p> TCP 协议管理和维护连接的生命周期，包括连接的建立、数据传输和连接的终止（通常通过四次挥手（four-way handshake）过程实现）。</p>\n</li>\n</ol>\n<p>在 TCP/IP 协议栈中，TCP 位于传输层，正上方是应用层，应用层协议如 HTTP、FTP 等使用 TCP 来保证数据传输的可靠性；正下方是网络层，网络层协议如 IP 负责将数据包路由到正确的目的地。TCP 处理的是端到端的通信，确保数据能够在应用程序之间准确无误地传输。</p>\n<p>由于 TCP 提供的可靠性和面向连接的特性，它广泛用于需要保证数据完整性和正确顺序的应用场景，如网页浏览、文件传输、电子邮件发送等。</p>\n<p>下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p>\n<p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了 “建立连接”“传输数据” 和 “断开连接” 三个阶段。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6613c26168eb9357131cee1d.png\" alt=\"一个TCP连接的生命周期\"></p>\n<h2 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP 三次握手</h2><p>TCP 三次握手（Three-way Handshake）是建立 TCP/IP 网络连接的标准过程，其目的是在两个网络主机之间创建一个可靠的连接。这个过程确保了双方都准备好接收和发送数据，并且同步了双方的初始序列号，用于数据包的正确排序和可靠传输。下面是 TCP 三次握手的详细步骤：</p>\n<h3 id=\"第一次握手：SYN\"><a href=\"#第一次握手：SYN\" class=\"headerlink\" title=\"第一次握手：SYN\"></a>第一次握手：SYN</h3><p><strong>客户端发送 SYN 包</strong>:</p>\n<p>客户端选择一个初始序列号（ISN）并向服务器发送一个 SYN（同步）包。这个 SYN 包包含客户端的初始序列号，并且 SYN 标志位被设置为 1，其他标志位（如 ACK）被设置为 0。</p>\n<h3 id=\"第二次握手：SYN-ACK\"><a href=\"#第二次握手：SYN-ACK\" class=\"headerlink\" title=\"第二次握手：SYN-ACK\"></a>第二次握手：SYN-ACK</h3><p><strong>服务器回应 SYN-ACK 包</strong>:</p>\n<p>服务器接收到 SYN 包后，发送一个 SYN-ACK（同步 - 确认）包作为回应。该包含有服务器自己的初始序列号，同时将客户端的初始序列号加 1，并在 ACK 字段中回传此值，以确认接收到客户端的 SYN。此时，SYN 和 ACK 标志位都被设置为 1。</p>\n<h3 id=\"第三次握手：ACK\"><a href=\"#第三次握手：ACK\" class=\"headerlink\" title=\"第三次握手：ACK\"></a>第三次握手：ACK</h3><p><strong>客户端发送 ACK 包</strong>:</p>\n<p>客户端收到 SYN-ACK 包后，将服务器的序列号加 1，并将这个值放在 ACK 包的确认字段中，发送给服务器。这个 ACK 包的 ACK 标志位设置为 1，表示确认。</p>\n<h3 id=\"握手完成\"><a href=\"#握手完成\" class=\"headerlink\" title=\"握手完成\"></a>握手完成</h3><p><strong>连接建立</strong>:</p>\n<p>服务器接收到客户端的 ACK 包后，三次握手完成，客户端和服务器之间建立了一个双向的可靠连接。之后，数据可以在双方之间开始传输。</p>\n<p>这个过程的关键在于两次增量序列号的交换，这保证了双方都能确认对方已准备好进行通信，并且正确地维护了 TCP 的状态信息。三次握手可以防止历史连接的初始化数据段突然出现在当前连接中，从而导致不可预料的问题。</p>\n<p>简化的表示如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">客户端                     服务器</span><br><span class=\"line\">  |-----SYN(X)------------&gt;|</span><br><span class=\"line\">  |&lt;----SYN(Y), ACK(X+1)---|</span><br><span class=\"line\">  |-----ACK(Y+1)----------&gt;|</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，X 和 Y 分别是客户端和服务器选择的初始序列号。</p>\n<p>值得注意的是，TCP 三次握手仅仅是建立连接的一部分，数据传输会在三次握手之后开始，而在数据传输结束后，TCP 用另一个独立的四次挥手（Four-way Handshake）过程来关闭连接。</p>\n<h2 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP 四次挥手</h2><p>TCP（传输控制协议）四次挥手是用于终止一个已经建立的 TCP 连接的过程。这个过程确保了双方都能够完成数据传输并且正确关闭连接。以下是 TCP 四次挥手的详细步骤：</p>\n<h3 id=\"第一次挥手：FIN-WAIT-1\"><a href=\"#第一次挥手：FIN-WAIT-1\" class=\"headerlink\" title=\"第一次挥手：FIN_WAIT_1\"></a>第一次挥手：FIN_WAIT_1</h3><ul>\n<li>假设客户端决定关闭连接，它发送一个 FIN（结束）标志的 TCP 段给服务器，表示客户端已经没有数据要发送了。</li>\n<li>客户端进入 FIN_WAIT_1 状态，等待服务器的确认。</li>\n</ul>\n<h3 id=\"第二次挥手：CLOSE-WAIT\"><a href=\"#第二次挥手：CLOSE-WAIT\" class=\"headerlink\" title=\"第二次挥手：CLOSE_WAIT\"></a>第二次挥手：CLOSE_WAIT</h3><ul>\n<li>服务器收到这个 FIN 段后，发送一个 ACK（确认）标志的 TCP 段作为回应，确认已经收到客户端的终止请求。</li>\n<li>服务器进入 CLOSE_WAIT 状态，此时客户端收到 ACK 后进入 FIN_WAIT_2 状态。</li>\n<li>此时，客户端到服务器的连接已经关闭，但是服务器如果还有数据要发送，可以继续发送。</li>\n</ul>\n<h3 id=\"第三次挥手：LAST-ACK\"><a href=\"#第三次挥手：LAST-ACK\" class=\"headerlink\" title=\"第三次挥手：LAST_ACK\"></a>第三次挥手：LAST_ACK</h3><ul>\n<li>当服务器完成数据发送后，它也会决定关闭连接，发送一个 FIN 标志的 TCP 段给客户端。</li>\n<li>服务器进入 LAST_ACK 状态，等待客户端的确认。</li>\n</ul>\n<h3 id=\"第四次挥手：TIME-WAIT\"><a href=\"#第四次挥手：TIME-WAIT\" class=\"headerlink\" title=\"第四次挥手：TIME_WAIT\"></a>第四次挥手：TIME_WAIT</h3><ul>\n<li>客户端收到服务器的 FIN 段后，发送一个 ACK 标志的 TCP 段作为回应，确认已经收到服务器的终止请求。</li>\n<li>客户端进入 TIME_WAIT 状态，持续 2 个最大段生命周期（MSL）的时间后，确保服务器能够接收到确认，然后关闭连接。</li>\n<li>服务器收到 ACK 后，关闭连接，进入 CLOSED 状态。</li>\n</ul>\n<p>这个过程确保了双方都有机会完成数据传输并清理连接。如果在四次挥手过程中的任何一步发生网络延迟或丢包，TCP 协议会重试发送丢失的段，直到成功完成四次挥手过程。这个过程是 TCP 提供可靠传输服务的关键机制之一。</p>\n<p>简化的表示如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"> 客户端                       服务器</span><br><span class=\"line\">FIN_WAIT_1    |-----FIN----&gt;|</span><br><span class=\"line\">FIN_WAIT_2    |&lt;----ACK-----| CLOSE_WAIT</span><br><span class=\"line\">              |&lt;----FIN-----| LAST_ACK</span><br><span class=\"line\">TIME_WAIT     |-----ACK----&gt;| CLOSED</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","TCP"]},{"title":"TLS（Transport Layer Security，传输层安全协议）三次握手","url":"//browser/protocol/tls.html","content":"<p>TLS（Transport Layer Security，传输层安全协议）三次握手是建立安全层通信的一个过程，它确保了数据在两个通信实体之间的传输是加密和身份验证的。TLS 是一种安全协议，通常用于在网络中传输数据时提供保密性和数据完整性保护。TLS 也可以用作其他协议的底层安全层，例如 HTTPS（超文本传输安全协议）是 HTTP 协议的安全版本，它使用了 TLS/SSL 协议进行数据传输。</p>\n<p>TLS 三次握手过程如下：</p>\n<ol>\n<li><p><strong>客户端 Hello（ClientHello）</strong>:</p>\n<ul>\n<li>客户端开始建立连接，发送一个 ClientHello 消息给服务器。这个消息包括客户端支持的 TLS 版本、一个客户端生成的随机数（ClientRandom），以及客户端支持的加密套件列表（cipher suites）。</li>\n<li>客户端还可能会请求服务器的证书，以及其它与安全相关的信息。</li>\n</ul>\n</li>\n<li><p><strong>服务器 Hello（ServerHello）</strong>:</p>\n<ul>\n<li>服务器收到 ClientHello 消息后，会从客户端提供的加密套件列表中选择一个加密算法，并在 ServerHello 消息中通知客户端。</li>\n<li>服务器也会生成一个随机数（ServerRandom），并把自己的证书（包含公钥）发送给客户端。如果服务器需要对客户端进行身份验证，它也可以发送一个证书请求。</li>\n</ul>\n</li>\n<li><p><strong>客户端验证（Client Verification）</strong>:</p>\n<ul>\n<li>客户端收到服务器的证书后，会验证其有效性（例如，检查证书是否过期，是否由受信任的证书颁发机构签发等）。</li>\n<li>客户端会生成第三个随机数（ClientVerifyRandom），并使用服务器的公钥加密这个随机数，然后将加密后的数据发送给服务器（Pre-Master Secret）。</li>\n<li>如果服务器请求了客户端证书，客户端也会发送自己的证书。</li>\n</ul>\n</li>\n<li><p><strong>服务器完成（Server Finished）</strong>:</p>\n<ul>\n<li>服务器使用自己的私钥解密收到的 Pre-Master Secret。</li>\n<li>服务器和客户端都将使用 ClientRandom、ServerRandom 和 ClientVerifyRandom 这三个随机数，通过一定的算法生成相同的会话密钥（Session Key）。</li>\n<li>服务器发送 Finished 消息给客户端，这个消息是使用新生成的会话密钥加密的。</li>\n</ul>\n</li>\n<li><p><strong>客户端完成（Client Finished）</strong>:</p>\n<ul>\n<li>客户端收到服务器的 Finished 消息后，使用会话密钥解密，并验证消息的正确性。</li>\n<li>客户端也发送一个 Finished 消息给服务器，同样使用会话密钥加密。</li>\n</ul>\n</li>\n</ol>\n<p>完成以上步骤后，客户端和服务器就建立了一个安全的连接，可以开始安全地传输数据。需要注意的是，TLS 协议中的 “三次握手” 与 TCP 协议的三次握手是不同的概念。TLS 的三次握手是指在 TLS 密钥交换过程中的步骤，而 TCP 的三次握手是指在建立一个可靠的传输层连接的过程中的步骤。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","TLS"]},{"title":"什么是 JavaScript 的调用栈","url":"//browser/javascript/stack.html","content":"<p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>\n<p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">b,c</span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b+c</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addAll</span>(<span class=\"params\">b,c</span>){</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">10</span></span><br><span class=\"line\">result = <span class=\"title function_\">add</span>(b,c)</span><br><span class=\"line\"><span class=\"keyword\">return</span>  a+result+d</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">addAll</span>(<span class=\"number\">3</span>,<span class=\"number\">6</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p>\n<p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p>\n<p>第一步，创建全局上下文，并将其压入栈底。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66208e950ea9cb1403d68448.png\" alt=\"全局执行上下文压栈\"></p>\n<p>从图中你也可以看出，变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</p>\n<p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090130ea9cb1403e0909e.png\" alt=\"赋值操作改变执行上下文中的值\"></p>\n<p>接下来，第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090720ea9cb1403e2eec8.png\" alt=\"执行addAll函数时的调用栈\"></p>\n<p>addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</p>\n<p>然后接着往下执行，第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090a30ea9cb1403e425b4.png\" alt=\"执行add函数时的调用栈\"></p>\n<p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090c80ea9cb1403e523a9.png\" alt=\"add函数执行结束时的调用栈\"></p>\n<p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090f60ea9cb1403e639d6.png\" alt=\"addAll函数执行结束时的调用栈\"></p>\n<p>至此，整个 JavaScript 流程执行结束了。</p>\n<p>好了，现在你应该知道了<strong>调用栈是 JavaScript 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>\n<h2 id=\"在开发中，如何利用好调用栈\"><a href=\"#在开发中，如何利用好调用栈\" class=\"headerlink\" title=\"在开发中，如何利用好调用栈\"></a>在开发中，如何利用好调用栈</h2><p>鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。</p>\n<h3 id=\"如何利用浏览器查看调用栈的信息\"><a href=\"#如何利用浏览器查看调用栈的信息\" class=\"headerlink\" title=\"如何利用浏览器查看调用栈的信息\"></a>如何利用浏览器查看调用栈的信息</h3><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p>\n<p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开 “开发者工具”，点击 “Source” 标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边 “call stack” 来查看当前的调用栈的情况，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6620919e0ea9cb1403ea1c3f.png\" alt=\"查看函数调用关系\"></p>\n<p>从图中可以看出，右边的 “call stack” 下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以<strong>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的</strong>。</p>\n<p>除了通过断点来查看调用栈，你还可以使用 console.trace () 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace ()，你就可以看到控制台输出的结果，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662091dd0ea9cb1403ebbedf.png\" alt=\"使用trace函数输出当前调用栈信息\"></p>\n<h3 id=\"栈溢出（Stack-Overflow）\"><a href=\"#栈溢出（Stack-Overflow）\" class=\"headerlink\" title=\"栈溢出（Stack Overflow）\"></a>栈溢出（Stack Overflow）</h3><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</p>\n<p>特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">division</span>(<span class=\"params\">a,b</span>){</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">division</span>(a,b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">division</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行时，就会抛出栈溢出错误，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662092120ea9cb1403ed1894.png\" alt=\"栈溢出错误\"></p>\n<p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p>\n<p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p>\n<p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客世界\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test1 = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> myName = <span class=\"string\">\"Chrome浏览器\"</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客邦\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test = <span class=\"number\">2</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> test = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"title function_\">bar</span>()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"调用栈分析\"><a href=\"#调用栈分析\" class=\"headerlink\" title=\"调用栈分析\"></a>调用栈分析</h2><p><img data-src=\"https://pic.imgdb.cn/item/661f8ef80ea9cb140395bde2.png\" alt=\"调用栈分析图\"></p>\n<p>当 <code>foo</code> 在执行时</p>\n<ol>\n<li>会先去它当前所在的 <code>if</code> 词法环境中查找；</li>\n<li>在去 <code>bar</code> 所在的词法环境中查找；</li>\n<li>再去 <code>bar</code> 所在的变量环境中查找；</li>\n<li>全局执行上下文中的词法环境中查找；</li>\n<li>最后在变量环境下去查找。</li>\n</ol>\n<p>最终输出：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","javascript"],"tags":["前端","javascript"]},{"title":"Hexo 内容分页配置","url":"//hexo/config/pagination.html","content":"<h4 id=\"per-page-config-yml\"><a href=\"#per-page-config-yml\" class=\"headerlink\" title=\"per_page _config.yml\"></a>per_page _config.yml</h4><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Pagination</span></span><br><span class=\"line\"><span class=\"comment\">## Set per_page to 0 to disable pagination</span></span><br><span class=\"line\"><span class=\"attr\">per_page:</span> <span class=\"number\">20</span> <span class=\"comment\"># 分页条数</span></span><br><span class=\"line\"><span class=\"attr\">pagination_dir:</span> <span class=\"string\">page</span> <span class=\"comment\"># 自定义分页路径</span></span><br></pre></td></tr></tbody></table></figure>\n\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","Pagination"]},{"title":"Hexo 开启公众号引流工具","url":"//hexo/config/readmore.html","content":"<h3 id=\"配置博客信息\"><a href=\"#配置博客信息\" class=\"headerlink\" title=\"配置博客信息\"></a>配置博客信息</h3><p><img data-src=\"https://pic.imgdb.cn/item/6535dc4dc458853aef3ec866.jpg\"></p>\n<h3 id=\"hexo-config-yml-配置\"><a href=\"#hexo-config-yml-配置\" class=\"headerlink\" title=\"hexo _config.yml 配置\"></a>hexo _config.yml 配置</h3><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins:</span></span><br><span class=\"line\">  <span class=\"attr\">readmore:</span></span><br><span class=\"line\">    <span class=\"attr\">blogId:</span> <span class=\"number\">31652</span><span class=\"number\">-1697970027416</span><span class=\"number\">-119</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">BaType</span></span><br><span class=\"line\">    <span class=\"attr\">qrcode:</span> <span class=\"string\">https://i.postimg.cc/BnGK06H2/qrcode-for-gh-50f2ce2229c5-258.jpg</span></span><br><span class=\"line\">    <span class=\"attr\">keyword:</span> <span class=\"number\">666</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，配置参数含义如下:</p>\n<ul>\n<li>blogId : [必选] OpenWrite 后台申请的博客唯一标识，例如：31652-1697970027416-119</li>\n<li>name : [必选] OpenWrite 后台申请的博客名称，例如：BaType</li>\n<li>qrcode : [必选] OpenWrite 后台申请的微信公众号二维码，例如:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLnBvc3RpbWcuY2MvQm5HSzA2SDIvcXJjb2RlLWZvci1naC01MGYyY2UyMjI5YzUtMjU4LmpwZw==\">https://i.postimg.cc/BnGK06H2/qrcode-for-gh-50f2ce2229c5-258.jpg<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>keyword : [必选] OpenWrite 后台申请的微信公众号后台回复关键字，例如：666</li>\n</ul>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p><code>npm install hexo-plugin-readmore --save</code></p>\n<h3 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h3><p><img data-src=\"https://pic.imgdb.cn/item/6535dddec458853aef428ef6.jpg\"></p>\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","ReadMore"]},{"title":"Hexo 开启 RSS","url":"//hexo/config/rss.html","content":"<h5 id=\"安装hexo-generator-feed-插件\"><a href=\"#安装hexo-generator-feed-插件\" class=\"headerlink\" title=\"安装hexo-generator-feed 插件\"></a>安装 hexo-generator-feed 插件</h5><h6 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h6><p><code>npm install hexo-generator-feed -d</code></p>\n<h6 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h6><p><code>yarn add hexo-generator-feed</code></p>\n<h5 id=\"配置-config-themes-yml\"><a href=\"#配置-config-themes-yml\" class=\"headerlink\" title=\"配置_config.[themes].yml\"></a>配置_config.[themes].yml</h5><h6 id=\"增加导航栏菜单\"><a href=\"#增加导航栏菜单\" class=\"headerlink\" title=\"增加导航栏菜单\"></a>增加导航栏菜单</h6><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">RSS:</span> <span class=\"string\">/atom.xml</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h6 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h6><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">atom</span>  <span class=\"comment\"># 类型为atom</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">atom.xml</span> <span class=\"comment\"># 访问路径</span></span><br><span class=\"line\">    <span class=\"attr\">limit:</span> <span class=\"number\">20</span> <span class=\"comment\"># 分页</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<h5 id=\"清除重启\"><a href=\"#清除重启\" class=\"headerlink\" title=\"清除重启\"></a>清除重启</h5><p><code>hexo clean &amp;&amp; hexo generate</code></p>\n<h5 id=\"页面效果\"><a href=\"#页面效果\" class=\"headerlink\" title=\"页面效果\"></a>页面效果</h5><p><img data-src=\"https://pic.imgdb.cn/item/6533d473c458853aefb79c42.png\" alt=\"atom.xml\"></p>\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","RSS"]},{"title":"deb  使用命令","url":"//linux/install/deb.html","content":"<p>使用 dpkg 命令：在终端中运行以下命令来安装.deb 文件：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i &lt;filename&gt;.deb</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","es6"],"tags":["前端","Git","linux","deb"]},{"title":"Docker 的安装和使用","url":"//linux/install/docker.html","content":"<h4 id=\"Linux上安装Docker分为以下几步：\"><a href=\"#Linux上安装Docker分为以下几步：\" class=\"headerlink\" title=\"Linux上安装Docker分为以下几步：\"></a>Linux 上安装 Docker 分为以下几步：</h4><ol>\n<li>设置存储库。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>安装 Docker 引擎 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>启动 Docker</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>设置 docker 开机自启动 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable docker</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>配置镜像加速器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /etc/docker</span><br><span class=\"line\">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class=\"line\">{</span><br><span class=\"line\">  \"registry-mirrors\": [\"https://om7zpa5s.mirror.aliyuncs.com\"]</span><br><span class=\"line\">}</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"镜像命令\"><a href=\"#镜像命令\" class=\"headerlink\" title=\"镜像命令\"></a>镜像命令</h4><ol>\n<li>查看 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>搜索镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker search mysql</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>下载镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull mysql:version</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>删除镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker images // 查看image ID</span><br><span class=\"line\"></span><br><span class=\"line\">docker rmi -f feb5d9fea6a5</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">多个删除</span></span><br><span class=\"line\">docker rmi -f feb5d9fea6a5 feb5d9fea6a5 </span><br><span class=\"line\">docker rmi -f $(docker images -aq)    # 删除全部的镜像</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"容器命令\"><a href=\"#容器命令\" class=\"headerlink\" title=\"容器命令\"></a>容器命令</h4><ol>\n<li>新建容器并启动 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it centos /bin/bash</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>列出所有运行的容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker ps </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">命令参数可选项</span></span><br><span class=\"line\">-a        # 列出当前正在运行的容器+历史运行过的容器</span><br><span class=\"line\">-n=?    # 显示最近创建的容器（可以指定显示几条，比如-n=1）</span><br><span class=\"line\">-q        # 只显示容器的编号</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>退出容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">exit        # 容器直接停止，并退出</span><br><span class=\"line\">ctrl+P+Q    # 容器不停止，退出</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>删除容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker rm 容器id                    # 删除容器（不能删除正在运行的容器）如果要强制删除：docker rm -f 容器id</span><br><span class=\"line\">docker rm -f $(docker ps -aq)        # 删除全部容器</span><br><span class=\"line\">docker ps -a -q|xargs docker rm        # 删除所有容器</span><br><span class=\"line\">docker rm 656c03b3be05</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>启动和停止容器的操作 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker start 容器id # 启动容器</span><br><span class=\"line\">docker restart 容器id # 重启</span><br><span class=\"line\">docker stop 容器id # 停止</span><br><span class=\"line\">docker kill 容器id # 强制停止</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"常用其他命令\"><a href=\"#常用其他命令\" class=\"headerlink\" title=\"常用其他命令\"></a>常用其他命令</h4><ol>\n<li>后台启动容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d centos</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>查看日志 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker logs -tf 5694d2fc0a88</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d centos /bin/sh -c \"while true;do echo batype;sleep 1000;done\"</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>查看容器中的进程 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   6 seconds ago   Up 5 seconds             tender_hofstadter</span><br><span class=\"line\"></span><br><span class=\"line\">docker top 4f9b77aafa46</span><br><span class=\"line\">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class=\"line\">root                14087               14066               0                   17:42               ?                   00:00:00            /bin/sh -c while true;do echo batype;sleep 1000;done</span><br><span class=\"line\">root                14107               14087               0                   17:42               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1000</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>查看镜像的元数据 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker inspect 4f9b77aafa46</span><br><span class=\"line\">[</span><br><span class=\"line\">    {</span><br><span class=\"line\">        \"Id\": \"4f9b77aafa469b2e50ca296515d66b841f60f12343b1a45ddbdd09766e103d0f\",</span><br><span class=\"line\">        \"Created\": \"2023-11-03T09:42:35.034147379Z\",</span><br><span class=\"line\">        \"Path\": \"/bin/sh\",</span><br><span class=\"line\">        \"Args\": [</span><br><span class=\"line\">            \"-c\",</span><br><span class=\"line\">            \"while true;do echo batype;sleep 1000;done\"</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        \"State\": {</span><br><span class=\"line\">            \"Status\": \"running\",</span><br><span class=\"line\">            \"Running\": true,</span><br><span class=\"line\">            \"Paused\": false,</span><br><span class=\"line\">            \"Restarting\": false,</span><br><span class=\"line\">            \"OOMKilled\": false,</span><br><span class=\"line\">            \"Dead\": false,</span><br><span class=\"line\">            \"Pid\": 14087,</span><br><span class=\"line\">            \"ExitCode\": 0,</span><br><span class=\"line\">            \"Error\": \"\",</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        }</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>进入当前正在运行的容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker exec -it 4f9b77aafa46 /bin/bash</span><br><span class=\"line\">[root@4f9b77aafa46 /]# ps =ef</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root         1     0  0 09:42 ?        00:00:00 /bin/sh -c while true;do echo batype;sleep 1000;done</span><br><span class=\"line\">root        20     1  0 13:19 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1000</span><br><span class=\"line\">root        21     0  0 13:30 pts/0    00:00:00 /bin/bash</span><br><span class=\"line\">root        35    21  0 13:31 pts/0    00:00:00 ps -ef</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"6\">\n<li>从容器拷贝文件到主机 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker cp 容器id:容器内路径 目的主机的路径</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# cd /home/</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# ls</span><br><span class=\"line\">html</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago   Up 4 hours             tender_hofstadter</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker exec -it 4f9b77aafa46 /bin/bash</span><br><span class=\"line\">[root@4f9b77aafa46 /]# ls</span><br><span class=\"line\">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class=\"line\">[root@4f9b77aafa46 /]# cd /home/</span><br><span class=\"line\">[root@4f9b77aafa46 home]# ls</span><br><span class=\"line\">[root@4f9b77aafa46 home]# touch test.java</span><br><span class=\"line\">[root@4f9b77aafa46 home]# ls</span><br><span class=\"line\">test.java</span><br><span class=\"line\">[root@4f9b77aafa46 home]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago   Up 4 hours             tender_hofstadter</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker cp 4f9b77aafa46:/home/test.java /home</span><br><span class=\"line\">Successfully copied 1.54kB to /home</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# ls</span><br><span class=\"line\">html  test.java</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步（容器内的/home路径和主机上的/home路径打通）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"练习安装Nginx\"><a href=\"#练习安装Nginx\" class=\"headerlink\" title=\"练习安装Nginx\"></a>练习安装 Nginx</h4><ol>\n<li><p>搜索镜像：docker search nginx (建议去 dockerHub 上去搜索)</p>\n</li>\n<li><p>下载镜像：docker pull nginx</p>\n</li>\n<li><p>启动镜像</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker pull nginx</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/nginx</span><br><span class=\"line\">Digest:</span><br><span class=\"line\">sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</span><br><span class=\"line\">Status: Downloaded newer image for nginx:latest</span><br><span class=\"line\">docker.io/library/nginx:latest</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">-d 后台运行</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">--name=<span class=\"string\">\"nginx01\"</span>    给容器命名</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">-p 宿主机端口:容器内部端口</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker run -d --name nginx01 -p 515:80 nginx</span><br><span class=\"line\">614bbf44138a3e834008f5a33a71194c8e78d7f0e53bccbdfc4c9c9f0c0501cb</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                 NAMES</span><br><span class=\"line\">614bbf44138a   nginx     \"/docker-entrypoint.…\"   8 seconds ago   Up 7 seconds   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp   nginx01</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago     Up 4 hours                                           tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>测试访问 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">访问指向端口515</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# curl 0.0.0.0:515</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">html { color-scheme: light dark; }</span><br><span class=\"line\">body { width: 35em; margin: 0 auto;</span><br><span class=\"line\">font-family: Tahoma, Verdana, Arial, sans-serif; }</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class=\"line\">working. Further configuration is required.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For online documentation and support please refer to</span><br><span class=\"line\">&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class=\"line\">Commercial support is available at</span><br><span class=\"line\">&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br><span class=\"line\">Unable to find image 'portainer/portainer:latest' locally</span><br><span class=\"line\">latest: Pulling from portainer/portainer</span><br><span class=\"line\"></span><br><span class=\"line\">Digest:</span><br><span class=\"line\">  sha256:fb45b43738646048a0a0cc74fcee2865b69efde857e710126084ee5de9be0f3f</span><br><span class=\"line\">Status: Downloaded newer image for portainer/portainer:latest</span><br><span class=\"line\">a1b1156666edf6cad33eb299e35f543b823673a97a9756726d1fbc2cc571bc47</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                       NAMES</span><br><span class=\"line\">a1b1156666ed   portainer/portainer   \"/portainer\"             8 seconds ago   Up 7 seconds   0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   dreamy_goodall</span><br><span class=\"line\">614bbf44138a   nginx                 \"/docker-entrypoint.…\"   8 minutes ago   Up 8 minutes   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp         nginx01</span><br><span class=\"line\">4f9b77aafa46   centos                \"/bin/sh -c 'while t…\"   4 hours ago     Up 4 hours                                                 tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>测试访问</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYXR5cGUuY29tOjgwODgv\">http://www.batype.com:8088/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li><p>连接本地 Local<br><img data-src=\"https://pic.imgdb.cn/item/6545012dc458853aefeef057.jpg\" alt=\"Connect Portainer\"></p>\n</li>\n<li><p>进入之的连接页面<br><img data-src=\"https://pic.imgdb.cn/item/654505fec458853aef03e9b1.jpg\" alt=\"进入之的连接页面\"></p>\n</li>\n</ol>\n<h4 id=\"commit镜像\"><a href=\"#commit镜像\" class=\"headerlink\" title=\"commit镜像\"></a>commit 镜像</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交容器成为一个新的副本</span></span><br><span class=\"line\">docker commit</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">命令和git原理类似</span></span><br><span class=\"line\">docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG]</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker commit -a=\"batype\" -m=\"test\" 614bbf44138a nginx001:18.16.0</span><br><span class=\"line\">sha256:7fcdd59c72c118bccfc2a6d94953e7d18d4a1afadeea0eee304117e917f0aabe</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker images</span><br><span class=\"line\">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">nginx001              18.16.0   7fcdd59c72c1   12 seconds ago   141MB</span><br><span class=\"line\">nginx                 latest    605c77e624dd   22 months ago    141MB</span><br><span class=\"line\">mysql                 latest    3218b38490ce   22 months ago    516MB</span><br><span class=\"line\">centos                latest    5d0da3dc9764   2 years ago      231MB</span><br><span class=\"line\">portainer/portainer   latest    580c0e4e98b0   2 years ago      79.1MB</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                 COMMAND                  CREATED             STATUS             PORTS                                       NAMES</span><br><span class=\"line\">a1b1156666ed   portainer/portainer   \"/portainer\"             About an hour ago   Up About an hour   0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   dreamy_goodall</span><br><span class=\"line\">614bbf44138a   nginx                 \"/docker-entrypoint.…\"   About an hour ago   Up About an hour   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp         nginx01</span><br><span class=\"line\">4f9b77aafa46   centos                \"/bin/sh -c 'while t…\"   5 hours ago         Up 5 hours                                                     tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><h4 id=\"什么是容器数据卷？\"><a href=\"#什么是容器数据卷？\" class=\"headerlink\" title=\"什么是容器数据卷？\"></a>什么是容器数据卷？</h4><p>Docker 容器数据卷，即 Docker Volume（卷）。</p>\n<p>当 Docker 容器运行的时候，会产生一系列的数据文件，这些数据文件会在关闭 Docker 容器时，直接消失的。但是其中产生部分的数据内容，我们是希望能够把它给保存起来，另作它用的。</p>\n<p>关闭 Docker 容器 = 删除内部除了 image 底层数据的其他全部内容，即删库跑路</p>\n<p>所以我们期望：</p>\n<p>将应用与运行的环境打包形成容器运行，伴随着容器运行产生的数据，我们希望这些数据能够持久化。<br>希望容器之间也能够实现数据的共享、</p>\n<p>Docker 容器产生的数据同步到本地，这样关闭容器的时候，数据是在本地的，不会影响数据的安全性。<br>docker 的容器卷技术也就是将容器内部目录和本地目录进行一个同步，即挂载。</p>\n<h4 id=\"使用数据卷\"><a href=\"#使用数据卷\" class=\"headerlink\" title=\"使用数据卷\"></a>使用数据卷</h4><p>主机目录和容器内的目录是映射关系</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试，查看容器信息</span></span><br><span class=\"line\">docker inspect 容器id</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/654510aac458853aef35e748.jpg\"></p>\n<p>停止容器后，在主机的 /home/ceshi 文件夹下，修改文件或新增文件，启动容器，查看容器的 /home 文件夹，发现容器内的数据依旧是同步的</p>\n<ul>\n<li>停止容器。</li>\n<li>宿主机上修改文件。</li>\n<li>启动容器。</li>\n<li>容器内的数据依旧是同步的。</li>\n</ul>\n<h4 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装 MySQL</h4><p><img data-src=\"https://pic.imgdb.cn/item/65451200c458853aef3c1f3c.jpg\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取镜像</span></span><br><span class=\"line\">docker pull mysql:5.7</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">运行容器，需要做数据目录挂载。（安装启动mysql，注意：需要配置密码）</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">官方启动mysql</span></span><br><span class=\"line\">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my123456 -d mysql:5.7</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">配置启动并同步数据</span></span><br><span class=\"line\">docker run -d -p 8081:3306 -v /home/mysql/conf.d:/etc/mysql/conf.d -v /home/mysql/mysql.conf.d:/etc/mysql/mysql.conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=weiliao&amp;666 --name mysql01 mysql:5.7</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"匿名挂载和具名挂载\"><a href=\"#匿名挂载和具名挂载\" class=\"headerlink\" title=\"匿名挂载和具名挂载\"></a>匿名挂载和具名挂载</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如何确定是具名挂载，还是匿名挂载，还是指定路径挂载</span></span><br><span class=\"line\">-v 容器内的路径                # 匿名挂载</span><br><span class=\"line\">-v 卷名:容器内的路径        # 具名挂载</span><br><span class=\"line\">-v /宿主机路径:容器内路径    # 指定路径挂载</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">具名挂载</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class=\"line\">7cd90c3b2f02f9b84e0dd659f0c8179d777b3c9b6c95e11da4db8a7831d0923e</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker volume ls</span><br><span class=\"line\">DRIVER    VOLUME NAME</span><br><span class=\"line\">local     cffb5d0a4839c2deff3d4c3fde9b86795632dd3ee42e256daf68fa3a33d888fd</span><br><span class=\"line\">local     f9515933a80fac5357c7b26742d5870471ae5b21dcef34a79b60e2cc70a4c288</span><br><span class=\"line\">local     juming-nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">匿名挂载</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker run -d --name nginx03 -v /etc/nginx nginx</span><br><span class=\"line\">c27103b64da61544a65037ae16441f2b1ffe6f02ce0729768724752d8c4751f1</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker volume ls</span><br><span class=\"line\">DRIVER    VOLUME NAME</span><br><span class=\"line\">local     3303ec682317c64c023983cc615fa0db5cd6a88b77c4f7361d2594bc68618961</span><br><span class=\"line\">local     cffb5d0a4839c2deff3d4c3fde9b86795632dd3ee42e256daf68fa3a33d888fd</span><br><span class=\"line\">local     f9515933a80fac5357c7b26742d5870471ae5b21dcef34a79b60e2cc70a4c288</span><br><span class=\"line\">local     juming-nginx</span><br></pre></td></tr></tbody></table></figure>\n<p><strong>拓展</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">通过 -v 容器内的路径:ro    rw    改变读写权限</span></span><br><span class=\"line\">ro    read only    # 只读</span><br><span class=\"line\">rw    read write    # 可读可写</span><br><span class=\"line\">docker run -d -p 3345:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class=\"line\">docker run -d -p 3345:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h4><p>dockerfile 就是用来构建 docker 镜像的构建文件。    命令脚本！</p>\n<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个一个的命令，每个命令都是一层！</p>\n<ol>\n<li>创建一个名为 dockerfile 的文件 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">FROM centos</span><br><span class=\"line\">VOLUME [\"volume01\", \"volume02\"]</span><br><span class=\"line\">CMD echo \"-----end-----\"</span><br><span class=\"line\">CMD /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>编译 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker build -f ./dockerfile_songs_note -t songs_note.centos:1.0 .</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ab56c458853aef9204f3.jpg\"></p>\n<ol start=\"3\">\n<li>启动容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it 5f6352c38230 /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">图形选中的就是匿名挂载</span></span><br><span class=\"line\">VOLUME [\"volume01\", \"volume02\"]</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ac56c458853aef949ef9.jpg\"></p>\n<ol start=\"4\">\n<li>查看一下卷挂载的路径：docker inspect 容器 id</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker inspect 95ab48f7bf47</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ad0ac458853aef967f53.jpg\"></p>\n<h4 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h4><p>多个容器同步数据（临时认父）</p>\n<p>将两个容器或者更多容器之间的数据进行数据共享</p>\n<ol>\n<li>启动 3 个容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -d --name docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test.js 文件</span></span><br><span class=\"line\">docker run -it -d --name docker02 --volumes-from docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test1.js 文件</span></span><br><span class=\"line\">docker run -it -d --name docker03 --volumes-from docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test2.js 文件</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入 容器docker01查看</span></span><br><span class=\"line\">[root@ab2fb91dd8c5 volume01]# ls</span><br><span class=\"line\">test.js  test1.js  test2.js</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除某一个容器</span></span><br><span class=\"line\"> [root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker rm -f f0305bd4a916</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看其他容器文件是否还在</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker exec -it 1c7a3dbaf54e /bin/bash</span><br><span class=\"line\">[root@1c7a3dbaf54e /]# cd volume01</span><br><span class=\"line\">[root@1c7a3dbaf54e volume01]# ls</span><br><span class=\"line\">test.js  test1.js  test2.js</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>多个 mysql 实现数据共享 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 7777:3306 -v /home/mysql/conf:/etc mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 7777:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>结论</strong>：<br>容器之间配置信息的传递，数据卷容器的生命同期一直持续到没有容器使用为止。<br>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p>\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><h4 id=\"什么是DockerFile-？\"><a href=\"#什么是DockerFile-？\" class=\"headerlink\" title=\"什么是DockerFile ？\"></a>什么是 DockerFile ？</h4><p>dockerfile 是用来构建 docker 镜像的文件！命令参数脚本！</p>\n<p><strong>构建步骤</strong>：</p>\n<ol>\n<li>编写一个 dockerfile 文件</li>\n<li> docker build 构建成为一个镜像</li>\n<li> docker run 运行镜像</li>\n<li> docker push 发布镜像（DockerHub、阿里云镜像仓库！）</li>\n</ol>\n<h4 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h4><ol>\n<li>每个保留关键字（指令）都是必须是大写字母</li>\n<li>执行从上到下顺序执行</li>\n<li>‘#’ 表示注释</li>\n<li>每一个指令都会创建提交一个新的镜像层，并提交！</li>\n</ol>\n<p>dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 dockerfile 文件，这个文件十分简单！</p>\n<p>DockerFile：构建文件，定义了一切的步骤，源代码。<br>Dockerlmages：通过 DockerFile 构建生成的镜像，最终发布和运行的产品。<br>Docker 容器：容器就是镜像运行起来提供服务的。</p>\n<h4 id=\"DockerFile的命令\"><a href=\"#DockerFile的命令\" class=\"headerlink\" title=\"DockerFile的命令\"></a>DockerFile 的命令</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">FROM         # 基础镜像，一起从这里开始构建</span><br><span class=\"line\">MAINTAINER   # 镜像作者：姓名-邮箱</span><br><span class=\"line\">RUN          # 镜像构建的时候需要运行的命令</span><br><span class=\"line\">ADD          # 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span><br><span class=\"line\">WORKDIR      # 镜像的工作目录</span><br><span class=\"line\">VOLUME       # 挂载的目录</span><br><span class=\"line\">EXPOSE       # 暴露端口配置</span><br><span class=\"line\">CMD          # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class=\"line\">ENTRYPOINT   # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class=\"line\">ONBUILD      # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD 的指令，触发指令。</span><br><span class=\"line\">CPOY         # 类似ADD，将我们的文件拷贝到镜像中</span><br><span class=\"line\">ENV          # 构建的时候设置环境变量！</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><ol>\n<li>编写 dockerfile 的文件 </li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos:latest</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> batye&lt;<span class=\"number\">1175715363</span>@qq.com&gt;</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MYPATH /usr/local</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install vim</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install net-tools</span></span><br><span class=\"line\">EXPOST <span class=\"number\">8001</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">\"----end----\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> /bin/bash</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>构建文件镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker build -f dockerFile_test -t vim.centos:0.0.1 .</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>原生 contos7</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run -it centos</span><br><span class=\"line\">[root@566d6bd3f48d /]# pwd</span><br><span class=\"line\">/</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作目录为根目录</span></span><br><span class=\"line\">[root@566d6bd3f48d /]# vim</span><br><span class=\"line\">bash: vim: command not found</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">没有vim 工具</span></span><br><span class=\"line\">[root@566d6bd3f48d /]# exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>vim.centos 增加配置以后的镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run -it vim.centos:0.0.1</span><br><span class=\"line\">[root@53bfee4c6557 local]# pwd</span><br><span class=\"line\">/usr/local</span><br><span class=\"line\">[root@53bfee4c6557 local]# vim</span><br><span class=\"line\"></span><br><span class=\"line\">[root@53bfee4c6557 local]# ifconfig</span><br><span class=\"line\">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 172.17.0.5  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class=\"line\">        ether 02:42:ac:11:00:05  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 8  bytes 656 (656.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@53bfee4c6557 local]# exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>列出本地进行的变更历史 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker history 692aba72d901</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545f262c458853aef77e132.jpg\" alt=\"docker history 692aba72d901\"></p>\n<ol start=\"6\">\n<li>CMD 和 ENTRYPOINT 区别 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">CMD            # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class=\"line\">ENTRYPOINT     # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p>测试 CMD</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1. 编写dockerfile文件</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# vim dockerfile-cmd-test</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# cat dockerfile-cmd-test</span><br><span class=\"line\">FROM centos:7</span><br><span class=\"line\">CMD [\"ls\",\"-a\"]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 构建镜像</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3. run运行，发现我们的<span class=\"string\">\"ls -a\"</span>命令生效、执行</span></span><br><span class=\"line\">docker run 06f2cc65ea4a</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run 06f2cc65ea4a </span><br></pre></td></tr></tbody></table></figure>\n<p>  <img data-src=\"https://pic.imgdb.cn/item/6545f420c458853aef7e35a4.jpg\" alt=\"docker run 06f2cc65ea4a \"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">4. 我们先追加一个命令<span class=\"string\">\"l\"</span>,构成<span class=\"string\">\"ls -al\"</span>命令，发现报错</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run ec0d2dd226b3 -l</span><br><span class=\"line\">docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"-l\": executable file not found in $PATH: unknown.</span><br><span class=\"line\">ERRO[0000] error waiting for container:</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原因：CMD命令的情况下，<span class=\"string\">\"-l\"</span>替换了CMD[<span class=\"string\">\"1s\"</span>，<span class=\"string\">\"-a\"</span>]命令，因为<span class=\"string\">\"-l\"</span>不是命令，所以报错！</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>测试 ENTRYPOINT</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1. 编写dockerfile文件</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# vim dockerfile-entrypoint-test</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# cat dockerfile-entrypoint-test</span><br><span class=\"line\">FROM centos:7</span><br><span class=\"line\">ENTRYPOINT [\"ls\",\"-a\"]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 构建镜像</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypointtest .</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3. run运行，发现我们的<span class=\"string\">\"ls -a\"</span>命令生效、执行</span></span><br><span class=\"line\">docker run 5184c7d459a0</span><br></pre></td></tr></tbody></table></figure>\n<p><img data-src=\"https://pic.imgdb.cn/item/6545fc1bc458853aef99f91e.jpg\" alt=\"docker run 5184c7d459a0\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run 5184c7d459a0 -l</span><br></pre></td></tr></tbody></table></figure>\n<p><img data-src=\"https://pic.imgdb.cn/item/6545fb94c458853aef982c74.jpg\" alt=\"docker run 5184c7d459a0 -l\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原因：ENTRYPOINT命令的情况下，<span class=\"string\">\"-l\"</span>追加在ENTRYPOINT [<span class=\"string\">\"1s\"</span>，<span class=\"string\">\"-a\"</span>]命令后面，得到<span class=\"string\">\"ls -al\"</span>的命令，所以命令正常执行！</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">（我们的追加命令，是直接拼接在我们的ENTRYPOINT命令的后面）</span></span><br></pre></td></tr></tbody></table></figure></li>\n</ul>\n","categories":["linux","docker"],"tags":["前端","linux","docker"]},{"title":"linux 配置缩写快捷操作","url":"//linux/config/git-config.html","content":"<p>编辑～/.zshrc 增加自定义配置</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">alias gps=\"git push origin\"</span><br><span class=\"line\">alias gcm=\"git add . &amp;&amp; git commit -m \"</span><br><span class=\"line\">alias gpl=\"git pull origin\"</span><br><span class=\"line\">alias gco=\"git checkout\"</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","git"],"tags":["前端","Git","linux"]},{"title":"Git 使用","url":"//linux/config/git.html","content":"<p>Git 是一个分布式版本控制系统，用于跟踪文件的变化并协作开发。以下是使用 Git 的基本步骤：</p>\n<ol>\n<li><p>安装 Git：首先，你需要在本地计算机上安装 Git。你可以从 Git 官方网站（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS8lRUYlQkMlODklRTQlQjglOEIlRTglQkQlQkQlRTUlQjklQjYlRTYlOEMlODklRTclODUlQTclRTUlQUUlODklRTglQTMlODUlRTYlOEMlODclRTUlOEQlOTclRTglQkYlOUIlRTglQTElOEMlRTUlQUUlODklRTglQTMlODUlRTMlODAlODI=\">https://git-scm.com/）下载并按照安装指南进行安装。<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p>创建一个 Git 仓库：进入你的项目文件夹，并使用以下命令初始化一个新的 Git 仓库：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>添加文件到暂存区：将需要进行版本控制的文件添加到 Git 的暂存区，使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add &lt;文件名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>提交文件：将暂存区的文件提交到 Git 仓库，使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git commit -m \"提交说明\"</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>分支管理：</li>\n</ol>\n<p>Git 使用分支来管理不同的版本和功能。可以使用以下命令创建、切换、合并、暂存、还原暂存分支：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git branch          &lt;分支名&gt;        # 创建新分支</span><br><span class=\"line\">git checkout        &lt;分支名&gt;        # 切换到分支</span><br><span class=\"line\">git checkout -b     &lt;分支名&gt;        # 基于当前分支创建分支</span><br><span class=\"line\">git merge           &lt;分支名&gt;        # 合并分支</span><br><span class=\"line\">git branch                         # 查看分支列表</span><br><span class=\"line\">git stash    save   ''             # 暂存分支</span><br><span class=\"line\">git stash    pop                   # 恢复暂存：</span><br><span class=\"line\">                                   # 恢复暂存的修改 这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"6\">\n<li>远程仓库：Git 还提供了远程仓库的功能，可以将本地仓库与远程仓库进行同步和协作。常用的远程仓库服务有 GitHub、GitLab 和 Bitbucket。可以使用以下命令与远程仓库进行交互：</li>\n</ol>\n<ul>\n<li>添加远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>将本地分支推送到远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git push -u origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>将本地代码强制推送到远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git push -f || -force origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>从远程仓库拉取最新代码：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git pull origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这些是 Git 的基本用法，还有更多高级的用法和命令可以根据实际需要进行学习和掌握。你可以参考 Git 的官方文档或查找其他教程来深入了解 Git 的更多功能和用法。</p>\n<ol start=\"7\">\n<li>回退版本</li>\n</ol>\n<p>git reset 命令用于回退版本，可以指定退回某一次提交的版本。git reset 命令语法格式如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>–mixed</li>\n</ul>\n<p>为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交 (commit) 保持一致，工作区文件内容保持不变。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset HEAD^                  # 回退所有内容到上一个版本</span><br><span class=\"line\">git reset HEAD^ git_use.md       # 回退文件的版本到上一个版本</span><br><span class=\"line\">git reset 0123adsfe3             # 回退到指定版本</span><br></pre></td></tr></tbody></table></figure>\n\n\n<ul>\n<li>–hard</li>\n</ul>\n<p>参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD             # 回退所有内容到上一个版本</span><br><span class=\"line\">git reset --hard HEAD~3           # 回退上上上一个版本</span><br><span class=\"line\">git reset –hard bae128            # 回退到某个版本回退点之前的所有信息</span><br><span class=\"line\">git reset --hard origin/master    # 将本地的状态回退到和远程的一样</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"8\">\n<li>删除本地和远程分支 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git branch  -d         &lt;分支名&gt;    # 删除本地</span><br><span class=\"line\">git push    origin -d  &lt;分支名&gt;    # 删除远程分支</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"9\">\n<li>配置全局用户信息 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name   \"batype\"</span><br><span class=\"line\">git config --global user.email  1175715363@qq.com</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"10\">\n<li>避免每次推送都输入密码 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"11\">\n<li>当前 Git 仓库关联的远程仓库的 URL 配置 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git remote add     origin &lt;url&gt; # 添加 origin 地址</span><br><span class=\"line\">git remote set-url origin &lt;url&gt; # 更新 origin 地址</span><br><span class=\"line\">git remote get-url origin       # 获取 origin 地址</span><br><span class=\"line\">git remote remove  origin       # 移除 origin 地址</span><br></pre></td></tr></tbody></table></figure>\n\n","categories":["linux","git"],"tags":["前端","Git","linux"]},{"title":"ubantu 安装 Maven 和 jdk 步骤","url":"//linux/install/maven/jdk.html","content":"<p>To install Maven and JDK (Java Development Kit) on Ubuntu, you can follow these steps:</p>\n<p>Open a terminal on your Ubuntu system.</p>\n<p>Update the package lists by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></tbody></table></figure>\n\n<p>Install Maven by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install maven</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will install Maven and its dependencies.</p>\n<p>Verify the installation by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mvn --version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This should display the version of Maven installed on your system.</p>\n<p>Install JDK (Java Development Kit) using the following steps:</p>\n<p>a. Check if Java is already installed on your system by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum list installed | grep java</span><br><span class=\"line\">或者</span><br><span class=\"line\">java -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>If Java is not installed, you will see an error message.</p>\n<p>b. select yum list package version</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum search java | grep -i --color jdk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>c. Install the default JDK package by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum install java-1.8.0-openjdk.x86_64</span><br><span class=\"line\">or</span><br><span class=\"line\">sudo apt install default-jdk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will install the default JDK package available in the Ubuntu package repository.</p>\n<p>d. Verify the installation by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">javac -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This should display the version of the JDK installed on your system.</p>\n<p>Additionally, you can also run the following command to check the Java Runtime Environment (JRE) version:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will display the JRE version.</p>\n<p>e. jdk checkout version link</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java 1</span><br><span class=\"line\">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/javac 1</span><br></pre></td></tr></tbody></table></figure>\n\n<p>f. use shell checkout version</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --config java</span><br><span class=\"line\">有 3 个候选项可用于替换 java (提供 /usr/bin/java)。</span><br><span class=\"line\"></span><br><span class=\"line\">选择       路径                                          优先级  状态</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">* 0            /usr/lib/jvm/java-17-openjdk-amd64/bin/java      1711      自动模式</span><br><span class=\"line\">1            /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java   1         手动模式</span><br><span class=\"line\">2            /usr/lib/jvm/java-17-openjdk-amd64/bin/java      1711      手动模式</span><br><span class=\"line\">3            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      手动模式</span><br><span class=\"line\"></span><br><span class=\"line\">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1</span><br></pre></td></tr></tbody></table></figure>\n\n\n<p>That’s it! You have now installed Maven and JDK on your Ubuntu system. You can use Maven for building projects and the JDK for developing and running Java applications.</p>\n","categories":["linux","maven"],"tags":["前端","linux","maven","jdk"]},{"title":"MySQL linux install","url":"//linux/install/MySQL.html","content":"<p>在线下载 mysql 安装包</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">wget https://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 MySQL 服务器</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>报错 失败的软件包是： mysql-community-libs-compat-5.7.37-1.el7.x86_64<br>GPG 密钥配置为： file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql<br>解决办法：原因是 Mysql 的 GPG 升级了，需要重新获取<br>使用以下命令即可</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></tbody></table></figure>\n\n<p>重新执行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装完毕<br>启动 Mysql 服务</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl start  mysqld.service</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改 mysql 的密码<br>查看 MySQL 临时密码</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grep \"password\" /var/log/mysqld.log</span><br></pre></td></tr></tbody></table></figure>\n\n\n<p>使用临时密码先登录</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意：密码设置必须要大小写字母数字和特殊符号（,/‘;: 等）, 不然不能配置成功<br>查看 mysql 默认密码复杂度</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">SHOW VARIABLES LIKE 'validate_password%';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>把 MySQL 的密码校验强度改为低风险</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">set global validate_password_policy=LOW;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改 MySQL 的密码长度</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">set global validate_password_length=4;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改密码为 root</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>开启 mysql 远程访问</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>1、使用 grant 命令</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grant all privileges on 数据库名.表名 to 创建的用户名(root)@\"%\" identified by \"密码\";</span><br></pre></td></tr></tbody></table></figure>\n\n<p>2、格式说明：<br>数据库名。表名 如果写成 *.* 代表授权所有的数据库<br>@ 后面是访问 mysql 的客户端 IP 地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该 mysql 数据库了）</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">flush privileges; //刷新权限</span><br></pre></td></tr></tbody></table></figure>\n\n<p>退出 mysql</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">exit;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>为 firewalld 添加开放端口</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent  //开放端口</span><br><span class=\"line\">firewall-cmd --reload  //重新加载防火墙</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其他配置<br>关闭 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>重启 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>查看 MySQL 运行状态</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl status mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>设置开机启动</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl enable mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>关闭开机启动</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl disable mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>配置默认编码为 utf8</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\">在[mysqld]中加入 character_set_server=utf8 </span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>区分大小写</p>\n<p>/etc/my.cof</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">lower_case_table_names=1</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其他默认配置文件路径：<br>配置文件： /etc/my.cnf<br>日志文件： /var/log/mysqld.log<br>服务启动脚本： /usr/lib/systemd/system/mysqld.service</p>\n","categories":["linux","mysql"],"tags":["linux","mysql"]},{"title":"CentOS 上安装 Nginx","url":"//linux/install/nginx.html","content":"<p>要在 CentOS 上安装 Nginx，您可以按照以下步骤进行操作：</p>\n<p>打开终端或 SSH 连接到 CentOS 服务器。</p>\n<p>确保您的系统已经更新到最新版本。运行以下命令更新软件包：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum update</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 Nginx。运行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>启动 Nginx 服务：</p>\n<p>使用以下命令启动 Nginx 服务：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>检查 Nginx 状态：</p>\n<p>使用以下命令检查 Nginx 服务的状态：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl status nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果 Nginx 正在运行，您将看到”active (running)” 状态。</p>\n<p>添加到开机启动项：</p>\n<p>要使 Nginx 在系统启动时自动启动，可以使用以下命令将其添加到开机启动项：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在，Nginx 将在系统启动时自动启动。您可以通过重新启动服务器并检查 Nginx 状态来验证设置是否成功。请注意，上述命令假定您具有适当的权限（如 sudo）来执行这些操作。</p>\n","categories":["linux","nginx"],"tags":["linux","nginx"]},{"title":"Scp 复制文件到服务器","url":"//linux/use/scp.html","content":"<h4 id=\"复制文件夹到服务器\"><a href=\"#复制文件夹到服务器\" class=\"headerlink\" title=\"复制文件夹到服务器\"></a>复制文件夹到服务器</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">scp -r key root@4*.1*8.1*0.70:/etc/nginx/conf.d/cert</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","scp"],"tags":["linux","scp"]},{"title":"腾讯云服务器开发端口","url":"//linux/port/open.html","content":"<ol>\n<li><p>了解端口<br>在开始之前，我们需要了解一下端口。端口是计算机网络中的一个概念，它是用于标识应用程序的逻辑地址。在互联网中，每个应用程序都需要使用一个端口来进行通信。常见的端口有 HTTP 端口（80）、FTP 端口（21）、SSH 端口（22）等等。</p>\n</li>\n<li><p>登录腾讯云服务器<br>首先，我们需要登录到腾讯云服务器。可以使用 SSH 工具，如 PuTTY 或 Xshell，连接到服务器。在连接成功后，输入用户名和密码即可登录到服务器。</p>\n</li>\n<li><p>开放端口<br>要开放端口，我们需要使用防火墙规则。腾讯云服务器默认使用的是 iptables 防火墙。我们可以使用以下命令来开放端口：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，端口号是需要开放的端口号。例如，如果要开放 SSH 端口（22），则可以使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>保存规则<br>开放端口后，我们需要保存规则，以便在服务器重启后仍然有效。可以使用以下命令来保存规则：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">service iptables save</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>查看规则<br>如果想要查看当前的防火墙规则，可以使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -L</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将列出当前的防火墙规则，包括已开放的端口。</p>\n<p>总结<br>开放端口是使用腾讯云服务器的一个基本操作。通过了解端口、登录服务器、开放端口、保存规则和查看规则，我们可以轻松地开放需要的端口，以便应用程序可以正常运行。</p>\n","categories":["linux"],"tags":["linux"]},{"title":"Ubuntu 解压 Zip 文件命令详解","url":"//linux/use/zip.html","content":"<h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>Ubuntu 解压 Zip 文件的命令是 “unzip”，它可以解压几乎所有的 Zip 文件。其基本的语法为：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip [option] filename.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，filename.zip 表示要解压的 Zip 文件名，option 参数是可选的，用来控制解压的行为，常用的 option 参数如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">-d：指定解压到的目录，例如：unzip -d /home/user/untitled filename.zip，即将filename.zip解压到/home/user/untitled目录；</span><br><span class=\"line\">-q：不显示详细信息，即不显示每个文件的解压进度信息；</span><br><span class=\"line\">-o：覆盖目标文件，即如果目标文件存在就覆盖它；</span><br><span class=\"line\">-P：指定Zip文件的密码。</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解压Zip文件到当前路径\"><a href=\"#解压Zip文件到当前路径\" class=\"headerlink\" title=\"解压Zip文件到当前路径\"></a>解压 Zip 文件到当前路径</h3><p>解压一个 Zip 文件到当前路径很简单，只要在终端中输入 “unzip filename.zip” 即可。比如：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到当前路径中。如果你希望将 Zip 文件解压到另外一个路径，可以使用 “-d” 参数，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip -d /home/user/some_folder</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到 “/home/user/some_folder” 路径中。</p>\n<h3 id=\"解压指定的文件\"><a href=\"#解压指定的文件\" class=\"headerlink\" title=\"解压指定的文件\"></a>解压指定的文件</h3><p>有时候我们只需要解压 Zip 文件中的某些文件，而不是全部文件，这时候可以使用 “unzip -j” 命令。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -j archive.zip file.txt</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件中的 “file.txt” 文件解压到当前路径中。</p>\n<h3 id=\"解压时覆盖已存在的文件\"><a href=\"#解压时覆盖已存在的文件\" class=\"headerlink\" title=\"解压时覆盖已存在的文件\"></a>解压时覆盖已存在的文件</h3><p>默认情况下，如果解压的目标文件已经存在，unzip 命令会提示是否覆盖。如果你希望不进行提示，强制覆盖已经存在的文件，可以使用 “-o” 参数。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -o archive.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会解压 “archive.zip” 文件到当前路径中，如果有重名的文件会强制覆盖。</p>\n<h3 id=\"解压时保留目录结构\"><a href=\"#解压时保留目录结构\" class=\"headerlink\" title=\"解压时保留目录结构\"></a>解压时保留目录结构</h3><p>默认情况下，unzip 命令会将 Zip 文件中的所有文件解压到当前路径中，不管其原来所在的目录结构。如果你希望保留原来的目录结构，可以使用 “unzip -j” 命令，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip -d /home/user/some_folder</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到 “/home/user/some_folder” 路径中，并保留原来的目录结构。</p>\n<h3 id=\"解压时指定密码\"><a href=\"#解压时指定密码\" class=\"headerlink\" title=\"解压时指定密码\"></a>解压时指定密码</h3><p>如果 Zip 文件设置了密码，那么我们需要在解压时指定密码。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -P secretPassword archive.zip</span><br></pre></td></tr></tbody></table></figure>\n<p>上述命令将会解压 “archive.zip” 文件，并使用 “secretPassword” 作为密码。</p>\n","categories":["linux","zip"],"tags":["linux","zip"]},{"title":"vscode . open project","url":"//linux/use/vscode/open/project.html","content":"<p>You are trying to start Visual Studio Code as a super user which isn’t recommended. If this was i…</p>\n<p>在 centos7 中通过 wget 安装 vscode (tar.gz 格式) 后，执行 /bin/code 出现提示：</p>\n<p>You are trying to start Visual Studio Code as a super user which isn’t recommended. If this was intended, please add the argument –no-sandbox and specify an alternate user data directory using the –user-data-dir argument.<br>您正试图以超级用户身份启动 Visual Studio 代码，这是不推荐的。如果是这样，请添加参数 “–no sandbox”，并使用 “–user data dir” 参数指定备用用户数据目录。</p>\n<p>解决方法：<br>方法一：修改～/.bashrc</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">vi ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n\n<p>添加一行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">whereis code </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">code: /usr/bin/code /usr/share/code</span></span><br><span class=\"line\">alias code='/usr/share/code/code . --no-sandbox --unity-launch'</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","vscode"],"tags":["linux","vscode"]},{"title":"zsh install","url":"//linux/install/zsh.html","content":"<p>Manual Installation</p>\n<h3 id=\"Clone-The-Repository\"><a href=\"#Clone-The-Repository\" class=\"headerlink\" title=\"Clone The Repository\"></a>Clone The Repository</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git clone https://githubfast.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Optionally-Backup-Your-Existing-zshrc-File\"><a href=\"#Optionally-Backup-Your-Existing-zshrc-File\" class=\"headerlink\" title=\"Optionally, Backup Your Existing ~/.zshrc File\"></a>Optionally, Backup Your Existing ~/.zshrc File</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cp ~/.zshrc ~/.zshrc.orig</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Create-A-New-Zsh-Configuration-File\"><a href=\"#Create-A-New-Zsh-Configuration-File\" class=\"headerlink\" title=\"Create A New Zsh Configuration File\"></a>Create A New Zsh Configuration File</h3><p>You can create a new zsh config file by copying the template that we have included for you.</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Change-Your-Default-Shell\"><a href=\"#Change-Your-Default-Shell\" class=\"headerlink\" title=\"Change Your Default Shell\"></a>Change Your Default Shell</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">which zsh</span><br><span class=\"line\">chsh -s $(which zsh)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>You must log out from your user session and log back in to see this change.</p>\n","categories":["linux","zsh"],"tags":["linux","zsh"]},{"title":"async/await 的理解","url":"//javascript/async/await.html","content":"<h2 id=\"async-await-的理解\"><a href=\"#async-await-的理解\" class=\"headerlink\" title=\"async/await 的理解\"></a>async/await 的理解</h2><p>async/await 其实是 Generator 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是 “异步” 的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world;\"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\"><span class=\"title class_\">Promise</span> {&lt;fulfilled&gt;: <span class=\"string\">'hello world;'</span>}</span><br><span class=\"line\">[[<span class=\"title class_\">Prototype</span>]]: <span class=\"title class_\">Promise</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseState</span>]]: <span class=\"string\">\"fulfilled\"</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseResult</span>]]: <span class=\"string\">\"hello world;\"</span></span><br></pre></td></tr></tbody></table></figure>\n<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve () 封装成 Promise 对象。async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then () 链来处理这个 Promise 对象，就像这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world;\"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">result.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// hello world;</span></span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>那如果 async 函数没有返回值，又该如何？很容易想到，他会返回</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>联想一下 Promise 的特点 —— 无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<pre><code> 注意：Promise.resolve(x) 可以看作是new Promise(resolve=&gt;resolve(x)) 的简写\n 可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n</code></pre>\n<h2 id=\"async-await-的优势\"><a href=\"#async-await-的优势\" class=\"headerlink\" title=\"async/await 的优势\"></a>async/await 的优势</h2><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">takeLongTime</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> {</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(n + <span class=\"number\">200</span>), n)</span><br><span class=\"line\">\t})</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step1</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step1 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step2</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step2 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step3</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step3 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>现在用 Promise 方式来实现这三个步骤的处理：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"title function_\">step1</span>(time1)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> <span class=\"title function_\">step2</span>(time2))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> <span class=\"title function_\">step3</span>(time3))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">${result}</span>`</span>);</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t\t});\t</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>652s</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>输出结果 result 是 step3 () 的参数 700 + 200 = 900。doIt () 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time ()/console.timeEnd () 计算的结果一致。如果用 async/await 来实现呢，会是这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> <span class=\"title function_\">step1</span>(time1);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> <span class=\"title function_\">step2</span>(time2);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title function_\">step3</span>(time3);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">${result}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>515s</span><br></pre></td></tr></tbody></table></figure>\n\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h2 id=\"async-await-对比-Promise-的优势\"><a href=\"#async-await-对比-Promise-的优势\" class=\"headerlink\" title=\"async/await 对比 Promise 的优势\"></a>async/await 对比 Promise 的优势</h2><p>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</p>\n<p>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</p>\n<p>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</p>\n<p>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进 (step-over) 功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"Optional chaining 语法编程","url":"//javascript/optional/chaining.html","content":"<h3 id=\"什么是-Optional-Chaining？\"><a href=\"#什么是-Optional-Chaining？\" class=\"headerlink\" title=\"什么是 Optional Chaining？\"></a>什么是 Optional Chaining？</h3><p>Optional chaining 是一个现代 JavaScript 语法特性，允许开发者在读取对象内部嵌套属性时安全地处理 <code>undefined</code> 或 <code>null</code> 值。这种语法通过 <code>?.</code> 操作符实现，可以避免在查询属性或调用方法时因为中间某个环节不存在而引发错误。</p>\n<h3 id=\"Optional-chaining-的基本使用示例如下\"><a href=\"#Optional-chaining-的基本使用示例如下\" class=\"headerlink\" title=\"Optional chaining 的基本使用示例如下\"></a>Optional chaining 的基本使用示例如下</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: {</span><br><span class=\"line\">        <span class=\"attr\">b</span>: {</span><br><span class=\"line\">            <span class=\"attr\">c</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// 传统的深层属性访问可能会抛出错误，如果某个属性不存在</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = obj &amp;&amp; obj.<span class=\"property\">a</span> &amp;&amp; obj.<span class=\"property\">a</span>.<span class=\"property\">b</span> &amp;&amp; obj.<span class=\"property\">a</span>.<span class=\"property\">b</span>.<span class=\"property\">c</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用 optional chaining 语法，安全地读取嵌套属性</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> valueWithOptionalChaining = obj?.<span class=\"property\">a</span>?.<span class=\"property\">b</span>?.<span class=\"property\">c</span>; <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"comment\">// 如果中间某个属性不存在，表达式会返回 undefined，而不是抛出错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undefinedValue = obj?.<span class=\"property\">a</span>?.<span class=\"property\">nonExistingProp</span>?.<span class=\"property\">c</span>; <span class=\"comment\">// 输出 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Optional-chaining-可以用于四种不同的操作\"><a href=\"#Optional-chaining-可以用于四种不同的操作\" class=\"headerlink\" title=\"Optional chaining 可以用于四种不同的操作\"></a>Optional chaining 可以用于四种不同的操作</h3><ol>\n<li>对象属性访问</li>\n</ol>\n<p>如上例所示，可以安全地访问嵌套对象属性。</p>\n<ol start=\"2\">\n<li>数组索引访问</li>\n</ol>\n<p>可以安全地访问数组的索引，如果数组是 undefined 或 null，则不会报错。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> valueAtIndex = arr?.[<span class=\"number\">2</span>]; <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> nonExistingIndex = arr?.[<span class=\"number\">5</span>]; <span class=\"comment\">// 输出 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>函数或方法调用</li>\n</ol>\n<p>如果不确定一个对象上的函数是否存在，可以使用 optional chaining 安全地调用函数或方法。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"attr\">a</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Function exists'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">a</span>?.(); <span class=\"comment\">// 输出 'Function exists'</span></span><br><span class=\"line\">obj.<span class=\"property\">b</span>?.(); <span class=\"comment\">// 由于 b 不存在，不执行任何操作，返回 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>默认值中使用 </li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = {};</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = user?.<span class=\"property\">name</span> ?? <span class=\"string\">\"匿名用户\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>要注意的是，optional chaining 语法是 ECMAScript 2020（ES11）的一部分，因此在老旧的 JavaScript 环境中可能不受支持。对于这些环境，可以使用 Babel 这样的工具来转译代码，使其兼容。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"事件循环（Event Loop）","url":"//javascript/eventloop.html","content":"<p>事件循环（Event Loop）是计算机程序中的一个设计模式，用于处理异步操作，特别是在图形用户界面程序和服务器端应用程序中。事件循环模式通过等待并分派事件或回调函数来驱动程序的执行流程，而不是通过直接执行代码的方式。</p>\n<p>在编程领域，事件循环通常余非阻塞 I/O 和异步编程模型结合使用。这种模式允许程序在等待一个长时间操作（如网络请求或磁盘 I/O）完成时继续处理其他任务。一旦长时间操作完成，相关的回调函数就会被放入事件循环中等待执行。</p>\n<p>事件循环的基本工作原理如下：</p>\n<ol>\n<li>事件循环开始时，它首先检查是否有任何事件或回调函数需要执行。</li>\n<li>如果没有事件或回调函数需要执行，事件循环将进入休眠状态，等待新事件或回调函数的到来。</li>\n<li>当有事件或回调函数需要执行时，事件循环从等待队列中取出事件或回调函数，并将其放入执行队列中。</li>\n<li>事件循环从执行队列中取出事件或回调函数，并执行它们。</li>\n<li>执行完成后，事件循环将事件或回调函数从执行队列中移除，并继续等待新的事件或回调函数。</li>\n</ol>\n<p>在 JavaScript 中，事件循环通常由 JavaScript 引擎和宿主环境（如浏览器或 Node.js）共同实现。JavaScript 引擎负责执行代码，而宿主环境负责管理事件和回调函数。</p>\n<p>如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">4</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行过程：</p>\n<ol>\n<li>现将 <code>console.log('1');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>setTimeout(() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }, 0);</code> 放入宏任务队列中。</li>\n<li>将 <code>console.log('4');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code> 放入微任务队列中；</li>\n<li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code>；</li>\n<li>将 <code>console.log('2');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>setTimeout(() =&gt; { console.log('3'); }, 0);</code> 放入宏任务队列中；</li>\n<li>将 <code>() =&gt; { console.log('3'); }</code> 放入微任务队列中；</li>\n<li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('3'); }</code>；</li>\n<li>将 <code>console.log('3');</code> 放入执行队列中，并立即执行。</li>\n</ol>\n<p>微任务（Microtask）和宏任务（Macrotask）是 JavaScript 中事件循环机制的两个重要概念，它们决定了异步代码的执行时机和顺序。以下是微任务和宏任务的主要区别以及它们各自包含的任务类型：</p>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ol>\n<li><p><strong>定义</strong>：<br>微任务是一类非常小的任务，它们通常与当前执行栈中的代码有关，并且总是在当前执行栈清空后立即执行。</p>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>微任务具有高优先级，它们总是在宏任务之前执行。</li>\n<li>微任务可以快速响应状态的变化，因为它们在每次事件循环迭代的末尾执行。</li>\n<li>微任务的执行不会阻塞后续代码的执行。</li>\n</ul>\n</li>\n<li><p><strong>包含的任务类型</strong>：</p>\n<ul>\n<li><code>Promise</code> 的<code>.then()</code> 回调函数。</li>\n<li><code>MutationObserver</code> 的回调函数。</li>\n<li>手动添加的微任务，例如使用 <code>queueMicrotask()</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ol>\n<li><p><strong>定义</strong>：<br>宏任务是一类较大的任务，它们通常与用户交互或 I/O 操作有关，并且总是在微任务执行完毕后执行。</p>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>宏任务具有较低的优先级，它们总是在微任务之后执行。</li>\n<li>宏任务的执行可能会阻塞后续代码的执行，因为它们通常涉及到等待外部事件或资源。</li>\n<li>宏任务的执行次数通常比微任务多，因为每次事件循环迭代可能包含多个宏任务。</li>\n</ul>\n</li>\n<li><p><strong>包含的任务类型</strong>：</p>\n<ul>\n<li><code>setTimeout</code> 和 <code>setInterval</code> 的回调函数。</li>\n<li><code>requestAnimationFrame</code> 的回调函数。</li>\n<li><code>setImmediate</code>（在 Node.js 中可用）的回调函数。</li>\n<li>浏览器事件，如点击、滚动、键盘输入等。</li>\n<li>网络请求、文件读写等 I/O 操作完成后的回调函数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"事件循环中的执行顺序\"><a href=\"#事件循环中的执行顺序\" class=\"headerlink\" title=\"事件循环中的执行顺序\"></a>事件循环中的执行顺序</h3><p>在 JavaScript 的事件循环中，微任务和宏任务按照以下顺序执行：</p>\n<ol>\n<li>执行当前执行栈中的所有同步代码。</li>\n<li>清空当前执行栈。</li>\n<li>执行所有微任务队列中的微任务。</li>\n<li>执行所有宏任务队列中的宏任务。</li>\n<li>重复步骤 1-4，直到微任务和宏任务队列都为空。</li>\n</ol>\n<p>这种机制确保了 JavaScript 能够以非阻塞的方式处理异步事件，同时保证了高优先级任务（如用户交互和状态变化）能够及时响应。开发者可以利用微任务和宏任务的特性来优化代码性能和用户体验。</p>\n<p>下面实例代码包括微任务和宏任务：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3. 宏任务执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> timeoutId = <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">    <span class=\"comment\">// 4. 微任务执行</span></span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeoutId);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3. 宏任务执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(</span><br><span class=\"line\">    <span class=\"comment\">// 4. 微任务执行</span></span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'5'</span>);</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"comment\">// 2. 微任务执行</span></span><br><span class=\"line\"><span class=\"title function_\">promise</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></tbody></table></figure>\n\n<p>大家猜一下下面<strong>实例 3</strong> 的结果：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> timeoutId = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeoutId);</span><br><span class=\"line\">    (<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'8'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'9'</span>);</span><br><span class=\"line\">}, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'5'</span>);</span><br><span class=\"line\">    (<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'10'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">    (<span class=\"function\">()=&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'7'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br></pre></td></tr></tbody></table></figure>","categories":["前端","javascript"],"tags":["前端","浏览器","Event Loop"]},{"title":"编写 Promise 方法","url":"//javascript/promise.html","content":"<h5 id=\"Promise-是什么？\"><a href=\"#Promise-是什么？\" class=\"headerlink\" title=\"Promise 是什么？\"></a>Promise 是什么？</h5><p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步 操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调， 它比传统的解决方案回调函数和事件更合理和更强大。</p>\n<span id=\"more\"></span>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束 的事件 (通常是一个异步操作) 的结果。从语法上说，Promise 是一 个对象，从它可以获取异步操作的消息。Promise 提供统一的 API， 各种异步操作都可以用同样的方法进行处理。</p>\n<ol>\n<li>Promise 的实例有三个状态:</li>\n</ol>\n<ul>\n<li><p>Pending (进行中)</p>\n</li>\n<li><p>Resolved (已完成)</p>\n</li>\n<li><p>Rejected (已拒绝)</p>\n</li>\n</ul>\n<p>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了 状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</p>\n<ol start=\"2\">\n<li><p>Promise 的实例有两个过程:<br> pending -&gt; fulfilled: Resolved (已完成)<br> pending -&gt; rejected: Rejected (已拒绝)</p>\n<p> 注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>\n</li>\n</ol>\n<h5 id=\"Promise-的特点\"><a href=\"#Promise-的特点\" class=\"headerlink\" title=\"Promise 的特点\"></a>Promise 的特点</h5><p>对象的状态不受外界影响。promise 对象代表一个异步操作，有三种 状态，pending (进行中)、fulfilled (已成功)、rejected (已失 败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他 操作都无法改变这个状态，这也是 promise 这个名字的由来 ——“承 诺”;</p>\n<p>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled，从 pending 变为 rejected。这时就称为 resolved (已定型)。如果改 变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这 个结果。这与事件 (event) 完全不同，事件的特点是：如果你错过 了它，再去监听是得不到结果的。</p>\n<h5 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h5><p>Promise 实现是通过 js class 编写，主要包括 status、value、error、resolve、reject、then、catch、all、race、allSettled、any 等组成。</p>\n<ol>\n<li>状态 </li>\n</ol>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">\"pending\"</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">\"fulfilled\"</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">\"rejected\"</span>; <span class=\"comment\">// 已拒绝</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>resolve 创建一个已解决的 Promise 对象，将给定的值作为其参数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>reject 创建一个已拒绝的 Promise 对象，将给定的原因作为其参数 </li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>then 添加对 Promise 对象解决或拒绝时的处理程序</li>\n</ol>\n<ul>\n<li>单个方法调用 </li>\n</ul>\n   <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> resolve = (<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_FULFILLED</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> { <span class=\"comment\">//queueMicrotask:  主线程执行完毕之后立马执行</span></span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">resfn</span>(value)</span><br><span class=\"line\">      })</span><br><span class=\"line\">    }</span><br><span class=\"line\">  })</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> reject = (<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_REJECTED</span></span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">errfn</span>(error)</span><br><span class=\"line\">      })</span><br><span class=\"line\">    }</span><br><span class=\"line\">  })</span><br><span class=\"line\">   <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span> = resFn;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span> = errFn;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>执行结果  <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>)</span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {        <span class=\"comment\">//最终打印 1111</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\"></span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure></li>\n<li>优化 then 方法</li>\n</ul>\n<p>官方给与的 then 方法是可以进行数组传值和链式调用的，而目前我们写的是不支持。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [] <span class=\"comment\">//1.多次调用then 时用数组 保存</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将then 方法修改为 </span></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resfns</span>.<span class=\"title function_\">push</span>(resFn);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(errFn);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolve修改为</span></span><br><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// reject 修改为</span></span><br><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<p>  优化后 then 的运行结果<br>  </p><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res1:\"</span>, res) </span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err1:\"</span>, err)</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res2:\"</span>, res)</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err2:\"</span>, err)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure><br>运行结果：res2: 111  因为后面的.then 把前面的覆盖掉了 并不会执行res1 所在的代码块<br>*由此可见 then 方法调用时应该是个数组然后依次调用<br>下面改造我们的代码then,还需要优化执行resolve 时调用reject<br>   <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br></pre></td></tr></tbody></table></figure><br>然后执行：<br>  <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>);</span><br><span class=\"line\">    <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>);</span><br><span class=\"line\">})</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res1:\"</span>, res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err1:\"</span>, err);</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res2:\"</span>, res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err2:\"</span>, err);</span><br><span class=\"line\">})</span><br><span class=\"line\">执行结果：</span><br><span class=\"line\"><span class=\"attr\">res1</span>: <span class=\"number\">111</span></span><br><span class=\"line\"><span class=\"attr\">res2</span>: <span class=\"number\">111</span></span><br></pre></td></tr></tbody></table></figure><p></p>\n<ol start=\"5\">\n<li><p>catch 添加对 Promise 对象拒绝时的处理程序</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(errFn) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>finally 添加对 Promise 对象解决或拒绝时的最终处理程序，无论 Promise 对象是否已被解决或拒绝。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>all 接收一个可迭代对象（如数组），并返回一个新的 Promise 对象。当所有 Promise 对象都已解决时，该 Promise 对象才将被解决，并返回一个包含所有解决值的数组。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类型判断当前数组中的方法或者对象是否为Promise 对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">any[]</span>} <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@desc</span> 实际上多个对象同步执行时，就相当于把所有的方法重新进行Promise一次。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当遍历到最后一个时，resolve 所有结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) {</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          })</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>all 运行示例</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"number\">88888</span>,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  });</span><br><span class=\"line\">})();</span><br><span class=\"line\">运行结果: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">123</span>,  <span class=\"number\">88888</span>]</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>race Promise.race (iterable) 传入多个对象，当任何一个执行完成后 resolve 结果</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) {</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>race 运行示例</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">race</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  });</span><br><span class=\"line\">})();</span><br><span class=\"line\">运行结果： <span class=\"number\">1</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>完整代码</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// status</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">\"pending\"</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">\"fulfilled\"</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">\"rejected\"</span>; <span class=\"comment\">// 已拒绝</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPromise</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [];</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">//    创建一个已解决的Promise对象，将给定的值作为其参数。</span></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个已拒绝的Promise对象，将给定的原因作为其参数。</span></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">  <span class=\"comment\">//   添加对Promise对象解决或拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(errFn) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象解决或拒绝时的最终处理程序，无论Promise对象是否已被解决或拒绝。</span></span><br><span class=\"line\">  <span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">any[]</span>} <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) {</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          })</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) {</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// const p1 = new MyPromise((resolve, reject) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(\"状态pending\");</span></span><br><span class=\"line\"><span class=\"comment\">//   resolve(\"22222\");</span></span><br><span class=\"line\"><span class=\"comment\">//   reject(\"3333333\");</span></span><br><span class=\"line\"><span class=\"comment\">// });</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// p1.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(\"res1:\", res);</span></span><br><span class=\"line\"><span class=\"comment\">//   return \"第二次的成功回调\";</span></span><br><span class=\"line\"><span class=\"comment\">// })</span></span><br><span class=\"line\"><span class=\"comment\">//   .catch((error) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(\"err1:\", error);</span></span><br><span class=\"line\"><span class=\"comment\">//     throw new Error(\"第二次的失败回调\");</span></span><br><span class=\"line\"><span class=\"comment\">//   })</span></span><br><span class=\"line\"><span class=\"comment\">//   .finally(() =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(\"finally\");</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// (async function() {</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.all([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     () =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       return 123;</span></span><br><span class=\"line\"><span class=\"comment\">//     },</span></span><br><span class=\"line\"><span class=\"comment\">//     88888,</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// })();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (async function() {</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.race([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// })();</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"Promise-的缺点\"><a href=\"#Promise-的缺点\" class=\"headerlink\" title=\"Promise 的缺点\"></a>Promise 的缺点</h5><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p>\n<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>\n<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段 (刚刚开始 还是即将完成)。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h5><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变， 就凝固了，无法再被改变了。</p>\n<p>状态的改变是通过 resolve () 和 reject () 函数来实现的，可以在 异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原 型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的 改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的 末尾执行。</p>\n<p>注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"对原型、原型链的理解","url":"//javascript/prototype.html","content":"<p>在 JavaScript 中是使用构造两数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造西数的所有实例共享的属性和方法。<br>当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造两数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在 浏览器中都实现了_proto_ 属性来访问这个属性，但是最好不要 使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf () 方法，可以通过这个方法米获取对象的原型。 </p>\n<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象义会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 0bject.prototype 所以这就是新建的对象为什么能够使用 toString () 等方法的原因。 </p>\n<p>特点：JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。<br><img data-src=\"https://pic.imgdb.cn/item/65366accc458853aefbfcd92.jpg\" alt=\"原型链图解\"><br>那么原型链的终点是什么？如何打印出原型链的终点？</p>\n<p>由于 Object 是构造函数，原型链终点 Ob ject.prototype._proto_，而 Object.prototype.<em>proto</em> === null //true，所以，原型链的终点是 null。原型链上的所有原型都是对象，所有的对象最终都是由 0bject 构造的，而 Object.prototype 的下一级是 Object. prototype._proto_。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653668e4c458853aefb94875.jpg\" alt=\"在这里插入图片描述\"></p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"var、let、const 的区别","url":"//javascript/var/let/const.html","content":"<h5 id=\"var-关键词\"><a href=\"#var-关键词\" class=\"headerlink\" title=\"var 关键词\"></a>var 关键词</h5><ol>\n<li>var 声明作用域<br>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">\"hello world\"</span>;   <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);  <span class=\"comment\">// 报错</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>函数 test () 调用时会创建变量 message 并给它赋值，调用之后变量随即被销毁。因此，在函数 test () 之外调用变量 message 会报错</p>\n<p>在函数内定义变量时省略 var 操作符，可以创建一个全局变量</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    message = <span class=\"string\">\"hello world\"</span>;   <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);  <span class=\"comment\">// hello world</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>省略掉 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test ()，就会定义这个变量，并且可以在函数外部访问到。在局部作用域中定义的全局变量很难维护，不推荐这么做。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。</p>\n<ol start=\"2\">\n<li>var 声明提升<br>var 在 js 中是支持预解析的，如下代码不会报错。这是因为使用 var 声明的变量会自动提升到函数作用域顶部：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>javaScript 引擎，在代码预编译时，javaScript 引擎会自动将所有代码里面的 var 关键字声明的语句都会提升到当前作用域的顶端，如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">    age = <span class=\"number\">26</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"let声明\"><a href=\"#let声明\" class=\"headerlink\" title=\"let声明\"></a>let 声明</h5><ol>\n<li>let 声明作用域<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，而 var 可以跨块访问 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// 26</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// ReferenceError: age没有定义</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>let 也不允许同一个块作用域中出现冗余声明（重复声明）</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age; <span class=\"comment\">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>暂时性死区<br>let、const 与 var 的另一个重要的区别，let、const 声明的变量不会在作用域中被提升。ES6 新增的 let、const 关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建出来，由于此时还未完成语法绑定，所以是不能被访问的，如果访问就会抛出错误 ReferenceError。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// name会被提升</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// age不会被提升</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// ReferenceError：age没有定义</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>全局声明<br>与 var 关键字不同，var 定义的全局变量会挂载到 window 对象上，使用 window 可以访问，而 let 在全局作用域中声明的变量不会成为 window 对象的属性 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">name</span>); <span class=\"comment\">// 'Matt'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>for 循环中的 var、let 声明<br>for 循环中 var 定义的迭代变量会渗透到循环体外部：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"comment\">// 循环逻辑</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"comment\">// 循环逻辑</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// ReferenceError: i没有定义</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>使用 var 和 let 定义 for 循环中的变量，循环里使用定时器 setTimeout 后循环结果如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i), <span class=\"number\">0</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 输出5、5、5、5、5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i), <span class=\"number\">0</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 输出0、1、2、3、4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>let 是在代码块内有效，var 是在全局范围内有效。let 只能声明一次 ，var 可以声明多次。</p>\n<p>当同步代码执行完毕后，开始执行异步的 setTimeout 代码，执行 setTimeout 时需要从当前作用域内寻找一个变量 i，for 循环执行完毕，当前 i=5，执行 setTimeout 时输出为 5，任务队列中的剩余 4 个 setTimeout 也依次执行，输出为 5。</p>\n<p>变量 j 是用 let 声明的，当前的 i 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 0-4。</p>\n<h5 id=\"const声明\"><a href=\"#const声明\" class=\"headerlink\" title=\"const声明\"></a>const 声明</h5><p>const 的行为与 let 基本相同，唯一一个重要的区别是：</p>\n<p>const 是用来定义常量的，而且定义的时候必须赋值，不赋值会报错，定义之后是不允许被修改的，修改 const 声明的变量会导致运行时错误。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">age = <span class=\"number\">36</span>; <span class=\"comment\">// TypeError: 给常量赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const也不允许重复声明</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Nicholas'</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const声明的作用域也是块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> name = <span class=\"string\">'Nicholas'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>而 const 声明的变量是一个对象时，修改这个对象内部的属性并不会报错。</p>\n<p>这是因为 const 声明的是栈区里的内容不能修改，基本数据类型的值直接在栈内存中存储，而引用数据类型在栈区保存的是对象在堆区的地址，修改对象的属性，不会修改对象在栈区的地址，如果重新给对象 person 赋值，则会报错。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'Lili'</span></span><br><span class=\"line\">};</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'Matt'</span>; <span class=\"comment\">// ok</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) {} <span class=\"comment\">// TypeError：给常量赋值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> j = <span class=\"number\">7</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 7, 7, 7, 7, 7</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> {<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>}) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// a, b</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"Fiber 架构的起源","url":"//react/fiber.html","content":"<h1 id=\"Fiber-架构的起源\"><a href=\"#Fiber-架构的起源\" class=\"headerlink\" title=\"Fiber 架构的起源\"></a>Fiber 架构的起源</h1><p>Fiber 架构的起源可以追溯到 React 团队在 2017 年提出的一项重大改进计划。在过去的 React 版本中，渲染过程是基于递归的，即组件树的遍历是通过递归函数来完成的。这种方式在大规模复杂应用中可能会引发一些性能问题，例如长时间的主线程阻塞，导致用户体验下降。</p>\n<span id=\"more\"></span>\n<p>为了解决这些性能问题，React 团队开始着手设计一种新的渲染架构，即 Fiber 架构。Fiber 架构的目标是使 React 的渲染过程可中断和恢复，从而实现更好的任务调度、优先级管理和增量更新。</p>\n<p>Fiber 这个名字来源于计算机科学中的 “Fiber”（纤程）概念，指的是一种轻量级的执行单元，可以在多个任务之间切换，并且可以中断和恢复执行。React 中的 Fiber 也是类似的概念，表示渲染过程中的任务单元，可以根据任务的优先级和时间片进行灵活的调度和中断。</p>\n<p>通过 Fiber 架构，React 实现了一个基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。同时，React 还引入了优先级调度算法，通过动态调整任务的优先级，可以根据不同任务的重要性和紧急程度来合理地分配渲染资源。</p>\n<p>Fiber 架构的引入使得 React 在渲染过程中可以更加灵活地响应用户交互，提供更好的用户体验。它为 React 提供了更强大的渲染能力，能够支持更复杂、更大规模的应用程序。</p>\n<p>值得一提的是，Fiber 架构的设计和实现是一个非常复杂的过程，并且在不同版本的 React 中可能会有一些细节上的差异。React 团队在不断地改进和优化 Fiber 架构，以进一步提升 React 应用的性能和可靠性。</p>\n<h1 id=\"Fiber的含义\"><a href=\"#Fiber的含义\" class=\"headerlink\" title=\"Fiber的含义\"></a>Fiber 的含义</h1><blockquote>\n<p>总的来说，Fiber 是 React 中的一种渲染架构和调度算法，通过将渲染过程划分为可中断和恢复的任务单元，实现了增量更新和优先级调度。Fiber 架构的引入使得 React 能够更加高效地处理渲染任务，提供更好的用户体验和更高的性能。</p>\n</blockquote>\n<p>Fiber 是 React 中的一个概念，它有多个含义和作用：</p>\n<ul>\n<li><p>渲染任务单元：在 React 中，Fiber 表示渲染过程中的任务单元。传统的递归渲染方式可能会导致长时间的主线程阻塞，影响用户体验。而 Fiber 架构将渲染过程划分为一系列小的任务单元（Fiber 节点），可以根据任务的优先级和时间片进行灵活的调度和中断，实现增量更新和任务的并发处理。</p>\n</li>\n<li><p>调度和优先级管理：Fiber 架构引入了一套调度算法，用于根据任务的优先级和时间片来动态调整任务的执行顺序。通过优先级调度，React 可以根据任务的重要性和紧急程度合理地分配渲染资源，从而提供更好的用户体验。优先级调度还使得 React 可以在不同任务之间进行中断和恢复，避免了长时间的阻塞。</p>\n</li>\n<li><p>组件结构表示：Fiber 架构引入了基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。每个 Fiber 节点表示一个组件或 DOM 元素，并通过 child、sibling 和 return 等属性建立起节点之间的关联。通过 Fiber 树的结构，React 可以更加高效地遍历和更新组件树，实现增量渲染。</p>\n</li>\n<li><p>增量更新：Fiber 架构支持增量更新，即仅更新发生变化的部分，而不需要重新渲染整个组件树。通过对比 Fiber 树的两个状态，React 可以确定哪些组件需要更新，并且可以跳过不需要更新的部分，从而提高渲染性能。</p>\n</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b551cc458853aef02aa5f.jpg\" alt=\"react 中一帧的过程\"></p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"Fiber 架构实现流程","url":"//react/fiber/implement.html","content":"<p>Fiber 架构是 React 中用于实现虚拟 DOM 的一种算法架构。它的目标是提高渲染性能和用户体验，通过将渲染工作分割成多个小任务，在不阻塞主线程的情况下逐步完成整个渲染过程。</p>\n<p>下面是 Fiber 架构的简要实现过程：</p>\n<ul>\n<li><p>构建 Fiber 树：在进行首次渲染时，React 会构建一棵 Fiber 树，用于表示组件的层级结构和渲染顺序。每个 Fiber 节点对应一个组件实例，其中包含组件的状态、属性和其他相关信息。</p>\n</li>\n<li><p>初始渲染阶段：React 通过递归遍历 Fiber 树，在每个 Fiber 节点上执行渲染操作，生成对应的虚拟 DOM 元素。</p>\n</li>\n<li><p>任务拆分：在渲染过程中，React 根据时间片（Time Slicing）的概念将渲染任务拆分为多个小任务（Fiber），每个小任务执行时间有限，并且可以中断和恢复。</p>\n</li>\n<li><p>优先级调度：React 使用优先级调度算法确定哪些任务具有更高的优先级，并按照顺序执行这些高优先级的任务，以保证用户界面的流畅度。</p>\n</li>\n<li><p>增量更新：在执行每个小任务时，React 会比较前后两次渲染结果，找出需要更新的部分，并对其进行增量更新。这样可以避免全量重新渲染，提高性能。</p>\n</li>\n<li><p>渲染结果提交：当所有小任务完成后，React 将最终渲染结果提交给浏览器进行绘制，完成整个渲染过程。</p>\n</li>\n</ul>\n<p>Fiber 架构的实现使得 React 能够在多任务之间动态地切换，并根据任务的优先级和时间片进行灵活的调度。这样可以更好地响应用户的交互，提供更流畅的用户体验。</p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"Fiber 架构工作原理","url":"//react/fiber/works.html","content":"<h2 id=\"什么是“双缓存”？\"><a href=\"#什么是“双缓存”？\" class=\"headerlink\" title=\"什么是“双缓存”？\"></a>什么是 “双缓存”？</h2><p>“双缓存” 是一种常见的图形处理技术，用于在图像渲染中实现平滑的、无闪烁的更新效果。它通过使用两个缓冲区（即两块内存区域）来完成。其中一个缓冲区用于显示图像，而另一个缓冲区则用于在后台进行图像的更新和绘制。当更新完成后，通过交换两个缓冲区的引用，以实现无缝的切换和更新。</p>\n<p>在图形处理中使用双缓存的好处包括：</p>\n<ol>\n<li>无闪烁：通过在后台缓冲区进行绘制，然后将绘制结果一次性地切换到显示缓冲区，可以避免在图像更新过程中的闪烁问题。这对于实时图形、动画和视频等应用非常重要。</li>\n<li>平滑更新：使用双缓冲可以实现平滑的更新效果。在后台缓冲区进行绘制和更新，然后在更新完成后将其切换到显示缓冲区，可以避免直接在显示缓冲区上进行绘制和修改，从而减少了可能出现的可见的渲染中间状态。</li>\n<li>减少渲染延迟：使用双缓冲可以减少渲染延迟。由于绘制和更新发生在后台缓冲区，因此可以在绘制完成后立即切换到显示缓冲区，从而减少了等待绘制完成的时间，提高了渲染效率和响应时间。</li>\n</ol>\n<p>双缓存技术在图形处理、动画、视频播放和游戏开发等领域得到广泛应用。在图形库、操作系统和桌面应用程序中，双缓存被用于实现平滑的图像渲染和交互效果。在前端开发中，双缓存也被广泛应用于图形绘制和动画效果的实现，以提供更好的用户体验。</p>\n<p><code>React</code> 使用 “双缓存” 来完成 <code>Fiber树</code>的构建与替换 —— 对应着 <code>DOM树</code>的创建与更新。</p>\n<h2 id=\"双缓存Fiber树\"><a href=\"#双缓存Fiber树\" class=\"headerlink\" title=\"双缓存Fiber树\"></a>双缓存 Fiber 树</h2><p>在 <code>React</code> 中最多会同时存在两棵 <code>Fiber树</code>。当前屏幕上显示内容对应的 <code>Fiber树</code>称为 <code>current Fiber树</code>，正在内存中构建的 <code>Fiber树</code>称为 <code>workInProgress Fiber树</code>。</p>\n<p><code>current Fiber树</code>中的 <code>Fiber节点</code>被称为 <code>current fiber</code>，<code>workInProgress Fiber树</code>中的 <code>Fiber节点</code>被称为 <code>workInProgress fiber</code>，他们通过 <code>alternate</code> 属性连接。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">currentFiber.<span class=\"property\">alternate</span> === workInProgressFiber;</span><br><span class=\"line\">workInProgressFiber.<span class=\"property\">alternate</span> === currentFiber;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>React </code>应用的根节点通过使 <code>current </code> 指针在不同 <code>Fiber树</code> 的 <code>rootFiber</code> 间切换来完成 <code>current Fiber</code> 树指向的切换。</p>\n<p>即当 <code>workInProgress Fiber树</code> 构建完成交给 <code>Renderer</code> 渲染在页面上后，应用根节点的 <code>current</code> 指针指向 <code>workInProgress Fiber树</code> ，此时 <code>workInProgress Fiber树</code>就变为 <code>current Fiber树</code>。</p>\n<p>每次状态更新都会产生新的 <code>workInProgress Fiber树</code>，通过 <code>current</code> 与 <code>workInProgress</code> 的替换，完成 <code>DOM</code> 更新。</p>\n<p>接下来我们以具体例子讲解 <code>mount时</code>、<code>update时</code>的构建 / 替换流程。</p>\n<h2 id=\"mount时\"><a href=\"#mount时\" class=\"headerlink\" title=\"mount时\"></a>mount 时</h2><p>考虑如下例子：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> '<span class=\"attr\">red</span>' }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></tbody></table></figure>\n\n<ol>\n<li>首次执行 <code>ReactDOM.render</code> 会创建 <code>fiberRootNode</code>（源码中叫 <code>fiberRoot</code>）和 <code>rootFiber</code>。其中 <code>fiberRootNode</code> 是整个应用的根节点，<code>rootFiber</code> 是 <code>&lt;App/&gt;</code> 所在组件树的根节点。</li>\n</ol>\n<p>之所以要区分 <code>fiberRootNode</code> 与 <code>rootFiber</code>，是因为在应用中我们可以多次调用 <code>ReactDOM.render</code> 渲染不同的组件树，他们会拥有不同的 <code>rootFiber</code>。但是整个应用的根节点只有一个，那就是 <code>fiberRootNode</code>。</p>\n<p><code>fiberRootNode</code> 的 <code>current</code> 会指向当前页面上已渲染内容对应 <code>Fiber树</code>，即 <code>current Fiber树</code>。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"fiberRootNode\"></p>\n<p><code>fiberRootNode.current = rootFiber;</code></p>\n<p>由于是首屏渲染，页面中还没有挂载任何 <code>DOM</code>，所以 <code>fiberRootNode.current</code> 指向的 <code>rootFiber</code> 没有任何<code>子Fiber节点</code>（即 <code>current Fiber树</code>为空）。</p>\n<ol start=\"2\">\n<li>接下来进入 <code>render阶段</code>，根据组件返回的 <code>JSX</code> 在内存中依次创建 <code>Fiber节点</code>并连接在一起构建 <code>Fiber树</code>，被称为 <code>workInProgress Fiber树</code>。（下图中右侧为内存中构建的树，左侧为页面显示的树）</li>\n</ol>\n<p>在构建 <code>workInProgress Fiber树</code>时会尝试复用 <code>current Fiber树</code>中已有的 <code>Fiber节点</code>内的属性，在<code>首屏渲染</code>时只有 <code>rootFiber</code> 存在对应的 <code>current fiber</code>（即 <code>rootFiber.alternate</code>）。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b55d2c458853aef05059f.jpg\"></p>\n<ol start=\"3\">\n<li>图中右侧已构建完的 <code>workInProgress Fiber树</code>在 <code>commit阶段</code>渲染到页面。</li>\n</ol>\n<p>此时 <code>DOM</code> 更新为右侧树对应的样子。<code>fiberRootNode</code> 的 <code>current</code> 指针指向 <code>workInProgress Fiber树</code>使其变为 <code>current Fiber 树</code>。</p>\n<p><img data-src=\"https://react.iamkasong.com/img/wipTreeFinish.png\"></p>\n<h2 id=\"update时\"><a href=\"#update时\" class=\"headerlink\" title=\"update时\"></a>update 时</h2><ol>\n<li><p>接下来我们点击 <code>p节点</code>触发状态改变，这会开启一次新的 <code>render阶段</code>并构建一棵新的 <code>workInProgress Fiber 树</code>。</p>\n<p><img data-src=\"https://react.iamkasong.com/img/wipTreeUpdate.png\"></p>\n</li>\n</ol>\n<p>和 <code>mount</code> 时一样，<code>workInProgress fiber</code> 的创建可以复用 <code>current Fiber树</code>对应的节点数据。</p>\n<ol start=\"2\">\n<li><code>workInProgress Fiber 树</code>在 <code>render阶段</code>完成构建后进入 <code>commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为 <code>current Fiber 树</code>。</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b55f9c458853aef0589a3.jpg\" alt=\"渲染过程\"></p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"FiberNode 结构解析","url":"//react/fiber/node.html","content":"<h1 id=\"FiberNode结构解析\"><a href=\"#FiberNode结构解析\" class=\"headerlink\" title=\"FiberNode结构解析\"></a>FiberNode 结构解析</h1><p>FiberNode（也称为 Fiber 节点）是 React Fiber 架构中的核心概念之一，用于表示组件的层级结构和渲染过程中的任务。</p>\n<span id=\"more\"></span>\n\n\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberNode</span>(<span class=\"params\">tag, pendingProps, key, mode</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">tag</span> = tag;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">key</span> = key;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">elementType</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stateNode</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">return</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">child</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sibling</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">ref</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">pendingProps</span> = pendingProps;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedProps</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">updateQueue</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedState</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">dependencies</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">mode</span> = mode; <span class=\"comment\">// Effects</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">flags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">deletions</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">lanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">childLanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">alternate</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  {</span><br><span class=\"line\">    <span class=\"comment\">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Initializing the fields below to smis and later updating them with</span></span><br><span class=\"line\">    <span class=\"comment\">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class=\"line\">    <span class=\"comment\">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class=\"line\">    <span class=\"comment\">// Fortunately this only impacts DEV builds.</span></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class=\"line\">    <span class=\"comment\">// To work around this, initialize the fields below with doubles.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Learn more about this here:</span></span><br><span class=\"line\">    <span class=\"comment\">// https://github.com/facebook/react/issues/14365</span></span><br><span class=\"line\">    <span class=\"comment\">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>; <span class=\"comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  {</span><br><span class=\"line\">    <span class=\"comment\">// This isn't directly used but is handy for debugging internals:</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugSource</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugOwner</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugNeedsRemount</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugHookTypes</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasBadMapPolyfill &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"title class_\">Object</span>.<span class=\"property\">preventExtensions</span> === <span class=\"string\">'function'</span>) {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h5 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h5><p>表示 FiberNode 的类型，可以是 HostComponent、ClassComponent、FunctionComponent 等。</p>\n<h5 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h5><p>表示组件的唯一标识符，用于在列表渲染中进行元素的重用。</p>\n<h5 id=\"elementType\"><a href=\"#elementType\" class=\"headerlink\" title=\"elementType\"></a>elementType</h5><p>表示组件元素的类型。大部分情况同 type，某些情况不同，比如 FunctionComponent 使用 React.memo 包裹。</p>\n<h5 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h5><p>type 属性表示 FiberNode 对应的组件类型，可以是字符串（原生组件）或函数 / 类（自定义组件）。对于 FunctionComponent，指函数本身，对于 ClassComponent，指 class，对于 HostComponent，指 DOM 节点 tagName。</p>\n<h5 id=\"stateNode\"><a href=\"#stateNode\" class=\"headerlink\" title=\"stateNode\"></a>stateNode</h5><p>每个 FiberNode 包含一个 stateNode 属性，它指向组件实例。stateNode 可以是一个 DOM 元素（对于原生组件），也可以是一个类实例（对于自定义组件）。</p>\n<blockquote>\n<p>​\tFiberNode 使用链表结构来表示组件的层级关系</p>\n</blockquote>\n<h5 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h5><p>return 指向父节点。</p>\n<h5 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child\"></a>child</h5><p>  child 属性指向第一个子节点。</p>\n<h5 id=\"sibling\"><a href=\"#sibling\" class=\"headerlink\" title=\"sibling\"></a>sibling</h5><p>  sibling 属性指向下一个兄弟节点。</p>\n<h6 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h6><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">function App() {</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      i am</span><br><span class=\"line\">      &lt;span&gt;SongShao&lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>对应的 <code>Fiber树</code>结构</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">   App</span><br><span class=\"line\">   ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span></span><br><span class=\"line\">||</span><br><span class=\"line\"> --------div ----------------</span><br><span class=\"line\">      ||  \t\t\t ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span>  child || <span class=\"built_in\">return</span> </span><br><span class=\"line\">         ||\t\t\t\t ||</span><br><span class=\"line\">        i am ----------- span</span><br><span class=\"line\">               sibling    ||</span><br><span class=\"line\">           \t\t   child || <span class=\"built_in\">return</span></span><br><span class=\"line\">           \t\t \t     ||</span><br><span class=\"line\">           \t\t      SongShao</span><br><span class=\"line\">    </span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>这里需要提一下，为什么父级指针叫做 <code>return</code> 而不是 <code>parent</code> 或者 <code>father</code> 呢？因为作为一个工作单元，<code>return</code> 指节点执完 <code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子 <code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用 <code>return</code> 指代父级节点。</p>\n</blockquote>\n<h5 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h5><p>在父节点中的索引位置。</p>\n<h5 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h5><p>用于引用组件。</p>\n<h5 id=\"pendingProps\"><a href=\"#pendingProps\" class=\"headerlink\" title=\"pendingProps\"></a>pendingProps</h5><p>组件的待处理属性。</p>\n<h5 id=\"memoizedProps-和-memoizedState\"><a href=\"#memoizedProps-和-memoizedState\" class=\"headerlink\" title=\"memoizedProps 和 memoizedState\"></a>memoizedProps 和 memoizedState</h5><p>这些属性保存了组件的当前状态（props 和 state）。在渲染过程中，React 使用 memoizedProps 和 memoizedState 保存组件的最新状态，并通过比较前后两次状态的差异，确定是否需要更新组件。</p>\n<h5 id=\"updateQueue\"><a href=\"#updateQueue\" class=\"headerlink\" title=\"updateQueue\"></a>updateQueue</h5><p>用于存储组件的更新队列。</p>\n<h5 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h5><p>表示组件的依赖项。</p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><p>表示渲染模式。</p>\n<h5 id=\"flags-和-subtreeFlags\"><a href=\"#flags-和-subtreeFlags\" class=\"headerlink\" title=\"flags 和 subtreeFlags\"></a>flags 和 subtreeFlags</h5><p>表示 FiberNode 的状态标志。</p>\n<h5 id=\"deletions\"><a href=\"#deletions\" class=\"headerlink\" title=\"deletions\"></a>deletions</h5><p>表示待删除的节点。</p>\n<h5 id=\"lanes-和-childLanes\"><a href=\"#lanes-和-childLanes\" class=\"headerlink\" title=\"lanes 和 childLanes\"></a>lanes 和 childLanes</h5><p>表示调度的优先级。</p>\n<h5 id=\"alternate\"><a href=\"#alternate\" class=\"headerlink\" title=\"alternate\"></a>alternate</h5><p>alternate 属性指向 FiberNode 的替代节点。在渲染过程中，React 会创建两个 FiberNode，一个表示当前渲染状态，另一个表示下一次渲染状态。通过 alternate 属性，React 在两个状态之间进行比较，找出需要更新的节点。</p>\n<h5 id=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"><a href=\"#actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\" class=\"headerlink\" title=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"></a>actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration</h5><p>用于记录组件的实际渲染时间和基准时间。</p>\n<h5 id=\"debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\"><a href=\"#debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\" class=\"headerlink\" title=\"__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes\"></a>__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes</h5><p>用于调试和内部记录。</p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"React 获取服务器端时间","url":"//react/service/time.html","content":"<h2 id=\"React-获取服务器端时间\"><a href=\"#React-获取服务器端时间\" class=\"headerlink\" title=\"React 获取服务器端时间\"></a>React 获取服务器端时间</h2><p><strong>思路</strong>：React 获取服务器端时间，本质上就是给服务器端发送一个请求，然后从返回数据里面的 headers 里面获取到服务器 date，然后更新服务器时间去格式化，获取服务器时间结束。按秒进行数据刷新，其实也很简单，就是使用定时器，进行动态递增即可，直接上代码。</p>\n<span id=\"more\"></span>\n<p>获取服务器时间的方法：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">changeTime = async () =&gt; {</span><br><span class=\"line\">    let leftTime = await axios.get('/').then(response =&gt; {</span><br><span class=\"line\">        console.log(response.headers)</span><br><span class=\"line\">        return new Date(response.headers.date).getTime()</span><br><span class=\"line\">     }).catch(error =&gt; {</span><br><span class=\"line\">        console.log(error)</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">     })</span><br><span class=\"line\">        this.setState({</span><br><span class=\"line\">        time: moment(leftTime).format('YYYY-MM-DD HH:mm:ss')</span><br><span class=\"line\">    })</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>自动增加的方法（以秒为单位）:</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">addTime = date =&gt; {</span><br><span class=\"line\">      let newDate = new Date(date)</span><br><span class=\"line\">      newDate.setSeconds(newDate.getSeconds() + 1)</span><br><span class=\"line\">      this.setState({</span><br><span class=\"line\">        time: moment(newDate).format('YYYY-MM-DD HH:mm:ss')</span><br><span class=\"line\">      })</span><br><span class=\"line\">      window.time = {</span><br><span class=\"line\">        date: this.state.time,</span><br><span class=\"line\">        timestamp: Date.parse(new Date(this.state.time))</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>最后根据 react  state 状态进行页面渲染。</p>\n","categories":["React"],"tags":["前端","JavaScript","react"]},{"title":"React 使用合成事件（SyntheticEvent）","url":"//react/synthetic/event.html","content":"<h1 id=\"React-使用合成事件\"><a href=\"#React-使用合成事件\" class=\"headerlink\" title=\"React 使用合成事件\"></a>React 使用合成事件</h1><p>React 使用合成事件（SyntheticEvent）来处理浏览器原生事件的跨浏览器兼容性问题。合成事件是一个封装了原生事件的对象，提供了一致的跨浏览器接口，使您能够在不同浏览器中以一致的方式处理事件。</p>\n<span id=\"more\"></span>\n<p>在 React 中，您可以通过在组件中定义事件处理函数并将其传递给相应的元素来处理合成事件。例如，您可以在一个按钮上定义一个点击事件处理函数：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> {</span><br><span class=\"line\">  handleClick = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Button clicked!'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{this.handleClick}</span>&gt;</span>Click me!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在上面的示例中，我们定义了一个名为 handleClick 的点击事件处理函数，并将其传递给按钮的 onClick 属性。当按钮被点击时，React 将自动创建一个合成事件对象，并将其作为参数传递给 handleClick 函数。您可以在事件处理函数中访问合成事件对象，并使用其属性和方法进行操作。</p>\n<p>合成事件对象具有与原生事件对象相似的属性和方法，但也有一些额外的属性和方法，用于处理 React 特定的功能。例如，您可以使用 event.target 来访问触发事件的元素，event.preventDefault () 来阻止默认行为，以及 event.stopPropagation () 来阻止事件冒泡。</p>\n<p>请注意，由于合成事件是 React 提供的跨浏览器抽象，它并不是浏览器原生事件对象。因此，某些浏览器特定的功能可能不可用或表现不一致。如果需要访问原生事件对象，您可以使用合成事件对象的 nativeEvent 属性。</p>\n<h1 id=\"React合成事件如何阻止事件传播\"><a href=\"#React合成事件如何阻止事件传播\" class=\"headerlink\" title=\"React合成事件如何阻止事件传播\"></a>React 合成事件如何阻止事件传播</h1><p>React 合成事件可以通过调用 <code>e.stopPropagation()</code> 来阻止事件传播。<br>当根容器接收到捕获事件时，先触发一次 React 事件的捕获阶段，然后再执行原生事件的捕获传播。所以，调用 <code>e.stopPropagation()</code> 可以阻止原生事件的传播。<br>合成事件是根据事件类型对原生事件的属性进行处理，并包装了关键方法，从而实现了事件的触发和处理。</p>\n","categories":["React"],"tags":["前端","JavaScript","react"]},{"title":"React 实现原理","url":"//react/implement.html","content":"<h3 id=\"实现jsx\"><a href=\"#实现jsx\" class=\"headerlink\" title=\"实现jsx\"></a>实现 jsx</h3><figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> \"<span class=\"attr\">red</span>\" }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(element);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"编译后\"><a href=\"#编译后\" class=\"headerlink\" title=\"编译后\"></a>编译后</h3><p><img data-src=\"https://pic.imgdb.cn/item/653b2718c458853aef75775a.jpg\" alt=\"jsx 编译之后\"></p>\n<h3 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h3><ol>\n<li><p>jsx-dev-runtime.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> { jsxDEV } <span class=\"keyword\">from</span> <span class=\"string\">\"./jsx/ReactJSXElement\"</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactJSXElement.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hasOwnProperty <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/hasOwnProperty'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dom 类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span>  } <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/ReactSymbols'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">RESERVED_PROPS</span> = {</span><br><span class=\"line\">    <span class=\"attr\">key</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">ref</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasValidKey</span>(<span class=\"params\">config</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config.<span class=\"property\">key</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasValidRef</span>(<span class=\"params\">config</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config.<span class=\"property\">ref</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReactElement 创建</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ReactElement</span>(<span class=\"params\">type, key, ref, props, owner</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 这个标签允许我们唯一地将其标识为React元素</span></span><br><span class=\"line\">        <span class=\"attr\">$$typeof</span>: <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span>,</span><br><span class=\"line\">        type,</span><br><span class=\"line\">        key,</span><br><span class=\"line\">        ref,</span><br><span class=\"line\">        props,</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">jsxDEV</span>(<span class=\"params\">type, config</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 提取保留名称</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> props = {};</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">hasValidKey</span>(config)) {</span><br><span class=\"line\">        key = config.<span class=\"property\">key</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">hasValidRef</span>(config)) {</span><br><span class=\"line\">        ref = config.<span class=\"property\">ref</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> propName <span class=\"keyword\">in</span> config) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasOwnProperty.<span class=\"title function_\">call</span>(config, propName) &amp;&amp;</span><br><span class=\"line\">        !<span class=\"variable constant_\">RESERVED_PROPS</span>.<span class=\"title function_\">hasOwnProperty</span>(propName)</span><br><span class=\"line\">        ) {</span><br><span class=\"line\">            props[propName] = config[propName];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">ReactElement</span>(type, key, ref, props)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>hasOwnProperty.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> { hasOwnProperty } = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> hasOwnProperty;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactSymbols.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于标记类似 ReactElement 类型的符号。</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">'react.element'</span>);</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"根节点和根fiber\"><a href=\"#根节点和根fiber\" class=\"headerlink\" title=\"根节点和根fiber\"></a>根节点和根 fiber</h3><ul>\n<li>需要给 react 提供一个根节点，之后每个节点都是渲染在根节点内部的。</li>\n</ul>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>根 fiber 可以通俗理解为一个装着所有虚拟 dom 的容器，每个虚拟 dom 又单独对应一个 fiber，</li>\n<li>渲染可以以单个 fiber 为单位暂停 / 恢复。</li>\n<li>需要创建两个根 <code>fiber</code> 去相互替换展示。</li>\n</ul>\n<h4 id=\"创建根节点\"><a href=\"#创建根节点\" class=\"headerlink\" title=\"创建根节点\"></a>创建根节点</h4><p>更改 main.jsx</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"react-dom/client\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> '<span class=\"attr\">red</span>' }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>首先要建一个 <code>FiberRootNode</code> 根节点，也就是所有 DOM 的根，本质就是 <code>div#root</code>。</p>\n<p>根节点和 <code>fiber</code> 关系：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"根节点和`fiber`关系\"></p>\n<p><code>FiberRootNode</code> 和 <code>HostRootFiber</code> 中间使用 <code>current</code> 相连；</p>\n<p><code>HostRootFiber</code> 和 <code>FiberRootNode</code> 中间使用 <code>stateNode</code> 相连。</p>\n<h4 id=\"实现createRoot\"><a href=\"#实现createRoot\" class=\"headerlink\" title=\"实现createRoot\"></a>实现 createRoot</h4><p>分这么多文件的主要是因为很多其他逻辑要处理，暂时都给省略了。虽然比较绕，但其实本质就是把 <code>div#root</code> 做了几层包装。</p>\n<ol>\n<li><p>client.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> { createRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"./src/client/ReactDOMRoot\"</span>;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactDOMRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createContainer } <span class=\"keyword\">from</span> <span class=\"string\">\"react-reconciler/src/ReactFiberReconciler\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ReactDOMRoot</span>(<span class=\"params\">internalRoot</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">_internalRoot</span> = internalRoot;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 创建一个根 实际就是一个被包装过的真实DOM节点</span></span><br><span class=\"line\"><span class=\"comment\">// container: div#root</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createRoot</span>(<span class=\"params\">container</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建容器   6. 接收到有#root的容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createContainer</span>(container);</span><br><span class=\"line\"><span class=\"comment\">// 7. 容器传给 ReactDOMRoot</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReactDOMRoot</span>(root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createFiberRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberRoot\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建容器 containerInfo: 容器信息</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createContainer</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">createFiberRoot</span>(containerInfo);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberRootNode</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 4. 把DOM节点放到容器</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">containerInfo</span> = containerInfo</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberRoot</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建根容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">FiberRootNode</span>(containerInfo);</span><br><span class=\"line\"><span class=\"comment\">// 这个位置在下一步要创建 FiberRoot</span></span><br><span class=\"line\"><span class=\"comment\">// 5. 把容器返回出去</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<p>现在根节点 <code>FiberRootNode</code> 创建好了，最后 <code>root</code> 的打印结果：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2e66c458853aef8a195c.jpg\" alt=\"FiberRootNode\"></p>\n<h4 id=\"fiber\"><a href=\"#fiber\" class=\"headerlink\" title=\"fiber\"></a>fiber</h4><p>在创建根 fiber 之前先了解一下 fiber</p>\n<h4 id=\"为什么需要有fiber？\"><a href=\"#为什么需要有fiber？\" class=\"headerlink\" title=\"为什么需要有fiber？\"></a>为什么需要有 fiber？</h4><ul>\n<li>react 以前没有 fiber 整个计算过程不能暂停，会导致时间过长</li>\n<li>浏览器刷新频率为 60Hz, 大概 16.6 毫秒渲染一次，而 JS 线程和渲染线程是互斥的，所以如果 JS 线程执行任务时间超过 16.6ms 的话，就会导致掉帧、卡顿，解决方案就是 React 利用空闲的时间进行更新，不影响渲染进行的渲染</li>\n<li>把一个耗时任务切分成一个个小任务，分布在每一帧里。这个的方式就叫时间切片</li>\n</ul>\n<p>我们需要把渲染变成一个可中断，可暂停，可恢复的过程。<br>注：可以去搜一下 requestIdleCallback API ，react 封装了一个类似的方法让每帧时间固定 5ms。</p>\n<h4 id=\"什么是fiber？\"><a href=\"#什么是fiber？\" class=\"headerlink\" title=\"什么是fiber？\"></a>什么是 fiber？</h4><ul>\n<li><p>Fiber 是一个执行单元</p>\n<p>  Fiber 是一个执行单元，每次执行完一个执行单元，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去。</p>\n<p>  react 中一帧的过程：</p>\n<p>  <img data-src=\"https://pic.imgdb.cn/item/653b551cc458853aef02aa5f.jpg\" alt=\"react 中一帧的过程\"></p>\n</li>\n<li><p>Fiber 是一种数据结构<br>  React 目前的做法是使用链表，每个虚拟节点内部表示为一个 Fiber<br>  从顶点开始遍历<br>  如果有第一个儿子，先遍历第一个儿子<br>  如果没有第一个儿子，标志着此节点遍历完成<br>  如果有弟弟遍历弟弟<br>  如果有没有下一个弟弟，返回父节点标识完成父节点遍历，如果有叔叔遍历叔叔<br>  没有父节点遍历结束</p>\n<p>  遍历结构：<br>  <img data-src=\"https://pic.imgdb.cn/item/653b55d2c458853aef05059f.jpg\" alt=\"遍历结构\"></p>\n<p>  遍历过程：<br>  <img data-src=\"https://pic.imgdb.cn/item/653b55f9c458853aef0589a3.jpg\" alt=\"遍历过程\"></p>\n</li>\n</ul>\n<h4 id=\"创建根fiber\"><a href=\"#创建根fiber\" class=\"headerlink\" title=\"创建根fiber\"></a>创建根 fiber</h4><p>真实 DOM 需要一个根容器，<code>fiber</code> 同样需要一个根 <code>fiber</code>。</p>\n<p>相当于每个虚拟 DOM 都会创建一个对应的 <code>Fiber</code>，再创建真实 DOM</p>\n<p>虚拟 DOM =&gt; Fiber =&gt; 真实 DOM</p>\n<p>在刚刚创建 FiberRootNode 的函数里去创建 <code>HostRootFiber</code> 并互相指向对方。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"根节点和`fiber`关系\"></p>\n<ol>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createHostRootFiber } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberRootNode</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">containerInfo</span> = containerInfo;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberRoot</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 之前创建的根节点容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">FiberRootNode</span>(containerInfo);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建根fiber. hostRoot就是根节点dev#root</span></span><br><span class=\"line\"><span class=\"comment\">// 未初始化的fiber</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uninitializedFiber = <span class=\"title function_\">createHostRootFiber</span>();</span><br><span class=\"line\"><span class=\"comment\">// 当前渲染页面的fiber.</span></span><br><span class=\"line\"><span class=\"comment\">// 6. 根容器的current指向当前的根fiber</span></span><br><span class=\"line\">root.<span class=\"property\">current</span> = uninitializedFiber;</span><br><span class=\"line\">uninitializedFiber.<span class=\"property\">stateNode</span> = root;</span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3. 工作标签</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostRoot</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactWorkTags\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 5. 副作用标识</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">NoFlags</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberFlags\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">FiberNode</span>(<span class=\"params\">tag, pendingProps, key</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">tag</span> = tag;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">key</span> = key;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// fiber类型, 来自于虚拟DOM节点的type   (span h1 p)</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">stateNode</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 此fiber对应的真实DOM节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">return</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向父节点</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">child</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向第一个子节点</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">sibling</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向弟弟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">pendingProps</span> = pendingProps; <span class=\"comment\">// 等待生效的属性</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">memoizedProps</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 已经生效的属性</span></span><br><span class=\"line\"><span class=\"comment\">// 虚拟DOM会提供pendingProps给创建fiber的属性，等处理完复制给memoizedProps</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个fiber还会有自己的状态，每一种fiber状态存的类型都不一样</span></span><br><span class=\"line\"><span class=\"comment\">// 比如：类组件对应的fiber存的就是实例的状态，HostRoot存的就是要渲染的元素</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">memoizedState</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个fiber可能还有自己的更新队列</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">updateQueue</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. \"./ReactFiberFlags\"</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">flags</span> = <span class=\"title class_\">NoFlags</span>; <span class=\"comment\">// 副作用标识，表示对此fiber节点进行何种操作</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>; <span class=\"comment\">// 子节点对应的副作用标识</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">alternate</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 轮替 (缓存了另一个fiber节点实例) diff时用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberNode</span>(<span class=\"params\">tag, pendingProps, key</span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FiberNode</span>(tag, pendingProps, key);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createHostRootFiber</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">createFiberNode</span>(<span class=\"title class_\">HostRoot</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactWorkTags.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每种虚拟DOM都会对应自己的fiber的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 根Fiber的Tag</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostRoot</span> = <span class=\"number\">3</span>; <span class=\"comment\">// 根节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostComponent</span> = <span class=\"number\">5</span>; <span class=\"comment\">// 原生节点 span div p</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostText</span> = <span class=\"number\">6</span>; <span class=\"comment\">// 纯文本节点</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberFlags.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有任何操作</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">NoFlags</span> = <span class=\"number\">0b000000000000000000000000000000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Placement</span> = <span class=\"number\">0b000000000000000000000000000010</span>;</span><br><span class=\"line\"><span class=\"comment\">// 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Update</span> = <span class=\"number\">0b000000000000000000000000000100</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<p>看最后 root 的打印结果：根 fiber 和节点容器互相指向</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b5beac458853aef1a1a12.jpg\" alt=\"根fiber和节点容器互相指向\"></p>\n<pre><code>current指的是当前根容器正在显示或者已经渲染好的fiber树\n</code></pre>\n<p>react 采用了双缓存区的技术，可以把将要显示的图片绘制在缓存区中，需要展示的时候直接拿来替换掉。 alternate 轮替。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653bc1f2c458853aefb79377.jpg\"></p>\n<h4 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h4><p>打开 ReactFiberRoot.js 文件，在 return root 之前加一行代码，给根 fiber 加上一个更新队列，之后更新渲染任务都是放到这个队列里面。</p>\n<ol>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">+ <span class=\"keyword\">import</span> { initialUpdateQueue } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberClassUpdateQueue\"</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">+ <span class=\"title function_\">initialUpdateQueue</span>(uninitializedFiber);</span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberClassUpdateQueue.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initialUpdateQueue</span>(<span class=\"params\">fiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个更新队列</span></span><br><span class=\"line\">    <span class=\"comment\">// pending 是循环链表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = {</span><br><span class=\"line\">        <span class=\"attr\">shared</span>: {</span><br><span class=\"line\">            <span class=\"attr\">pending</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    fiber.<span class=\"property\">updateQueue</span> = queue;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<p>如下图所示在 fiber 树中增加了 updateQueue 队列</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653bc2bdc458853aefbd2de4.jpg\" alt=\"updateQueue 队列\"></p>\n<h3 id=\"构建轮替的根fiber\"><a href=\"#构建轮替的根fiber\" class=\"headerlink\" title=\"构建轮替的根fiber\"></a>构建轮替的根 fiber</h3><h4 id=\"fiber是怎么运作的\"><a href=\"#fiber是怎么运作的\" class=\"headerlink\" title=\"fiber是怎么运作的\"></a>fiber 是怎么运作的</h4><pre><code>为什么要轮替在上一篇已经说过了，这一篇写一下fiber的单项循环链表。\n</code></pre>\n<p>假如我们有一个 jsx 的 dom 结构</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"A1\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"B1\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"C1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"C2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"B2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在以前没有用 fiber 渲染是这样的，这个渲染方式是递归渲染如果数据很多就可能会卡顿。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vDom = {</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"key\"</span>: <span class=\"string\">\"A1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"props\"</span>: {</span><br><span class=\"line\">        <span class=\"string\">\"className\"</span>: <span class=\"string\">\"A1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"children\"</span>: [</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"key\"</span>: <span class=\"string\">\"B1\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"props\"</span>: {</span><br><span class=\"line\">                    <span class=\"string\">\"className\"</span>: <span class=\"string\">\"B1\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"children\"</span>: [</span><br><span class=\"line\">                        {</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"C1\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"props\"</span>: { <span class=\"string\">\"className\"</span>: <span class=\"string\">\"C1\"</span>},</span><br><span class=\"line\">                        },</span><br><span class=\"line\">                        {</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"C2\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"props\"</span>: {<span class=\"string\">\"className\"</span>: <span class=\"string\">\"C2\"</span>},</span><br><span class=\"line\">                        }</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                },</span><br><span class=\"line\">            },</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"key\"</span>: <span class=\"string\">\"B2\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"props\"</span>: {<span class=\"string\">\"className\"</span>: <span class=\"string\">\"B2\"</span>},</span><br><span class=\"line\">            }</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    },</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 把vDom一气呵成渲染到页面</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 把虚拟DOM创建成真实DOM</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历属性</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>).<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> key !== <span class=\"string\">'children'</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> {</span><br><span class=\"line\">        dom[key] = element.<span class=\"property\">props</span>[key];</span><br><span class=\"line\">    });</span><br><span class=\"line\">    <span class=\"comment\">// 把子节点渲染到父节点上</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(element.<span class=\"property\">props</span>.<span class=\"property\">children</span>)){</span><br><span class=\"line\">        element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span>=&gt;</span><span class=\"title function_\">render</span>(child,dom));</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 把真实节点挂载到容器</span></span><br><span class=\"line\">    container.<span class=\"title function_\">appendChild</span>(dom);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">render</span>(element, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></tbody></table></figure>\n\n<p>下面是 fiber 的渲染方式，可以中断、暂停、恢复渲染。深度优先</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把虚拟DOM构建成Fiber树</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">A1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'A1'</span> } };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">B1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'B1'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">A1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">B2</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'B2'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">A1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">C1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'C1'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">B1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">C2</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'C2'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">B1</span> };</span><br><span class=\"line\"><span class=\"variable constant_\">A1</span>.<span class=\"property\">child</span> = <span class=\"variable constant_\">B1</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">B1</span>.<span class=\"property\">sibling</span> = <span class=\"variable constant_\">B2</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">B1</span>.<span class=\"property\">child</span> = <span class=\"variable constant_\">C1</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">C1</span>.<span class=\"property\">sibling</span> = <span class=\"variable constant_\">C2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个工作单元</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasRemainingTime</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 模拟有时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// render 工作循序</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 有下一个节点并且有时间时</span></span><br><span class=\"line\">    <span class=\"comment\">// 每一个任务执行完都可以放弃，让浏览器执行更高优先级的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nextUnitOfWork &amp;&amp; <span class=\"title function_\">hasRemainingTime</span>()) {</span><br><span class=\"line\">        <span class=\"comment\">// 执行下一个任务并返回下一个任务</span></span><br><span class=\"line\">        nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(fiber);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'render 阶段结束\");</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 执行完后返回下一个节点</span></span><br><span class=\"line\"><span class=\"string\">function performUnitOfWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    // 执行渲染</span></span><br><span class=\"line\"><span class=\"string\">    let child = beginWork(fiber);</span></span><br><span class=\"line\"><span class=\"string\">    if(child) {</span></span><br><span class=\"line\"><span class=\"string\">        return child;</span></span><br><span class=\"line\"><span class=\"string\">    }</span></span><br><span class=\"line\"><span class=\"string\">    // 如果没有子节点说明当前节点已经完成了渲染工作</span></span><br><span class=\"line\"><span class=\"string\">    while(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">        // 可以结束此fiber的渲染了 </span></span><br><span class=\"line\"><span class=\"string\">        completeUnitOfWork(fiber);</span></span><br><span class=\"line\"><span class=\"string\">        // 如果有弟弟就返回弟弟</span></span><br><span class=\"line\"><span class=\"string\">        if(fiber.sibling) {</span></span><br><span class=\"line\"><span class=\"string\">            return fiber.sibling;</span></span><br><span class=\"line\"><span class=\"string\">        }</span></span><br><span class=\"line\"><span class=\"string\">        // 否则就返回上一层</span></span><br><span class=\"line\"><span class=\"string\">        fiber = fiber.return;</span></span><br><span class=\"line\"><span class=\"string\">    }</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function beginWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    console.log('</span>beginWork<span class=\"string\">', fiber.props.className);</span></span><br><span class=\"line\"><span class=\"string\">    // 执行完成后返回第一个子节点</span></span><br><span class=\"line\"><span class=\"string\">    return fiber.child;</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function completeUnitOfWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    // 标记当前这个fiber街道已经完成</span></span><br><span class=\"line\"><span class=\"string\">    console.log('</span>completeUnitOfWork<span class=\"string\">', fiber.props.className);</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的这些代码是预先熟悉一下，fiber 是怎么运行，下面正式进入构建的代码逻辑。</p>\n<h4 id=\"队列的单向链表\"><a href=\"#队列的单向链表\" class=\"headerlink\" title=\"队列的单向链表\"></a>队列的单向链表</h4><ol>\n<li><p>在 main.js 中增加下面代码</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">root.<span class=\"title function_\">render</span>(element)</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactDOMRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { updateContainer } <span class=\"keyword\">from</span> <span class=\"string\">'../react-reconciler/src/ReactFiberReconciler'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"title class_\">ReactDomRoot</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">render</span> = <span class=\"keyword\">function</span> (<span class=\"params\">children</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 获取容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"variable language_\">this</span>.<span class=\"property\">_internalRoot</span>;</span><br><span class=\"line\"><span class=\"title function_\">updateContainer</span>(children, root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createUpdate, enqueueUpdate } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberClassUpdateQueue'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 更新容器, 把虚拟DOM变成真实DOM 插入到container容器中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} element 虚拟DOM</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} container 容器   FiberRootNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateContainer</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 获取根fiber</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> current = container.<span class=\"property\">current</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建更新队列</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> update = <span class=\"title function_\">createUpdate</span>();</span><br><span class=\"line\">update.<span class=\"property\">payload</span> = {element};</span><br><span class=\"line\"><span class=\"comment\">// 3. 把此更新任务对象添加到current这个根Fiber的更新队列里</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> root = <span class=\"title function_\">enqueueUpdate</span>(current, update);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberClassUpdateQueue.js</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653e40f6c458853aefe48306.jpg\" alt=\"ReactFiberClassUpdateQueue.js\"></p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { markUpdateLaneFromFiberToRoot } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberConcurrentUpdate'</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 更新状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UpdateState</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> update = {<span class=\"attr\">tag</span>: <span class=\"title class_\">UpdateState</span>};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> update;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">enqueueUpdate</span>(<span class=\"params\">fiber, update</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取根fiber的更新队列 (上一篇最后加的)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> updateQueue = fiber.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取等待执行的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pending = updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 说明初始化的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pending === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = pending.<span class=\"property\">next</span>;</span><br><span class=\"line\">        pending.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让等待更新指向当前update 开始更新</span></span><br><span class=\"line\">    updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = update;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从当前的fiber 到返回找到并返回根节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(fiber);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"冒泡获取根节点容器\"><a href=\"#冒泡获取根节点容器\" class=\"headerlink\" title=\"冒泡获取根节点容器\"></a>冒泡获取根节点容器</h4><p>ReactFiberConcurrentUpdate.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostRoot</span> } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactWorkTags'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 本来此文件要处理更新优先级问题，把不同的fiber优先级冒泡一路标记到根节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 目前现在值实现向上冒泡找到根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} <span class=\"variable\">sourceFiber</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(<span class=\"params\">sourceFiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 当前父fiber</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = sourceFiber.<span class=\"property\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当前fiber</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> node = sourceFiber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一直找到 父fiber 为null</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(parent !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        node = parent;</span><br><span class=\"line\">        parent = parent.<span class=\"property\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 返回当前root节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.<span class=\"property\">tag</span> === <span class=\"title class_\">HostRoot</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> root = node.<span class=\"property\">stateNode</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"调度更新\"><a href=\"#调度更新\" class=\"headerlink\" title=\"调度更新\"></a>调度更新</h4><p>到目前为止更新对象已经添加到了根 fiber 的更新队列上，现在需要开始进行调度更新。</p>\n<ol>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { scheduleUpdateOnFiber } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberWorkLoop'</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateContainer</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\">...</span><br><span class=\"line\">+ <span class=\"title function_\">scheduleUpdateOnFiber</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { scheduleCallback } <span class=\"keyword\">from</span> <span class=\"string\">'./scheduler'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">scheduleUpdateOnFiber</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">ensureRootIsScheduled</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">ensureRootIsScheduled</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 告诉浏览器要执行performConcurrentWorkOnRoot 参数定死为root</span></span><br><span class=\"line\">    <span class=\"title function_\">scheduleCallback</span>(performConcurrentWorkOnRoot.<span class=\"title function_\">bind</span>(<span class=\"literal\">null</span>, root));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performConcurrentWorkOnRoot</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root, <span class=\"string\">'performConcurrentWorkOnRoot'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>src/scheduler/index.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">'./src/forks/Scheduler'</span>;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>src/forks/Scheduler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处后面会实现优先级队列</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">scheduleCallback</span>(<span class=\"params\">callback</span>) {</span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(callback);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>打印 FiberRootNode</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653e496bc458853aef00deb1.jpg\" alt=\"输出的FiberRootNode\"></p>\n<h3 id=\"工作循环\"><a href=\"#工作循环\" class=\"headerlink\" title=\"工作循环\"></a>工作循环</h3><p><img data-src=\"https://pic.imgdb.cn/item/653e4d86c458853aef11c6ea.jpg\" alt=\"工作循环\"></p>\n<p>我们已经创建好一个根节点容器和一个空的根 fiber（黑色部分），在图中看到还有一个正在构建中的根 fiber。<br>根节点的 current 指的是当前的根 fiber，是会和构建中的根 fiber 轮替工作（双缓冲），现在需要构建一个新的根 fiber 并且把 fiber 树写在里面。<br>一个是表示当前页面已经渲染完成的 fiber 树，一个是正在构建中还没有生效、更没有更新到页面的 fiber 树</p>\n<h4 id=\"建立新的hostRootFiber\"><a href=\"#建立新的hostRootFiber\" class=\"headerlink\" title=\"建立新的hostRootFiber\"></a>建立新的 hostRootFiber</h4><ol>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { creatWorkInProgress } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正在进行中的工作</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> workInProgress = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * (被告知浏览器确保执行的函数)</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据当前的fiber节点构建fiber树, 创建真实的dom节点, 插入到容器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performConcurrentWorkOnRoot</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 初次渲染的时候以同步方式渲染根节点, 因为要尽快展示 (初始化)</span></span><br><span class=\"line\"><span class=\"title function_\">renderRootSync</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">prepareFreshStack</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 5. 根据老fiber构建新fiber (初始化)</span></span><br><span class=\"line\">workInProgress = <span class=\"title function_\">creatWorkInProgress</span>(root.<span class=\"property\">current</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderRootSync</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 2. 先构建了一个空的栈</span></span><br><span class=\"line\"><span class=\"title function_\">prepareFreshStack</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老fiber和新的属性构建新fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} pendingProps 新的属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">creatWorkInProgress</span>(<span class=\"params\">current, pendingProps</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 3. 拿到老fiber的轮替 第一次没有 (初始化)</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> workInProgress = current.<span class=\"property\">alternate</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(workInProgress === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = <span class=\"title function_\">createFiberNode</span>(current.<span class=\"property\">tag</span>, pendingProps, current.<span class=\"property\">key</span>);</span><br><span class=\"line\">        workInProgress.<span class=\"property\">type</span> = current.<span class=\"property\">type</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">stateNode</span> = current.<span class=\"property\">stateNode</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        workInProgress.<span class=\"property\">stateNode</span> = current;</span><br><span class=\"line\">        current.<span class=\"property\">alternate</span> =  workInProgress;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有，说明是更新，只能改属性就可以复用</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">pendingProps</span> = current.<span class=\"property\">pendingProps</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">type</span> = current.<span class=\"property\">type</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">flags</span> = current.<span class=\"property\">flags</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 复制属性</span></span><br><span class=\"line\">    workInProgress.<span class=\"property\">child</span> = current.<span class=\"property\">child</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">memoizedProps</span> = current.<span class=\"property\">memoizedProps</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">memoizedState</span> = current.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">updateQueue</span> = current.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">sibling</span> = current.<span class=\"property\">sibling</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">index</span> = current.<span class=\"property\">index</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workInProgress;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"执行工作单元\"><a href=\"#执行工作单元\" class=\"headerlink\" title=\"执行工作单元\"></a>执行工作单元</h4><p>然后在新的根 fiber 里构建更新 fiber 树</p>\n<ol>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { beginWork } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberBeginWork\"</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderRootSync</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 2. 先构建一个空的栈</span></span><br><span class=\"line\">    <span class=\"title function_\">prepareFreshStack</span>(root);</span><br><span class=\"line\">    <span class=\"comment\">// 1. 现在的 workInProgress 是新的根fiber</span></span><br><span class=\"line\">    <span class=\"title function_\">workLoopSync</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工作同步循环</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoopSync</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(workInProgress !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 2. 执行工作单元</span></span><br><span class=\"line\">        <span class=\"title function_\">performUnitOfWork</span>(workInProgress);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = unitOfWork.<span class=\"property\">alternate</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> next = <span class=\"title function_\">beginWork</span>(current, unitOfWork);</span><br><span class=\"line\"></span><br><span class=\"line\">    unitOfWork.<span class=\"property\">memoizedProps</span> = unitOfWork.<span class=\"property\">pendingProps</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 说明已经完成</span></span><br><span class=\"line\">        <span class=\"comment\">// 完成工作单元</span></span><br><span class=\"line\">        <span class=\"comment\">// completeUnitOfWork(); // 这个方法之后写 先模拟一下完成工作</span></span><br><span class=\"line\">        workInProgress = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有子节点就成为下一个工作单元</span></span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberBeginWork.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostComponent</span>, <span class=\"title class_\">HostRoot</span>, <span class=\"title class_\">HostText</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactWorkTags\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { processUpdateQueue } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberClassUpdateQueue'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 根据 `新的` 虚拟dom去构建  `新的` fiber链表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 新fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 下一个工作单元</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">beginWork</span>(<span class=\"params\">current, workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"beginWork\"</span>, workInProgress);</span><br><span class=\"line\">    <span class=\"comment\">// 判断类型不同处理方式返回子节点或者弟弟</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(workInProgress.<span class=\"property\">tag</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostRoot</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">updateHostRoot</span>(current, workInProgress);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostComponent</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">updateHostComponent</span>(current, workInProgress);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostText</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostRoot</span>(<span class=\"params\">current, workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 需要知道它的子虚拟dom, 知道它的儿子的虚拟dom信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 之前在根fiber的更新队列加的虚拟dom, 可以在这获取</span></span><br><span class=\"line\">    <span class=\"title function_\">processUpdateQueue</span>(workInProgress);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = workInProgress.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取虚拟节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextChildren = nextState.<span class=\"property\">element</span>;</span><br><span class=\"line\">    <span class=\"title function_\">reconcileChildren</span>(current, workInProgress, nextChildren);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> workInProgress.<span class=\"property\">child</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostComponents</span>(<span class=\"params\">current, workInProgress</span>) {}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"获取更新队列的虚拟dom\"><a href=\"#获取更新队列的虚拟dom\" class=\"headerlink\" title=\"获取更新队列的虚拟dom\"></a>获取更新队列的虚拟 dom</h4><p>写上一步引入的 <code>processUpdateQueue</code> 方法</p>\n<ol>\n<li>ReactFiberClassUpdateQueue.js<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { markUpdateLaneFromFiberToRoot } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberConcurrentUpdate'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initialUpdateQueue</span>(<span class=\"params\">fiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个更新队列</span></span><br><span class=\"line\">    <span class=\"comment\">// pending 是循环链表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = {</span><br><span class=\"line\">        <span class=\"attr\">shared</span>: {</span><br><span class=\"line\">            <span class=\"attr\">pending</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    fiber.<span class=\"property\">updateQueue</span> = queue;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UpdateState</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> update = {<span class=\"attr\">tag</span>: <span class=\"title class_\">UpdateState</span>};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> update;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">enqueueUpdate</span>(<span class=\"params\">fiber, update</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取根fiber的更新队列 (上一篇最后加的)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> updateQueue = fiber.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取等待执行的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pending = updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 说明初始化的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pending === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = pending.<span class=\"property\">next</span>;</span><br><span class=\"line\">        pending.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让等待更新指向当前update 开始更新</span></span><br><span class=\"line\">    updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = update;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从当前的fiber 到返回找到并返回根节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(fiber);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老状态和更新队列的更新计算最新的状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 要计算的fiber</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">processUpdateQueue</span>(<span class=\"params\">workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 拿到更新队列</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = workInProgress.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 等待生效的队列</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pendingQueue = queue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有更新, 或者更新队列里有内容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pendingQueue !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 清除等待生效的更新 因为在这就要使用了可以清除了</span></span><br><span class=\"line\">        queue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取最后一个等待生效的更新 </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lastPendingUpdate = pendingQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个等待生效的更新</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> firstPendingUpdate = pendingQueue.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 把更新链表剪开, 变成单向链表</span></span><br><span class=\"line\">        lastPendingUpdate.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取老状态 (会不停更新和计算赋值新状态, 所以起名newState)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newState = workInProgress.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> update = firstPendingUpdate;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(update) {</span><br><span class=\"line\">            <span class=\"comment\">// 根据老状态和更新计算新状态</span></span><br><span class=\"line\">            newState = <span class=\"title function_\">getStateFromUpdate</span>(update, newState);</span><br><span class=\"line\">            update = update.<span class=\"property\">next</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把最终计算到的状态赋值给 memoizedState</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">memoizedState</span> = newState;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老状态和更新, 计算新状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} update 更新</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} prevState 上一个状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 新状态</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getStateFromUpdate</span>(<span class=\"params\">update, prevState</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(update.<span class=\"property\">tag</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">UpdateState</span>:</span><br><span class=\"line\">            <span class=\"keyword\">const</span> { payload } = update;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">assign</span>({}, prevState, payload);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"根据子虚拟dom创建子fiber节点\"><a href=\"#根据子虚拟dom创建子fiber节点\" class=\"headerlink\" title=\"根据子虚拟dom创建子fiber节点\"></a>根据子虚拟 dom 创建子 fiber 节点</h4><p>上上步还有一个 <code>reconcileChildren</code> 没有定义</p>\n<ol>\n<li><p>ReactFiberBeginWork.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { mountChildFibers, reconcileChildFibers } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactChildFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据新的虚拟dom生成新的fiber链表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老的父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 新的父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} nextChildren 新的子虚拟dom</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">current, workInProgress, nextChildren</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 如果此新fiber没有老fiber, 说明是新创建的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 挂在子fiber</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">child</span> = <span class=\"title function_\">mountChildFibers</span>(workInProgress, <span class=\"literal\">null</span>, next);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 更新:  协调子fiber列表 需要做DOM-DIFF   (初始化时的根fiber是有老fiber的(一开始创建的))</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">child</span> = <span class=\"title function_\">reconcileChildFibers</span>(</span><br><span class=\"line\">        workInProgress,</span><br><span class=\"line\">        current.<span class=\"property\">child</span>,</span><br><span class=\"line\">        nextChildren</span><br><span class=\"line\">        );</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactChildFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createFiberFromElement } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiber'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> } <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/ReactSymbols'</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} shouldTrackSideEffect 是否跟踪副作用</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createChildReconciler</span>(<span class=\"params\">shouldTrackSideEffect</span>) {</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileSingElement</span>(<span class=\"params\">returnFiber, currentFirstFiber, element</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 因为我们实现的是初次挂载, 老节点currentFirstFiber是没有的, </span></span><br><span class=\"line\">        <span class=\"comment\">// 所以可以直接根据虚拟dom创建fiber节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> created = <span class=\"title function_\">createFiberFromElement</span>(element);</span><br><span class=\"line\">        created.<span class=\"property\">return</span> = returnFiber;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> created;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较子fiber  (DOM-DIFF) 就是用老的fiber链表和新的虚拟dom进行比较</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} returnFiber 新父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} currentFirstFiber 当前的第一个子fiber(老fiber的第一个儿子)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} newChild 新的子虚拟dom</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildFibers</span>(<span class=\"params\">returnFiber, currentFirstFiber, newChild</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 现在暂时只考虑新的节点只有一个的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> newChild === <span class=\"string\">'object'</span> &amp;&amp; newChild !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (newChild.<span class=\"property\">$$typeof</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"attr\">REACT_ELEMENT_TYPE</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"title function_\">reconcileSingElement</span>(</span><br><span class=\"line\">                        returnFiber,</span><br><span class=\"line\">                        currentFirstFiber,</span><br><span class=\"line\">                        newChild</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                <span class=\"attr\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reconcileChildFibers;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有老父fiber 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> reconcileChildFibers = <span class=\"title function_\">createChildReconciler</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 没有老的父fiber 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mountChildFibers = <span class=\"title function_\">createChildReconciler</span>(<span class=\"literal\">false</span>);</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberFromElement</span>(<span class=\"params\">element</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> type = element.<span class=\"property\">type</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = element.<span class=\"property\">key</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pendingProps = element.<span class=\"property\">props</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fiber = <span class=\"title function_\">createFiberFromTypeAndProps</span>(</span><br><span class=\"line\">        type,</span><br><span class=\"line\">        key,</span><br><span class=\"line\">        pendingProps</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberFromTypeAndProps</span>(<span class=\"params\">type, key, pendingProps</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fiberTag = <span class=\"title class_\">IndeterminateComponent</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fiber = <span class=\"title function_\">createFiberNode</span>(fiberTag, pendingProps, key);</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> = type;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"完成工作单元\"><a href=\"#完成工作单元\" class=\"headerlink\" title=\"完成工作单元\"></a>完成工作单元</h3><ol>\n<li>ReactFiberWorkLoop.js<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">completeUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 说明已经完成</span></span><br><span class=\"line\">    <span class=\"comment\">// 完成工作单元</span></span><br><span class=\"line\">    + <span class=\"title function_\">completeUnitOfWork</span>(unitOfWork); <span class=\"comment\">// 这个方法之后写 先模拟一下完成工作</span></span><br><span class=\"line\">        <span class=\"comment\">// workInProgress = null;</span></span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有子节点就成为下一个工作单元</span></span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">completeUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> completeWork = unitOfWork;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 拿到他的父节点和当前节点RootFiber</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = completeWork.<span class=\"property\">alternate</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> returnFiber = completeWork.<span class=\"property\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> next = <span class=\"title function_\">completeWork</span>(current, completeWork);</span><br><span class=\"line\">        <span class=\"comment\">// 如果下一个节点不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> siblingFiber = completeWork.<span class=\"property\">sibling</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果兄弟节点不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siblingFiber !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = siblingFiber;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 返回父节点</span></span><br><span class=\"line\">        completeWork = returnFiber;</span><br><span class=\"line\"></span><br><span class=\"line\">    } <span class=\"keyword\">while</span>(completeWork !== <span class=\"literal\">null</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n","categories":["React"],"tags":["前端","JavaScript","react","JSX"]},{"title":"对象属性只读（递归）DeepReadonly","url":"//typescript/questions/DeepReadonly.html","content":"<p>实现一个泛型 <code>DeepReadonly&lt;T&gt;</code>，它将对象的每个参数及其子对象递归地设为只读。</p>\n<p>您可以假设在此挑战中我们仅处理对象。不考虑数组、函数、类等。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X = { </span><br><span class=\"line\">    <span class=\"attr\">x</span>: { </span><br><span class=\"line\">        <span class=\"attr\">a</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">b</span>: <span class=\"string\">'hi'</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"string\">'hey'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Expected</span> = { </span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">x</span>: { </span><br><span class=\"line\">        <span class=\"keyword\">readonly</span> <span class=\"attr\">a</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">readonly</span> <span class=\"attr\">b</span>: <span class=\"string\">'hi'</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">y</span>: <span class=\"string\">'hey'</span> </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Todo</span> = <span class=\"title class_\">DeepReadonly</span>&lt;X&gt; <span class=\"comment\">// should be same as `Expected`</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><ol>\n<li>属于基础类型则直接返回</li>\n<li>数组、Map、Set 需要拆分其内容属性 </li>\n</ol>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Primitive</span> = <span class=\"literal\">undefined</span> | <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> | <span class=\"built_in\">boolean</span> | <span class=\"built_in\">number</span> | <span class=\"title class_\">Function</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DeepReadonly</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"title class_\">Primitive</span></span><br><span class=\"line\">    ? T</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Array</span>&lt;infer U&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;T&gt;&gt;</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;infer K, infer V&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlyMap</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;K&gt;, <span class=\"title class_\">DeepReadonly</span>&lt;V&gt;&gt;</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Set</span>&lt;infer U&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlySet</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;U&gt;&gt;</span><br><span class=\"line\">    : { <span class=\"keyword\">readonly</span> [K <span class=\"keyword\">in</span> keyof T]: <span class=\"title class_\">DeepReadonly</span>&lt;T[K]&gt; };</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"获取只读属性 GetReadonlyKeys","url":"//typescript/questions/GetReadonlyKeys.html","content":"<p>实现泛型 <code>GetReadonlyKeys&lt;T&gt;</code>，<code>GetReadonlyKeys&lt;T&gt;</code> 返回由对象 T 所有只读属性的键组成的联合类型。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Keys</span> = <span class=\"title class_\">GetReadonlyKeys</span>&lt;<span class=\"title class_\">Todo</span>&gt; <span class=\"comment\">// expected to be \"title\" | \"description\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><ol>\n<li>映射类型：</li>\n</ol>\n<ul>\n<li>使用了映射类型语法 <code>[P in keyof T]</code>，遍历 <code>T</code> 类型的所有键（包括公共和私有属性以及方法）。</li>\n</ul>\n<ol start=\"2\">\n<li>条件类型与函数类型比较：</li>\n</ol>\n<ul>\n<li>对于每个键 <code>P</code>，创建一个返回值为布尔类型的匿名函数类型 <code>&lt;I&gt;() =&gt; ...</code>。</li>\n<li>第一个函数类型检查是否有一个对象类型，其具有属性 <code>I</code> 等于 <code>T[P]</code> 的类型，这实际上是为了确保当前键 <code>P</code> 的存在性。</li>\n<li>第二个函数类型则检查是否有只读版本的对象类型，其中属性 I 是只读的且类型为 <code>T[P]</code>。</li>\n</ul>\n<ol start=\"3\">\n<li>条件判断：</li>\n</ol>\n<ul>\n<li>判断第一个函数类型是否能赋值给第二个函数类型，即判断 <code>T[P]</code> 是否是一个只读属性。</li>\n<li>如果是，则结果为 <code>P</code>，表示该键 <code>P</code> 是只读属性。</li>\n<li>否则，结果为 <code>never</code>，表示该键不是只读属性。</li>\n</ul>\n<ol start=\"4\">\n<li>取可读属性键集合：</li>\n</ol>\n<ul>\n<li>最终通过 <code>keyof</code> 运算符从映射类型中提取所有满足上述条件（即为只读属性）的键 <code>P</code> 构成的联合类型。</li>\n</ul>\n<ol start=\"5\">\n<li>默认值 <code>never</code>：</li>\n</ol>\n<ul>\n<li>如果没有符合条件的只读属性，则整个映射类型的结果是空对象类型，因此 <code>keyof {}</code> 将得到 <code>never</code> 类型。</li>\n</ul>\n<p>综上所述，<code>GetReadonlyKeys&lt;T&gt;</code> 类型会返回 T 中所有声明为只读属性的键名组成的联合类型。如果 <code>T</code> 没有只读属性，则返回类型为 <code>never</code>。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GetReadonlyKeys</span>&lt;T&gt; = keyof {</span><br><span class=\"line\">    [</span><br><span class=\"line\">        P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> (</span><br><span class=\"line\">            &lt;I&gt;<span class=\"function\">() =&gt;</span> I <span class=\"keyword\">extends</span> ({ [I <span class=\"keyword\">in</span> P]: T[I] }) ? <span class=\"literal\">true</span> : <span class=\"built_in\">never</span></span><br><span class=\"line\">        ) <span class=\"keyword\">extends</span> (</span><br><span class=\"line\">            &lt;I&gt;<span class=\"function\">() =&gt;</span> I <span class=\"keyword\">extends</span> ({ <span class=\"keyword\">readonly</span> [I <span class=\"keyword\">in</span> P]: T[I] }) ? <span class=\"literal\">true</span> : <span class=\"built_in\">never</span></span><br><span class=\"line\">        ) ? P : <span class=\"built_in\">never</span></span><br><span class=\"line\">    ] : <span class=\"built_in\">never</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 Pick","url":"//typescript/questions/pick.html","content":"<p>不使用 <code>Pick&lt;T, K&gt;</code> ，实现 TS 内置的 <code>Pick&lt;T, K&gt;</code> 的功能</p>\n<p><strong>从类型 <code>T</code> 中选出符合 <code>K</code> 的属性，构造一个新的类型</strong>。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">MyPick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'title'</span> | <span class=\"string\">'completed'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Clean room'</span>,</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 1. K extends keyof T, K继承所有的T的key属性为type</span></span><br><span class=\"line\"><span class=\"comment\">// 2. P in keyof T 拿出所有的key，在extends K，如果是true，则返回 P</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyPick</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">[P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> K ? P : <span class=\"built_in\">never</span>]: T[P];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreviewMy</span> = <span class=\"title class_\">MyPick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">\"title\"</span> | <span class=\"string\">\"completed\"</span>&gt;;</span><br><span class=\"line\"><span class=\"comment\">// type TodoPreviewMy = {</span></span><br><span class=\"line\"><span class=\"comment\">//     title: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     completed: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">// }</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreviewMy</span> = {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">\"Clean room\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 Omit","url":"//typescript/questions/omit.html","content":"<p>不使用 <code>Omit</code> 实现 <code>TypeScript</code> 的 <code>Omit&lt;T, K&gt;</code> 泛型。</p>\n<p><code>Omit</code> 会创建一个省略 <code>K</code> 中字段的 <code>T</code> 对象。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">MyOmit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'description'</span> | <span class=\"string\">'title'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = {</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> K ? <span class=\"built_in\">never</span> : P]: T[P];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @ts-expect-error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> error = <span class=\"title class_\">MyOmit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">\"description\"</span> | <span class=\"string\">\"invalid\"</span>&gt;;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"对象属性只读 Readonly","url":"//typescript/questions/Readonly.html","content":"<p>不要使用内置的 <code>Readonly&lt;T&gt;</code>，自己实现一个。</p>\n<p>泛型 <code>Readonly&lt;T&gt;</code> 会接收一个 _泛型参数_，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。</p>\n<p>也就是不可以再对该对象的属性赋值。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">MyReadonly</span>&lt;<span class=\"title class_\">Todo</span>&gt; = {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">\"Hey\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">\"foobar\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">\"Hello\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">description</span> = <span class=\"string\">\"barFoo\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReadonly</span>&lt;T&gt; = {</span><br><span class=\"line\"><span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"对象部分属性只读 Readonly","url":"//typescript/questions/Readonly2.html","content":"<p>实现一个泛型 <code>MyReadonly2&lt;T, K&gt;</code>，它带有两种类型的参数 <code>T</code> 和 <code>K</code>。</p>\n<p>类型 <code>K</code> 指定 <code>T</code> 中要被设置为只读 (readonly) 的属性。如果未提供 <code>K</code>，则应使所有属性都变为只读，就像普通的 <code>Readonly&lt;T&gt;</code> 一样。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">MyReadonly2</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'title'</span> | <span class=\"string\">'description'</span>&gt; = {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"string\">\"Hey\"</span>,</span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"string\">\"foobar\"</span>,</span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">\"Hello\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">description</span> = <span class=\"string\">\"barFoo\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">completed</span> = <span class=\"literal\">true</span> <span class=\"comment\">// OK</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>先取出需要 <code>readonly</code> 参数，然后在把不需要声明的参数用排除法加上。 </p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReadonly2</span>&lt;T, D <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> D]: T[P];</span><br><span class=\"line\">} &amp; {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> D ? <span class=\"built_in\">never</span> : P]: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 ReturnType","url":"//typescript/questions/returntype.html","content":"<p>不使用 <code>ReturnType</code> 实现 TypeScript 的 <code>ReturnType&lt;T&gt;</code> 泛型。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> a = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn&gt; <span class=\"comment\">// 应推导出 \"1 | 2\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReturnType</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; infer R</span><br><span class=\"line\">? R</span><br><span class=\"line\">: <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span></span>) =&gt; (v ? <span class=\"number\">1</span> : <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn1</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span>, w: <span class=\"built_in\">any</span></span>) =&gt; (v ? <span class=\"number\">1</span> : <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType1 = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ComplexObject</span> = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: [<span class=\"number\">12</span>, <span class=\"string\">\"foo\"</span>];</span><br><span class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    <span class=\"title function_\">prev</span>(): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType2 = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"title class_\">ComplexObject</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现类似 Vue 的类型支持的简化版本","url":"//typescript/questions/SimpleVue.html","content":"<p>实现类似 Vue 的类型支持的简化版本。</p>\n<p>通过提供一个函数 <code>SimpleVue</code>（类似于 <code>Vue.extend</code> 或 <code>defineComponent</code>），它应该正确地推断出 computed 和 methods 内部的 <code>this</code> 类型。</p>\n<p>在此挑战中，我们假设 <code>SimpleVue</code> 接受只带有 <code>data</code>，<code>computed</code> 和 <code>methods</code> 字段的 Object 作为其唯一的参数，</p>\n<ul>\n<li><p><code>data</code> 是一个简单的函数，它返回一个提供上下文 <code>this</code> 的对象，但是你无法在 <code>data</code> 中获取其他的计算属性或方法。</p>\n</li>\n<li><p><code>computed</code> 是将 <code>this</code> 作为上下文的函数的对象，进行一些计算并返回结果。在上下文中应暴露计算出的值而不是函数。</p>\n</li>\n<li><p><code>methods</code> 是函数的对象，其上下文也为 <code>this</code>。函数中可以访问 <code>data</code>，<code>computed</code> 以及其他 <code>methods</code> 中的暴露的字段。 <code>computed</code> 与 <code>methods</code> 的不同之处在于 <code>methods</code> 在上下文中按原样暴露为函数。</p>\n</li>\n</ul>\n<p><code>SimpleVue</code> 的返回值类型可以是任意的。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> instance = <span class=\"title class_\">SimpleVue</span>({</span><br><span class=\"line\">  <span class=\"title function_\">data</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">      <span class=\"attr\">firstname</span>: <span class=\"string\">'Type'</span>,</span><br><span class=\"line\">      <span class=\"attr\">lastname</span>: <span class=\"string\">'Challenges'</span>,</span><br><span class=\"line\">      <span class=\"attr\">amount</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: {</span><br><span class=\"line\">    <span class=\"title function_\">fullname</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">firstname</span> + <span class=\"string\">' '</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">lastname</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: {</span><br><span class=\"line\">    <span class=\"title function_\">hi</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">fullname</span>.<span class=\"title function_\">toLowerCase</span>())</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DataType</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> { <span class=\"title function_\">data</span>(): infer D } ? D : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ComputedType</span>&lt;T, D&gt; = T <span class=\"keyword\">extends</span> { <span class=\"attr\">computed</span>: infer C }</span><br><span class=\"line\">? {</span><br><span class=\"line\">    [K <span class=\"keyword\">in</span> keyof C]: C[K] <span class=\"keyword\">extends</span> (<span class=\"attr\">this</span>: D) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">: {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MethodsType</span>&lt;T, D, C&gt; = T <span class=\"keyword\">extends</span> { <span class=\"attr\">methods</span>: infer M }</span><br><span class=\"line\">? {</span><br><span class=\"line\">    [K <span class=\"keyword\">in</span> keyof M]: M[K] <span class=\"keyword\">extends</span> (<span class=\"attr\">this</span>: D &amp; C) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">: {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title class_\">SimpleVue</span>&lt;T&gt;(<span class=\"attr\">options</span>: T): {</span><br><span class=\"line\"><span class=\"attr\">data</span>: <span class=\"title class_\">DataType</span>&lt;T&gt;;</span><br><span class=\"line\"><span class=\"attr\">computed</span>: <span class=\"title class_\">ComputedType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">methods</span>: <span class=\"title class_\">MethodsType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;, <span class=\"title class_\">ComputedType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;&gt;&gt;;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"type 的使用","url":"//typescript/use/type.html","content":"<h4 id=\"type-的使用\"><a href=\"#type-的使用\" class=\"headerlink\" title=\"type 的使用\"></a>type 的使用</h4><p>作用：给已有类型取别名 和 定义一个新的类型 (搭配联合类型使用)</p>\n<h5 id=\"1-类型别名\"><a href=\"#1-类型别名\" class=\"headerlink\" title=\"1. 类型别名\"></a>1. 类型别名</h5><p><strong>语法 :</strong> <code>type 别名 = 类型</code></p>\n<p><strong>实例 :</strong></p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">St</span> = <span class=\"built_in\">string</span> <span class=\"comment\">// 定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str1</span>:<span class=\"title class_\">St</span> = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str2</span>:<span class=\"built_in\">string</span> = <span class=\"string\">'abc'</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"2-自定义类型\"><a href=\"#2-自定义类型\" class=\"headerlink\" title=\"2.自定义类型\"></a>2. 自定义类型</h5><p><strong>语法 :</strong> <code>type 别名 = 类型 | 类型1 | 类型2</code></p>\n<p><strong>实例 :</strong></p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NewType</span> = <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> <span class=\"comment\">// 定义类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"title class_\">NewType</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>: <span class=\"title class_\">NewType</span> = <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"3-泛型定义\"><a href=\"#3-泛型定义\" class=\"headerlink\" title=\"3.泛型定义\"></a>3. 泛型定义</h5><p><strong>语法</strong>： <code>type 别名&lt;T&gt; = 类型&lt;T&gt; | 类型1&lt;T&gt; | 类型2&lt;T&gt;</code></p>\n<p><strong>实例</strong> :</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NewType</span>&lt;T&gt; = {</span><br><span class=\"line\">   <span class=\"attr\">name</span>: T</span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">let</span> a : <span class=\"title class_\">NewType</span>&lt;<span class=\"built_in\">number</span>&gt; = { <span class=\"attr\">name</span>: <span class=\"number\">0</span> }</span><br><span class=\"line\"> <span class=\"keyword\">let</span> b : <span class=\"title class_\">NewType</span>&lt;<span class=\"built_in\">string</span>&gt; = { <span class=\"attr\">name</span>: <span class=\"string\">'0'</span> }</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h5 id=\"4-联合类型-相当于继承类型\"><a href=\"#4-联合类型-相当于继承类型\" class=\"headerlink\" title=\"4.联合类型(相当于继承类型)\"></a>4. 联合类型 (相当于继承类型)</h5><p><strong>语法</strong>：<code>type 别名 = 类型 &amp; 类型1 &amp; 类型2</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Job</span> = {</span><br><span class=\"line\">    <span class=\"attr\">jobs</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInfo</span> = <span class=\"title class_\">User</span> &amp; <span class=\"title class_\">Job</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>","categories":["前端","TypeScript"],"tags":["前端","TypeScript"]},{"title":"什么是 CSRF 攻击？","url":"//web/cross/site/request/forgeries.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>CSRF（Cross-Site Request Forgeries） 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>\n<p>CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>常见的 CSRF 攻击有三种：</p>\n<ul>\n<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交；</li>\n<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>\n<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>\n</ul>\n<h5 id=\"如何防御-CSRF-攻击？\"><a href=\"#如何防御-CSRF-攻击？\" class=\"headerlink\" title=\"如何防御 CSRF 攻击？\"></a>如何防御 CSRF 攻击？</h5><p>CSRF 攻击可以使用以下方法来防护：</p>\n<p>进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</p>\n<p>使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token，当网站再次发起请求时，在请求参数中加入服务器端返回的 token，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。</p>\n<p>还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</p>\n<p>对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>\n<p>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","CSRF"]},{"title":"什么是 XSS 攻击？","url":"//web/cross/site/script.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>\n<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>\n<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>\n<ol>\n<li>获取页面的数据，如 DOM、cookie、localStorage；</li>\n<li>DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>\n<li>破坏页面结构；</li>\n<li>流量劫持（将链接指向某网站）</li>\n</ol>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>XSS 可以分为存储型、反射型和 DOM 型：</p>\n<ul>\n<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>\n<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</li>\n<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>\n</ul>\n<h6 id=\"存储型-XSS-的攻击步骤：\"><a href=\"#存储型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"存储型 XSS 的攻击步骤：\"></a>存储型 XSS 的攻击步骤：</h6><ol>\n<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>\n<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。<br>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</li>\n</ol>\n<h6 id=\"反射型-XSS-的攻击步骤：\"><a href=\"#反射型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"反射型 XSS 的攻击步骤：\"></a>反射型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>\n<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>\n</li>\n</ol>\n<h6 id=\"DOM-型-XSS-的攻击步骤：\"><a href=\"#DOM-型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"DOM 型 XSS 的攻击步骤：\"></a>DOM 型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p><strong>DOM 型 XSS 跟前两种 XSS 的区别</strong>：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>\n</li>\n</ol>\n<h5 id=\"如何防御-XSS-攻击？\"><a href=\"#如何防御-XSS-攻击？\" class=\"headerlink\" title=\"如何防御 XSS 攻击？\"></a>如何防御 XSS 攻击？</h5><p>可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，具体措施如下：</p>\n<p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>\n<p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>\n<ol>\n<li><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p>\n</li>\n<li><p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;metahttp-equiv=”Content-Security-Policy”&gt;<br>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p>\n</li>\n</ol>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","XSS"]},{"title":"有哪些可能引起前端安全的问题？","url":"//web/security/question.html","content":"<h5 id=\"跨站脚本-Cross-Site-Scripting-XSS\"><a href=\"#跨站脚本-Cross-Site-Scripting-XSS\" class=\"headerlink\" title=\"跨站脚本 (Cross-Site Scripting, XSS)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDkwMTkxL2FydGljbGUvZGV0YWlscy8xMzIyMTIyNjY=\">跨站脚本 (Cross-Site Scripting, XSS)<i class=\"fa fa-external-link-alt\"></i></span></h5><p>⼀种代码注⼊⽅式，为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛，起因是⽹站没有对⽤户的输⼊进⾏严格的限制，使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯，其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</p>\n<h5 id=\"iframe-的滥⽤\"><a href=\"#iframe-的滥⽤\" class=\"headerlink\" title=\"iframe 的滥⽤\"></a>iframe 的滥⽤</h5><p>iframe 中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端⽤户体验；</p>\n<h5 id=\"跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\"><a href=\"#跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\" class=\"headerlink\" title=\"跨站点请求伪造（Cross-Site Request Forgeries，CSRF）\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDkwMTkxL2FydGljbGUvZGV0YWlscy8xMzIyMjA1Mzg=\">跨站点请求伪造（Cross-Site Request Forgeries，CSRF）<i class=\"fa fa-external-link-alt\"></i></span></h5><p>指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击恶意</p>\n<h5 id=\"第三⽅库\"><a href=\"#第三⽅库\" class=\"headerlink\" title=\"第三⽅库\"></a>第三⽅库</h5><p>⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全"]},{"title":"如何对项目中的图片进行优化？","url":"//web/image/perform.html","content":"<h5 id=\"优化步骤方案\"><a href=\"#优化步骤方案\" class=\"headerlink\" title=\"优化步骤方案\"></a>优化步骤方案</h5><ol>\n<li><p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片<br>完全可以用 CSS 去代替。</p>\n</li>\n<li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪<br>费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然<br>后去请求相应裁剪好的图片。</p>\n</li>\n<li><p>小图使用 base64 格式</p>\n</li>\n<li><p>将多个图标文件整合到一张图片中（雪碧图）</p>\n</li>\n<li><p>选择正确的图片格式：</p>\n<ul>\n<li><p>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</p>\n</li>\n<li><p>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</p>\n</li>\n<li><p>照片使用 JPEG</p>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"常见的图片格式及使用场景\"><a href=\"#常见的图片格式及使用场景\" class=\"headerlink\" title=\"常见的图片格式及使用场景\"></a>常见的图片格式及使用场景</h5><ol>\n<li><p>BMP：是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。</p>\n</li>\n<li><p>GIF：是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行<br>编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画<br>以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格<br>式适用于对色彩要求不高同时需要文件体积较小的场景。</p>\n</li>\n<li><p>JPEG：是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF 更大。</p>\n</li>\n<li><p>PNG-8：是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。</p>\n</li>\n<li><p>PNG-24：是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。</p>\n</li>\n<li><p>SVG 是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。这意味着 SVG 图片在放大时，不会失真，所以它非常适合用来绘制 Logo、Icon 等。</p>\n</li>\n<li><p>WebP：是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。</p>\n</li>\n</ol>\n<p>在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小 26%；<br>在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%；</p>\n<p>WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22% 的格外文件大小。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","图片"]},{"title":"前端懒加载是什么？","url":"//web/lazy/loading.html","content":"<h5 id=\"懒加载的概念\"><a href=\"#懒加载的概念\" class=\"headerlink\" title=\"懒加载的概念\"></a>懒加载的概念</h5><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。<br>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>\n<h5 id=\"懒加载的特点\"><a href=\"#懒加载的特点\" class=\"headerlink\" title=\"懒加载的特点\"></a>懒加载的特点</h5><ul>\n<li>减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li>\n<li>提升用户体验：如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li>\n<li>防止加载过多图片而影响其他资源文件的加载：会影响网站应用的正常使用。</li>\n</ul>\n<h5 id=\"懒加载的实现原理\"><a href=\"#懒加载的实现原理\" class=\"headerlink\" title=\"懒加载的实现原理\"></a>懒加载的实现原理</h5><p>图片的加载是由 src 引起的，当对 src 赋值时，浏览器就会请求图片资源。根据这个原理，我们使用 HTML5 的 data-xxx 属性来储存图片的路径，在需要加载图片的时候，将 data-xxx 中图片的路径赋值给 src，这样就实现了图片的按需加载，即懒加载。</p>\n<p><strong>注意</strong>：data-xxx 中的 xxx 可以自定义，这里我们使用 data-src 来定义。</p>\n<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>\n<p>使用原生 JavaScript 实现懒加载：</p>\n<p><strong>知识点</strong>：</p>\n<p>window.innerHeight 是浏览器可视区的高度</p>\n<p>document.body.scrollTop</p>\n<p>document.documentElement.scrollTop 是浏览器滚动的过的距离</p>\n<p>imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>\n<p>图片加载条件 ： img.offsetTop &lt; window.innerHeight+document.body.scrollTop;</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6533ccf1c458853aef92497a.png\" alt=\"在这里插入图片描述\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'container'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> imgs = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'img'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">lazyLoad</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> scrollTop = <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> winHeight = <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imgs.<span class=\"property\">lenght</span>; i++) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">if</span>(imgs[i].<span class=\"property\">offsetTop</span> &lt; scrollTop + winHeight) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">                imgs[i].<span class=\"property\">src</span> = imgs[i].<span class=\"title function_\">getAttribute</span>(<span class=\"string\">'data-src'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onsrcoll</span> = <span class=\"title function_\">lazyLoad</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"节流和防抖","url":"//web/lodash/dubounce.html","content":"<h4 id=\"对节流与防抖的理解\"><a href=\"#对节流与防抖的理解\" class=\"headerlink\" title=\"对节流与防抖的理解\"></a>对节流与防抖的理解</h4><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件<br>又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因<br>为用户的多次点击向后端发送多次请求。<br>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发<br>事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只<br>有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件<br>节流来降低事件调用的频率。</p>\n<p>防抖函数的应用场景：</p>\n<ul>\n<li>按钮提交场景：防止多次提交按钮，只执行最后一次提交</li>\n<li>服务端验证场景： 表达验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有索联想词功能类似生存环境可以使用 lodash.debounce</li>\n</ul>\n<p>节流函数的适用场景：</p>\n<ul>\n<li>拖拽场景：固定实际内只执行一次，防止超高频次触发位置变动</li>\n<li>缩放场景：监控浏览器 resize</li>\n<li> 动画场景：避免短时间内多次触发动画引起性能问题</li>\n</ul>\n<h4 id=\"实现节流函数和防抖函数\"><a href=\"#实现节流函数和防抖函数\" class=\"headerlink\" title=\"实现节流函数和防抖函数\"></a>实现节流函数和防抖函数</h4><h5 id=\"函数防抖的实现\"><a href=\"#函数防抖的实现\" class=\"headerlink\" title=\"函数防抖的实现\"></a>函数防抖的实现</h5><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, wait</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>, args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 如果此时存在定时器则取消之前的定时器重新计时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timer) {</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        }, wait);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"函数节流的实现\"><a href=\"#函数节流的实现\" class=\"headerlink\" title=\"函数节流的实现\"></a>函数节流的实现</h5><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 时间戳版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fn, delay</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>],</span><br><span class=\"line\">        nowTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nowTime - preTime &gt;= delay) {</span><br><span class=\"line\">            preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fu, wait</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!timer) {</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">                fu.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">                <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            }, wait);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"浅谈回流与重绘","url":"//web/reflux/and/redrawing.html","content":"<h5 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h5><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。<br>下面这些操作会导致回流：</p>\n<ul>\n<li>页面的首次渲染</li>\n<li>浏览器的窗口大小发生变化</li>\n<li>元素的内容发生变化</li>\n<li>元素的尺寸或者位置发生变化</li>\n<li>元素的字体大小发生变化</li>\n<li>激活 CSS 伪类</li>\n<li>查询某些属性或者调用某些方法</li>\n<li>添加或者删除可见的 DOM 元素</li>\n</ul>\n<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的 DOM 元素重新排列，它的影响范围有两种：<br>全局范围：从根节点开始，对整个渲染树进行重新布局<br>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</p>\n<h5 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h5><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。</p>\n<p>下面这些操作会导致重绘：<br>color、background 相关属性：background-color、background-image 等<br>outline 相 关 属 性 ： outline-color 、outline-width、text-decoration<br>border-radius、visibility、box-shadow</p>\n<p>注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</p>\n<h5 id=\"如何避免回流与重绘？\"><a href=\"#如何避免回流与重绘？\" class=\"headerlink\" title=\"如何避免回流与重绘？\"></a>如何避免回流与重绘？</h5><p>减少回流与重绘的措施：</p>\n<p>操作 DOM 时，尽量在低层级的 DOM 节点进行操作不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新布局</p>\n<p>使用 CSS 的表达式</p>\n<p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>\n<p>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>\n<p>避免频繁操作 DOM，可以创建一个文档片段 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</p>\n<p>将元素先设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</p>\n<p>浏览器针对页面的回流与重绘，进行了自身的优化 —— 渲染队列浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>\n<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"如何⽤ webpack 来优化前端性能？","url":"//web/webpack/perform.html","content":"<h5 id=\"如何⽤webpack-来优化前端性能？\"><a href=\"#如何⽤webpack-来优化前端性能？\" class=\"headerlink\" title=\"如何⽤webpack 来优化前端性能？\"></a>如何⽤ webpack 来优化前端性能？</h5><p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>\n<ul>\n<li>压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS ⽂件， 利⽤ cssnano （css-loader?minimize）来压缩 css；</li>\n<li>利⽤ CDN 加速：在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径；</li>\n<li>Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现；</li>\n<li>Code Splitting: 将代码按路由维度或者组件分块 (chunk), 这样做到按需加载，同时可以充分利⽤浏览器缓存；</li>\n<li>提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码。</li>\n</ul>\n<h5 id=\"如何提⾼webpack-的构建速度？\"><a href=\"#如何提⾼webpack-的构建速度？\" class=\"headerlink\" title=\"如何提⾼webpack 的构建速度？\"></a>如何提⾼ webpack 的构建速度？</h5><ol>\n<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码；</li>\n<li>通过 externals 配置来提取常⽤库；</li>\n<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来；</li>\n<li>使⽤ Happypack 实现多线程加速编译；</li>\n<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度；</li>\n<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码。</li>\n</ol>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","插件"]},{"title":"uni-app APP 更新版本提示","url":"//uni-app/vue/update.html","content":"<h3 id=\"AppUpdate-方法\"><a href=\"#AppUpdate-方法\" class=\"headerlink\" title=\"AppUpdate 方法\"></a>AppUpdate 方法</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> baseUrl <span class=\"keyword\">from</span> <span class=\"string\">'@/basecall/utils.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">AppUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> appleId = <span class=\"number\">2021004105638058</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _this = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> platform = uni.<span class=\"title function_\">getSystemInfoSync</span>().<span class=\"property\">platform</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1. 获取当前版本号</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curversion = <span class=\"number\">100</span>;</span><br><span class=\"line\">  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">getProperty</span>(plus.<span class=\"property\">runtime</span>.<span class=\"property\">appid</span>, <span class=\"keyword\">function</span> (<span class=\"params\">widgetInfo</span>) {</span><br><span class=\"line\">    curversion = widgetInfo.<span class=\"property\">version</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"当前版本\"</span>, curversion);</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    2， 用当前版本号提交给服务端，判断是否需要更新，接口返回信息如下</span></span><br><span class=\"line\"><span class=\"comment\">        versionId\t\tinteger(int64)\t</span></span><br><span class=\"line\"><span class=\"comment\">        versionId\t版本号\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        intro\t版本描述\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        forced\t是否强制更新\tboolean\t</span></span><br><span class=\"line\"><span class=\"comment\">        news\t是否是最新版本\tboolean\t</span></span><br><span class=\"line\"><span class=\"comment\">        url\tapk地址\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        createTime\t创建时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  uni.<span class=\"title function_\">request</span>({</span><br><span class=\"line\">    <span class=\"attr\">url</span>: baseUrl.<span class=\"property\">baseUrl</span> + <span class=\"string\">\"/getVersion\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">method</span>: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> { versionId, forced, url, createTime } = res.<span class=\"property\">data</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">\t  uni.<span class=\"title function_\">setStorageSync</span>(<span class=\"string\">'url'</span>, url);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> currTimeStamp = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(createTime).<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\">      <span class=\"comment\">/* 判断是否是最新版 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (versionId !== curversion) {</span><br><span class=\"line\">        <span class=\"comment\">//forced true 强制更新 false 自然更新</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (forced == <span class=\"string\">'true'</span>) {</span><br><span class=\"line\">          uni.<span class=\"title function_\">showModal</span>({</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">\"紧急升级通知\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">content</span>:</span><br><span class=\"line\">              <span class=\"string\">\"亲爱的用户，为了提供更好的使用体验与功能改进，我们进行了系统升级。请立即完成强制升级，否则将无法正常使用APP。感谢您的配合与支持！\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">confirmText</span>: <span class=\"string\">\"立即更新\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">showCancel</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (res.<span class=\"property\">confirm</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (platform == <span class=\"string\">\"ios\"</span>) {</span><br><span class=\"line\">                  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">launchApplication</span>(</span><br><span class=\"line\">                    {</span><br><span class=\"line\">                      <span class=\"attr\">action</span>: <span class=\"string\">`itms-apps://itunes.apple.com/cn/app/id<span class=\"subst\">${appleId}</span>?mt=8`</span>,</span><br><span class=\"line\">                    },</span><br><span class=\"line\">                    <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) {</span><br><span class=\"line\">                      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">                        <span class=\"string\">\"Open system default browser failed: \"</span> + e.<span class=\"property\">message</span></span><br><span class=\"line\">                      );</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                  );</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                  uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                    <span class=\"attr\">icon</span>: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">mask</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    <span class=\"attr\">title</span>: <span class=\"string\">\"有新的版本发布，程序已启动自动更新。\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">duration</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\">                  });</span><br><span class=\"line\">                  <span class=\"comment\">//设置 最新版本apk的下载链接 这是固定的</span></span><br><span class=\"line\">                  <span class=\"keyword\">let</span> downloadApkUrl = url;</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(downloadApkUrl);</span><br><span class=\"line\">                  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">openURL</span>(downloadApkUrl);</span><br><span class=\"line\">                }</span><br><span class=\"line\">              }</span><br><span class=\"line\">            },</span><br><span class=\"line\">          });</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          uni.<span class=\"title function_\">getStorage</span>({</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              <span class=\"keyword\">var</span> lastTimeStamp = res.<span class=\"property\">data</span>; <span class=\"comment\">// 本地时间戳</span></span><br><span class=\"line\">              <span class=\"keyword\">var</span> tipTimeLength = <span class=\"number\">0</span>; <span class=\"comment\">// 时间间隔</span></span><br><span class=\"line\">              <span class=\"keyword\">let</span> cha = lastTimeStamp + tipTimeLength - currTimeStamp;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (lastTimeStamp + tipTimeLength &gt; currTimeStamp) {</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"当后台时间戳大于本地时间戳才会进入\"</span>);</span><br><span class=\"line\">              } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"立即更新\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//重新设置时间戳</span></span><br><span class=\"line\">                uni.<span class=\"title function_\">setStorage</span>({</span><br><span class=\"line\">                  <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">data</span>: currTimeStamp,</span><br><span class=\"line\">                  <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"setStorage-success\"</span>);</span><br><span class=\"line\">                  },</span><br><span class=\"line\">                });</span><br><span class=\"line\"></span><br><span class=\"line\">                uni.<span class=\"title function_\">showModal</span>({</span><br><span class=\"line\">                  <span class=\"attr\">title</span>: <span class=\"string\">\"版本更新\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">content</span>:</span><br><span class=\"line\">                    <span class=\"string\">\"尊敬的用户，我们为您准备了最新的版本更新，内含诸多新功能与用户体验优化。点击立即升级，享受更多精彩和便利。\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">confirmText</span>: <span class=\"string\">\"立即更新\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">cancelText</span>: <span class=\"string\">\"取消\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (res.<span class=\"property\">confirm</span>) {</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (platform == <span class=\"string\">\"ios\"</span>) {</span><br><span class=\"line\">                        plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">launchApplication</span>(</span><br><span class=\"line\">                          {</span><br><span class=\"line\">                            <span class=\"attr\">action</span>: <span class=\"string\">`itms-apps://itunes.apple.com/cn/app/id<span class=\"subst\">${appleId}</span>?mt=8`</span>,</span><br><span class=\"line\">                          },</span><br><span class=\"line\">                          <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) {</span><br><span class=\"line\">                            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">                              <span class=\"string\">\"Open system default browser failed: \"</span> + e.<span class=\"property\">message</span></span><br><span class=\"line\">                            );</span><br><span class=\"line\">                          }</span><br><span class=\"line\">                        );</span><br><span class=\"line\">                      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                          <span class=\"attr\">icon</span>: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">                          <span class=\"attr\">mask</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                          <span class=\"attr\">title</span>: <span class=\"string\">\"有新的版本发布，程序已启动自动更新。\"</span>,</span><br><span class=\"line\">                          <span class=\"attr\">duration</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\">                        });</span><br><span class=\"line\">                        <span class=\"comment\">//设置 最新版本apk的下载链接 这是固定的 每次把包放在这个链接里里面即可 由后端制作</span></span><br><span class=\"line\">                        <span class=\"keyword\">let</span> downloadApkUrl = url;</span><br><span class=\"line\">                        plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">openURL</span>(downloadApkUrl);</span><br><span class=\"line\">                      }</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res.<span class=\"property\">cancel</span>) {</span><br><span class=\"line\">                      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"下次一定\"</span>);</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                  },</span><br><span class=\"line\">                });</span><br><span class=\"line\">              }</span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              uni.<span class=\"title function_\">setStorage</span>({</span><br><span class=\"line\">                <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">data</span>: currTimeStamp,</span><br><span class=\"line\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"setStorage-success\"</span>);</span><br><span class=\"line\">                },</span><br><span class=\"line\">              });</span><br><span class=\"line\">            },</span><br><span class=\"line\">          });</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(createTime, <span class=\"string\">\"createTimecreateTime\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">fail</span>: <span class=\"function\">() =&gt;</span> {},</span><br><span class=\"line\">    <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> {},</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"在APP-vue中注册\"><a href=\"#在APP-vue中注册\" class=\"headerlink\" title=\"在APP.vue中注册\"></a>在 APP.vue 中注册</h3><p>在 <code>App.vue</code> 中，我们需要在 <code>onLaunch</code> 生命周期函数中调用 <code>AppUpdate</code> 方法，来检查是否有新版本的 APP。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">AppUpdate</span> } <span class=\"keyword\">from</span> <span class=\"string\">'@/common/AppUpdate.js'</span>;</span><br><span class=\"line\"><span class=\"title function_\">onLaunch</span>(<span class=\"params\"></span>) {    </span><br><span class=\"line\">    <span class=\"title class_\">AppUpdate</span>()</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["uni-app","vue","AppUpdate"],"tags":["前端","uni-app","vue","AppUpdate"]},{"title":"uni-app 分享页制作","url":"//uni-app/vue/share.html","content":"<h2 id=\"uni-app-分享页制作\"><a href=\"#uni-app-分享页制作\" class=\"headerlink\" title=\"uni-app 分享页制作\"></a>uni-app 分享页制作</h2><p>通过 canvas 先制作图。可以做一个 canvas 背景在生成一个二维码 canvas 图，在将两个 canvas 合成一个图片，然后将图片分享出来。</p>\n<h3 id=\"html-模板\"><a href=\"#html-模板\" class=\"headerlink\" title=\"html 模板\"></a>html 模板</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;view class=\"content\"&gt;</span><br><span class=\"line\">        &lt;u-icon name='arrow-left' @click=\"goBack\" style=\"position: absolute; z-index: 999; top: 80rpx; left: 40rpx; font-size: 40rpx; color: #454545;\"&gt;&lt;/u-icon&gt;</span><br><span class=\"line\">        &lt;view style=\"width: 100%; height: calc(100vh - 44px);\"&gt;</span><br><span class=\"line\">            &lt;view class=\"btn-opate\" style=\"\"&gt;</span><br><span class=\"line\">                &lt;button type=\"primary\" size=\"mini\" @click=\"saveImg\"&gt;保存分享&lt;/button&gt;</span><br><span class=\"line\">                &lt;button type=\"default\" size=\"mini\" @click=\"copyCode\"&gt;复制邀请码&lt;/button&gt;</span><br><span class=\"line\">            &lt;/view&gt;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &lt;image class=\"image\" style=\"width: 100%; height: calc(100vh - 44px);\" :src=\"ImagePath\" mode=\"widthFix\"&gt;&lt;/image&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        &lt;view v-if=\"show\"&gt;</span><br><span class=\"line\">            &lt;canvas canvas-id=\"myCanvas\" style=\"width: 100vw; height: 100vh;\"&gt;&lt;/canvas&gt;</span><br><span class=\"line\">            &lt;canvas canvas-id=\"qrcode\"&gt;&lt;/canvas&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"二维码制作\"><a href=\"#二维码制作\" class=\"headerlink\" title=\"二维码制作\"></a>二维码制作</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UQRCode</span> <span class=\"keyword\">from</span> <span class=\"string\">'uqrcodejs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">qrCode</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    uni.<span class=\"title function_\">showLoading</span>({</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'分享页制作中...'</span></span><br><span class=\"line\">    })</span><br><span class=\"line\">    <span class=\"keyword\">var</span> qr = <span class=\"keyword\">new</span> <span class=\"title class_\">UQRCode</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 设置二维码内容</span></span><br><span class=\"line\">    qr.<span class=\"property\">data</span> = <span class=\"string\">`https://app.xianyuangu.com/#/pages/login/h5login?registerCode=<span class=\"subst\">${<span class=\"variable language_\">this</span>.invitationCode}</span>`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置二维码大小，必须与canvas设置的宽高一致</span></span><br><span class=\"line\">    qr.<span class=\"property\">size</span> = <span class=\"number\">120</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 调用制作二维码方法</span></span><br><span class=\"line\">    qr.<span class=\"title function_\">make</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = uni.<span class=\"title function_\">createCanvasContext</span>(<span class=\"string\">'qrcode'</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    qr.<span class=\"property\">canvasContext</span> = context;</span><br><span class=\"line\">    <span class=\"comment\">// 调用绘制方法将二维码图案绘制到canvas上</span></span><br><span class=\"line\">    qr.<span class=\"title function_\">drawCanvas</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 将canvas内容保存为图片</span></span><br><span class=\"line\">        uni.<span class=\"title function_\">canvasToTempFilePath</span>({</span><br><span class=\"line\">            <span class=\"attr\">canvasId</span>: <span class=\"string\">'qrcode'</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">qrcode</span> = res.<span class=\"property\">tempFilePath</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">drawImageToCanvas</span>();</span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    }, <span class=\"number\">1000</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">drawImageToCanvas</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取 canvas 上下文</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> systemInfo = uni.<span class=\"title function_\">getSystemInfoSync</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvasWidth = systemInfo.<span class=\"property\">windowWidth</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvasHeight = systemInfo.<span class=\"property\">windowHeight</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = uni.<span class=\"title function_\">createCanvasContext</span>(<span class=\"string\">'myCanvas'</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Step 6: 使用 drawImage 方法绘制图片</span></span><br><span class=\"line\">    context.<span class=\"title function_\">drawImage</span>(<span class=\"string\">'/static/image/share.png'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, canvasWidth, canvasHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">setFillStyle</span>(<span class=\"string\">'#D43030'</span>); <span class=\"comment\">// 黑色文本</span></span><br><span class=\"line\">    context.<span class=\"title function_\">setFontSize</span>(<span class=\"number\">32</span>); <span class=\"comment\">// 文字大小</span></span><br><span class=\"line\">    context.<span class=\"title function_\">fillText</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">invitationCode</span>, canvasWidth / <span class=\"number\">2</span> - <span class=\"number\">50</span>, canvasHeight / <span class=\"number\">2</span> * <span class=\"number\">0.84</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">drawImage</span>(</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">qrcode</span>,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">3</span> - <span class=\"number\">20</span>,</span><br><span class=\"line\">    canvasHeight / <span class=\"number\">2</span>,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">1</span> ,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">2</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">save</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Step 7: 调用 draw 方法渲染 canvas</span></span><br><span class=\"line\">    context.<span class=\"title function_\">draw</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 将canvas内容保存为图片</span></span><br><span class=\"line\">        uni.<span class=\"title function_\">canvasToTempFilePath</span>({</span><br><span class=\"line\">            <span class=\"attr\">canvasId</span>: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">show</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span> = res.<span class=\"property\">tempFilePath</span>;</span><br><span class=\"line\">            uni.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 在这里可以将得到的图片路径进行保存或分享等操作</span></span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">                uni.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }, <span class=\"number\">1000</span>));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"保存图片\"><a href=\"#保存图片\" class=\"headerlink\" title=\"保存图片\"></a>保存图片</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">env</span>: uni.<span class=\"title function_\">getSystemInfoSync</span>().<span class=\"property\">uniPlatform</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">saveImg</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"comment\">// app 保存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">env</span> == <span class=\"string\">'app'</span>) {</span><br><span class=\"line\">        uni.<span class=\"title function_\">saveImageToPhotosAlbum</span>({</span><br><span class=\"line\">            <span class=\"attr\">filePath</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">                uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                    <span class=\"attr\">title</span>: <span class=\"string\">'保存成功'</span>,</span><br><span class=\"line\">                })</span><br><span class=\"line\">            }</span><br><span class=\"line\">        });</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">/** 生成一个a元素,并创建一个单击事件 */</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        a.<span class=\"property\">download</span> = name || <span class=\"string\">\"photo\"</span>; <span class=\"comment\">// 设置图片名称</span></span><br><span class=\"line\">        a.<span class=\"property\">href</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span>; <span class=\"comment\">// 将生成的URL设置为a.href属性</span></span><br><span class=\"line\">        a.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"myLink\"</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(a);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"链接\"</span>, a);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">exportCodeConfirm</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">},</span><br><span class=\"line\"><span class=\"title function_\">exportCodeConfirm</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> <span class=\"title class_\">MouseEvent</span>(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/** 触发a的单击事件 */</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"myLink\"</span>).<span class=\"title function_\">dispatchEvent</span>(event);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["uni-app","vue"],"tags":["前端","uni-app","vue","canvas"]},{"title":"docker-compose install","url":"//linux/install/docker-compose.html","content":"<h3 id=\"Curl-下载\"><a href=\"#Curl-下载\" class=\"headerlink\" title=\"Curl 下载\"></a>Curl 下载</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"查询版本\"><a href=\"#查询版本\" class=\"headerlink\" title=\"查询版本\"></a>查询版本</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker-compose --version</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>需要将运行 yml 命名为 docker-compose.yml</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","docker-compose"],"tags":["前端","linux","docker-compose"]},{"title":"Docker 安装 Redis","url":"//linux/docker/redis.html","content":"<h3 id=\"下载redis-镜像\"><a href=\"#下载redis-镜像\" class=\"headerlink\" title=\"下载redis 镜像\"></a>下载 redis 镜像</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull redis</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"启动镜像并同步数据\"><a href=\"#启动镜像并同步数据\" class=\"headerlink\" title=\"启动镜像并同步数据\"></a>启动镜像并同步数据</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -itd --name redis -p 6379:6379 \\</span><br><span class=\"line\"> --restart=always \\</span><br><span class=\"line\"> -v /home/xt/redis/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -v /home/xt/redis/data:/data \\</span><br><span class=\"line\"> redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"添加密码\"><a href=\"#添加密码\" class=\"headerlink\" title=\"添加密码\"></a>添加密码</h3><h4 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it 04f824eaf3800958615a9874084ea6d57ab346cd61723a1eb54074a9477f1efe /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在 Redis 命令行中，我们可以使用 config set 命令来设置 Redis 的密码。以下是设置密码的代码和注释。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">config set requirepass your_password</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"重启Redis容器\"><a href=\"#重启Redis容器\" class=\"headerlink\" title=\"重启Redis容器\"></a>重启 Redis 容器</h3><p>完成上述步骤后，我们需要重启 Redis 容器使密码生效。可以使用以下命令重启 Redis 容器。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker restart 04f824eaf3800958615a9874084ea6d57ab346cd61723a1eb54074a9477f1efe</span><br></pre></td></tr></tbody></table></figure>","categories":["linux","docker","redis"],"tags":["前端","linux","docker， redis"]},{"title":"ubantu use wechat","url":"//linux/install/wechat.html","content":"<h3 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装 Docker</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install docker.io</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"允许所有用户访问图形界面\"><a href=\"#允许所有用户访问图形界面\" class=\"headerlink\" title=\"允许所有用户访问图形界面\"></a>允许所有用户访问图形界面</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">xhost +</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意，这条命令可能会提示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">access control disabled, clients can connect from any host</span><br></pre></td></tr></tbody></table></figure>\n\n<p>看到这样的提示信息，表示命令执行成功，不是什么报错信息。</p>\n<h3 id=\"创建Docker容器\"><a href=\"#创建Docker容器\" class=\"headerlink\" title=\"创建Docker容器\"></a>创建 Docker 容器</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name wechat\\</span><br><span class=\"line\">    --device /dev/snd\\</span><br><span class=\"line\">    --ipc=host\\</span><br><span class=\"line\">    -v /tmp/.X11-unix:/tmp/.X11-unix\\</span><br><span class=\"line\">    -v /home/batype/WeChatFiles:/WeChatFiles\\</span><br><span class=\"line\">    -v /home/batype:/batype\\</span><br><span class=\"line\">    -e DISPLAY=unix$DISPLAY\\</span><br><span class=\"line\">    -e XMODIFIERS=@im=fcitx\\</span><br><span class=\"line\">    -e QT_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GTK_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GID=`id -g`\\</span><br><span class=\"line\">    -e UID=`id -u`\\</span><br><span class=\"line\">    bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意！注意！注意！上述代码不能直接使用，需要一定的修改！！！</p>\n<ul>\n<li><p>将代码中的 batype 改成自己的用户名！！！</p>\n</li>\n<li><p>如果你是 ibus 输入法，将代码中的 fcitx 改成 ibus！！！</p>\n</li>\n</ul>\n<h3 id=\"等待微信启动\"><a href=\"#等待微信启动\" class=\"headerlink\" title=\"等待微信启动\"></a>等待微信启动</h3><p>注意！！！当你执行完 docker run 之后，大约需要等待 1-2 分钟后，才会弹出微信的登录窗口。一定要有信心，有耐心，不要放弃，要耐心等待 1-2 分钟！</p>\n<p>等待完成后，即可看到微信的登录界面，扫码登录即可尽情使用！</p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"微信的字体特别小\"><a href=\"#微信的字体特别小\" class=\"headerlink\" title=\"微信的字体特别小\"></a>微信的字体特别小</h4><p>安装完 Docker 微信后，字特别小，根本看不清，太费眼睛。</p>\n<p>解决方法：</p>\n<ol>\n<li>进入容器内部 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it wechat bash</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>切换到 wechat 用户（此步骤不可省略，否则下面的步骤无法进行！！！）</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">su wechat</span><br></pre></td></tr></tbody></table></figure>\n<ol start=\"3\">\n<li>打开配置 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">WINEPREFIX=~/.deepinwine/Deepin-WeChat/ deepin-wine winecfg</span><br></pre></td></tr></tbody></table></figure>\n<ol start=\"4\">\n<li>在弹出窗口中，打开 “显示” 选项卡，找到最下面 “屏幕分辨率”，改成 200dpi 即可。</li>\n</ol>\n<h4 id=\"运行微信之后，出现一个wine-system-tray的小窗口\"><a href=\"#运行微信之后，出现一个wine-system-tray的小窗口\" class=\"headerlink\" title=\"运行微信之后，出现一个wine system tray的小窗口\"></a>运行微信之后，出现一个 wine system tray 的小窗口</h4><p>这是 wine 的系统栏，是正常现象，其实可以把那个窗口关掉，没什么影响。</p>\n<h4 id=\"我不小心把微信的窗口叉掉了，怎么办\"><a href=\"#我不小心把微信的窗口叉掉了，怎么办\" class=\"headerlink\" title=\"我不小心把微信的窗口叉掉了，怎么办\"></a>我不小心把微信的窗口叉掉了，怎么办</h4><p>执行下面命令即可：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker restart wechat -t 0</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"无法输入中文\"><a href=\"#无法输入中文\" class=\"headerlink\" title=\"无法输入中文\"></a>无法输入中文</h4><p>这是因为你使用的是 ibus 输入法，而你未将启动命令中的 ibus 改成 fcitx。</p>\n<h4 id=\"播放视频没有声音\"><a href=\"#播放视频没有声音\" class=\"headerlink\" title=\"播放视频没有声音\"></a>播放视频没有声音</h4><p>首先删掉容器</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker rm -f wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后重新运行一个</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name wechat\\</span><br><span class=\"line\">    --device /dev/snd\\</span><br><span class=\"line\">    --ipc=host\\</span><br><span class=\"line\">    -v /tmp/.X11-unix:/tmp/.X11-unix\\</span><br><span class=\"line\">    -v /home/batype/WeChatFiles:/WeChatFiles\\</span><br><span class=\"line\">    -v /home/batype:/batype\\</span><br><span class=\"line\">    -e DISPLAY=unix$DISPLAY\\</span><br><span class=\"line\">    -e XMODIFIERS=@im=fcitx\\</span><br><span class=\"line\">    -e QT_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GTK_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e AUDIO_GID=`getent group audio | cut -d: -f3`\\</span><br><span class=\"line\">    -e GID=`id -g`\\</span><br><span class=\"line\">    -e UID=`id -u`\\</span><br><span class=\"line\">    bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n<p>注意，加了这一行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">-e AUDIO_GID=`getent group audio | cut -d: -f3`\\</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这样的话，播放视频就有声音了。</p>\n","categories":["linux","wechat"],"tags":["前端","linux","wechat"]},{"title":"webpack 热更新的实现原理","url":"//web/webpack/hot/module/replacement.html","content":"<p>webpack 的热更新⼜称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。<br>原理：<br><img data-src=\"https://pic.imgdb.cn/item/65366aa5c458853aefbf449c.png\" alt=\"在这里插入图片描述\"></p>\n<p>⾸先要知道 server 端和 client 端都做了处理⼯作：</p>\n<ol>\n<li>在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li>\n<li>webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。</li>\n<li>webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。</li>\n<li>webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。</li>\n<li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏ 热 更 模 块 操 作 ， ⽽ 把 这 些 ⼯ 作⼜交回给了 webpack，webpack/hot/dev-server 的 ⼯ 作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。</li>\n<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀ 步 传 递 给 他 的 新 模 块 的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li>\n<li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。</li>\n</ol>\n<p>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</p>\n","categories":["前端","WebPack"],"tags":["前端","浏览器","WebPack"]},{"title":"nvm 管理 node 版本","url":"//web/npm/nvm.html","content":"<h4 id=\"Windows-上安装\"><a href=\"#Windows-上安装\" class=\"headerlink\" title=\"Windows 上安装\"></a>Windows 上安装</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm_github<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li>点击 “Code” 按钮，然后选择 “Download ZIP” 下载 ZIP 文件。</li>\n<li>解压缩 ZIP 文件：解压缩下载的 ZIP 文件，将解压后的文件夹放在您想要安装 NVM 的位置。</li>\n<li>配置环境变量：打开命令提示符或 PowerShell，并运行以下命令来配置 NVM 的环境变量：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">setx NVM_HOME \"解压缩文件夹的完整路径\"</span><br><span class=\"line\">setx NVM_SYMLINK \"解压缩文件夹的完整路径\"</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Linux-上安装\"><a href=\"#Linux-上安装\" class=\"headerlink\" title=\"Linux 上安装\"></a>Linux 上安装</h4><ol>\n<li>下载 NVM 安装脚本：打开终端并运行以下命令下载 NVM 安装脚本：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将从 NVM GitHub 存储库下载并运行安装脚本。</p>\n<ol start=\"2\">\n<li>配置 NVM 环境变量：安装脚本运行后，会将 NVM 相关的路径和初始化脚本添加到您的个人配置文件（如 <del>/.bashrc、</del>/.zshrc 等）。要使这些更改生效，可以运行以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果您使用的是其他 Shell，替换～/.bashrc 为您实际使用的配置文件。</p>\n<h4 id=\"验证安装\"><a href=\"#验证安装\" class=\"headerlink\" title=\"验证安装\"></a>验证安装</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm --version</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"安装node-js-版本\"><a href=\"#安装node-js-版本\" class=\"headerlink\" title=\"安装node.js 版本\"></a>安装 node.js 版本</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm install &lt;version&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>例如</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm install 16.13.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装成功后，NVM 会自动将该版本设置为默认版本。</p>\n<h4 id=\"切换版本\"><a href=\"#切换版本\" class=\"headerlink\" title=\"切换版本\"></a>切换版本</h4><p>切换 Node.js 版本：如果您有多个安装的 Node.js 版本，可以使用以下命令切换不同的版本：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use &lt;version&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>例如</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use 18.16.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将将您的当前 Shell 会话设置为使用指定的 Node.js 版本。</p>\n<h4 id=\"查询当前版本\"><a href=\"#查询当前版本\" class=\"headerlink\" title=\"查询当前版本\"></a>查询当前版本</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use node</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"查询当前node路径\"><a href=\"#查询当前node路径\" class=\"headerlink\" title=\"查询当前node路径\"></a>查询当前 node 路径</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm which 18.16.0</span><br><span class=\"line\">/Users/shaosong/.nvm/versions/node/v18.16.0/bin/node</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"listing-Version\"><a href=\"#listing-Version\" class=\"headerlink\" title=\"listing Version\"></a>listing Version</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm ls</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"设置默认version\"><a href=\"#设置默认version\" class=\"headerlink\" title=\"设置默认version\"></a>设置默认 version</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm alias default 18.16.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在，您已经在 Linux 上成功安装了 NVM。您可以使用 nvm use 命令切换不同的 Node.js 版本，并使用 node 和 npm 命令来管理您的 Node.js 环境。</p>\n","categories":["前端","npm"],"tags":["前端","npm","nvm"]},{"title":"nrm 管理 npm registry","url":"//web/npm/nrm.html","content":"<h4 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h4><p><code>npm install -g nrm</code></p>\n<h4 id=\"nrm-ls\"><a href=\"#nrm-ls\" class=\"headerlink\" title=\"nrm ls\"></a>nrm ls</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nrm ls</span><br><span class=\"line\"></span><br><span class=\"line\">npm ---------- https://registry.npmjs.org/</span><br><span class=\"line\">yarn --------- https://registry.yarnpkg.com/</span><br><span class=\"line\">tencent ------ https://mirrors.cloud.tencent.com/npm/</span><br><span class=\"line\">cnpm --------- https://r.cnpmjs.org/</span><br><span class=\"line\">taobao ------- https://registry.npmmirror.com/</span><br><span class=\"line\">npmMirror ---- https://skimdb.npmjs.com/registry/</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"nrm-use\"><a href=\"#nrm-use\" class=\"headerlink\" title=\"nrm use\"></a>nrm use</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nrm use taobao</span><br><span class=\"line\">Registry has been set to: https://registry.npmmirror.com/</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Usage: nrm [options] [command]</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">  -V, --version                           output the version number</span><br><span class=\"line\">  -h, --help                              output usage information</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">  ls                                      List all the registries</span><br><span class=\"line\">  current [options]                       Show current registry name or URL</span><br><span class=\"line\">  use &lt;registry&gt;                          Change registry to registry</span><br><span class=\"line\">  add &lt;registry&gt; &lt;url&gt; [home]             Add one custom registry</span><br><span class=\"line\">  login [options] &lt;registryName&gt; [value]  Set authorize information for a custom registry with a base64 encoded string or username and pasword</span><br><span class=\"line\">  set-hosted-repo &lt;registry&gt; &lt;value&gt;      Set hosted npm repository for a custom registry to publish packages</span><br><span class=\"line\">  set-scope &lt;scopeName&gt; &lt;value&gt;           Associating a scope with a registry</span><br><span class=\"line\">  del-scope &lt;scopeName&gt;                   Remove a scope</span><br><span class=\"line\">  set [options] &lt;registryName&gt;            Set custom registry attribute</span><br><span class=\"line\">  rename &lt;registryName&gt; &lt;newName&gt;         Set custom registry name</span><br><span class=\"line\">  del &lt;registry&gt;                          Delete one custom registry</span><br><span class=\"line\">  home &lt;registry&gt; [browser]               Open the homepage of registry with optional browser</span><br><span class=\"line\">  publish [options] [&lt;tarball&gt;|&lt;folder&gt;]  Publish package to current registry if current registry is a custom registry.</span><br><span class=\"line\">   if you're not using custom registry, this command will run npm publish directly</span><br><span class=\"line\">  test [registry]                         Show response time for specific or all registries</span><br><span class=\"line\">  help                                    Print this help </span><br><span class=\"line\">   if you want to clear the NRM configuration when uninstall you can execute \"npm uninstall nrm -g -C or npm uninstall nrm -g --clean\"</span><br></pre></td></tr></tbody></table></figure>","categories":["前端","npm"],"tags":["前端","npm","nrm"]},{"title":"unstate-next 的实现原理","url":"//react/components/unstate-next-implement.html","content":"<h4 id=\"定义实现Container接口\"><a href=\"#定义实现Container接口\" class=\"headerlink\" title=\"定义实现Container接口\"></a>定义实现 Container 接口</h4><p>需要实现包装方法和获取数据的 hooks</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"title class_\">Provider</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ComponentType</span>&lt;<span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span>&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">useContainer</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Value</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"定义实现Provider接口\"><a href=\"#定义实现Provider接口\" class=\"headerlink\" title=\"定义实现Provider接口\"></a>定义实现 Provider 接口</h4><p>定义接口需要初始化参数和需要使用的子节点。</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ContainerProviderProps 定义类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">State</span>} <span class=\"variable\">State</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">State</span>} <span class=\"variable\">initialState</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">React.ReactNode</span>} <span class=\"variable\">children</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span> = <span class=\"built_in\">any</span>&gt; {</span><br><span class=\"line\">initialState?: <span class=\"title class_\">State</span>;</span><br><span class=\"line\"><span class=\"attr\">children</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"createContainer-方法\"><a href=\"#createContainer-方法\" class=\"headerlink\" title=\"createContainer 方法\"></a>createContainer 方法</h4><p>在 <code>createContainer</code> 方法中，使用后会返回两个方法 <code>Provider</code> 和 <code>useContainer</code>。</p>\n<p>步骤：</p>\n<ol>\n<li>使用 React.createContext 创建 Context；</li>\n<li>自定义 hooks 获取属性；</li>\n<li>需要使用 Context 子组件使用 Provider 包装， 将数据写入 Context；</li>\n<li>使用 React.useContext 从 Context 中获取属性 </li>\n</ol>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> createContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">useHook</span>: <span class=\"function\">(<span class=\"params\">initialState?: State</span>) =&gt;</span> <span class=\"title class_\">Value</span></span><br><span class=\"line\">): <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"comment\">// 使用React.createContext 创建Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Context</span> = <span class=\"title class_\">React</span>.<span class=\"property\">createContext</span>&lt;<span class=\"title class_\">Value</span> | <span class=\"keyword\">typeof</span> <span class=\"variable constant_\">EMPTY</span>&gt;(<span class=\"variable constant_\">EMPTY</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Provider</span>(<span class=\"params\">props: ContainerProviderProps&lt;State&gt;</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义hooks 获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title function_\">useHook</span>(props.<span class=\"property\">initialState</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 需要使用Context 子组件使用Provider 包装， 将数据写入Context。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Context.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">{value}</span>&gt;</span>{props?.children}<span class=\"tag\">&lt;/<span class=\"name\">Context.Provider</span>&gt;</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useContainer</span>(<span class=\"params\"></span>): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 使用React.useContext 从 Context 中获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">Context</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === <span class=\"variable constant_\">EMPTY</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">\"Component must be wrapped with &lt;Container.Provider&gt;\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"title class_\">Provider</span>,</span><br><span class=\"line\">    useContainer,</span><br><span class=\"line\">};</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"useContainer\"><a href=\"#useContainer\" class=\"headerlink\" title=\"useContainer\"></a>useContainer</h4><p>使用 useContainer 从 Container 中直接获取属性。</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> useContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt;</span><br><span class=\"line\">): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\"><span class=\"keyword\">return</span> container.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"unstate-next-使用\"><a href=\"#unstate-next-使用\" class=\"headerlink\" title=\"unstate-next 使用\"></a><a href=\"./unstate-next-use.html\">unstate-next 使用</a></h4><h4 id=\"实现code\"><a href=\"#实现code\" class=\"headerlink\" title=\"实现code\"></a>实现 code</h4><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">EMPTY</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ContainerProviderProps 定义类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">State</span>} <span class=\"variable\">State</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">State</span>} <span class=\"variable\">initialState</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">React.ReactNode</span>} <span class=\"variable\">children</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span> = <span class=\"built_in\">any</span>&gt; {</span><br><span class=\"line\">initialState?: <span class=\"title class_\">State</span>;</span><br><span class=\"line\"><span class=\"attr\">children</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"title class_\">Provider</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ComponentType</span>&lt;<span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span>&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">useContainer</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Value</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> createContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">useHook</span>: <span class=\"function\">(<span class=\"params\">initialState?: State</span>) =&gt;</span> <span class=\"title class_\">Value</span></span><br><span class=\"line\">): <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"comment\">// 使用React.createContext 创建Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Context</span> = <span class=\"title class_\">React</span>.<span class=\"property\">createContext</span>&lt;<span class=\"title class_\">Value</span> | <span class=\"keyword\">typeof</span> <span class=\"variable constant_\">EMPTY</span>&gt;(<span class=\"variable constant_\">EMPTY</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Provider</span>(<span class=\"params\">props: ContainerProviderProps&lt;State&gt;</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义hooks 获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title function_\">useHook</span>(props.<span class=\"property\">initialState</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 需要使用Context 子组件使用Provider 包装， 将数据写入Context。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Context.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">{value}</span>&gt;</span>{props?.children}<span class=\"tag\">&lt;/<span class=\"name\">Context.Provider</span>&gt;</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useContainer</span>(<span class=\"params\"></span>): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 使用React.useContext 从 Context 中获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">Context</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === <span class=\"variable constant_\">EMPTY</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">\"Component must be wrapped with &lt;Container.Provider&gt;\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"title class_\">Provider</span>,</span><br><span class=\"line\">    useContainer,</span><br><span class=\"line\">};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> useContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt;</span><br><span class=\"line\">): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\"><span class=\"keyword\">return</span> container.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["React","components","unstate-next"],"tags":["前端","TypeScript","react","unstate-next"]},{"title":"unstate-next 的使用","url":"//react/components/unstate-next-use.html","content":"<h4 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zNTQ5MDE5MS9SZWFjdC1UeXBlU2NyaXB0\">Code-Test<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install --save unstated-next</span><br><span class=\"line\"></span><br><span class=\"line\">yarn add unstated-next</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"createContainer\"><a href=\"#createContainer\" class=\"headerlink\" title=\"createContainer\"></a>createContainer</h4><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { useState } <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { createContainer } <span class=\"keyword\">from</span> <span class=\"string\">\"unstated-next\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">useCounter</span> = (<span class=\"params\">props: <span class=\"built_in\">any</span></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { initNum } = props;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [num, changeNum] = useState&lt;<span class=\"built_in\">number</span>&gt;(initNum);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">decrement</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">changeNum</span>(num - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">increment</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">changeNum</span>(num + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {num, decrement, increment};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Counter</span> = <span class=\"title function_\">createContainer</span>(useCounter);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"use-Provider-initialState\"><a href=\"#use-Provider-initialState\" class=\"headerlink\" title=\"use Provider &amp;&amp; initialState\"></a>use Provider &amp;&amp; initialState</h4><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">'./Context'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> {<span class=\"title class_\">TestCounter</span>} <span class=\"keyword\">from</span> <span class=\"string\">'./TestCounter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Counter.Provider</span> <span class=\"attr\">initialState</span>=<span class=\"string\">{{</span> <span class=\"attr\">initNum:</span> <span class=\"attr\">1</span> }}&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">TestCounter</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Counter.Provider</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"useContainer\"><a href=\"#useContainer\" class=\"headerlink\" title=\"useContainer\"></a>useContainer</h4><h5 id=\"TestCounter\"><a href=\"#TestCounter\" class=\"headerlink\" title=\"TestCounter\"></a>TestCounter</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./Context\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> {<span class=\"title class_\">TestChild</span>} <span class=\"keyword\">from</span> <span class=\"string\">'./TestChild'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">TestCounter</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { num, decrement } = <span class=\"title class_\">Counter</span>.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{decrement}</span>&gt;</span>减法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TestChild</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"TestChild\"><a href=\"#TestChild\" class=\"headerlink\" title=\"TestChild\"></a>TestChild</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./Context\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">TestChild</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { num, increment } = <span class=\"title class_\">Counter</span>.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        {num} <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{increment}</span>&gt;</span>加法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["React","components","unstate-next"],"tags":["前端","TypeScript","react","unstate-next"]},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></tbody></table></figure>\n"},{"title":"有关于我","url":"//about/me.html","content":"<hr>\n<h4 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h4><ul>\n<li>性 别：男 \t\t\t\t\t\t\t\t\t\t\t  年 龄：27</li>\n<li> 手 机：15594555052                           邮 箱：<span class=\"exturl\" data-url=\"bWFpbHRvOiYjeDM4OyYjeDQwOyYjOTg7JiM5NzsmI3g3NDsmIzEyMTsmI3g3MDsmI3g2NTsmI3gyZTsmI3g2MzsmIzExMTsmI3g2ZDs=\">8@batype.com<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>专 业：计算机科学与技术                    岗 位：研发工程师</li>\n</ul>\n<hr>\n<h4 id=\"工作及教育经历\"><a href=\"#工作及教育经历\" class=\"headerlink\" title=\"工作及教育经历\"></a>工作及教育经历</h4><ul>\n<li>博彦科技：前端开发⼯程师 \t\t\t\t\t           2021.08.16 ~ 至今</li>\n<li>神玥软件：软件开发⼯程师部⻔技术负责⼈\t             2019.07.03 ~  2021.08.13</li>\n<li> 安康学院 \t\t\t\t\t \t\t\t\t\t           2015.09.01 ~ 2019.06.24</li>\n</ul>\n<hr>\n<h4 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h4><ul>\n<li>熟练使用：React、VUE、JavaScript、HTML、CSS、TypeScript、Java</li>\n<li> 了解：React 源码</li>\n<li>前端框架：Taro-UI、JQuery、Echarts、Antd、ThreeJS</li>\n<li> 前端服务层：Mobx、Redux</li>\n<li> 前端请求服务：Axios、Ajax、fetch</li>\n<li> 前端资源加载 / 打包⼯具：Webpack 、UmiJS、Vite</li>\n<li> 后端微服务框架：SpringBoot</li>\n<li> 后端服务框架：SpringMVC、Struct2</li>\n<li> 后端 Jdbc 层：MyBatis、Hibernate</li>\n<li> 框架：Django、Pillow、requests、urllib3、bs4、Selemiun、lxml</li>\n<li> 数据库：MySQL、Oracle、Redis、SqLite、memcache</li>\n<li> 服务器：Tomcat、Nginx</li>\n<li> 算法：快速排序、深度优先策略、贪心算法</li>\n</ul>\n<hr>\n<h4 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h4><ol>\n<li><p>阿里云开放平台</p>\n<ul>\n<li><p>时间： 2021 年 9 月至今</p>\n</li>\n<li><p>职责：主要负责项目开发、框架服务维护、自动化部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>职位：前端开发工程师</p>\n</li>\n<li><p>内容：在项目期间负责前端页面设计、开发、维护等。主要通过该项目对自己的个人技能有了一个较强的提升，对于自己的知识面有了一个更高层次的认知，使用第三方工具进行快速开发，采用 React  技术栈和其周边工具开发，项目架构采用 umiJs + vite  协同开发模式。</p>\n</li>\n<li><p>业绩：</p>\n<ol>\n<li>每一季度，评分基本都在 A 以上；</li>\n<li>目前通过自己的努力在项目中，担任 TL 职位，负责项目的任务分配，疑难问题处理。</li>\n<li>获得了博彦技术之星称号。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>神玥软件 - ⼴东动态监管平台 - 2020 年 6 ⽉⾄ 2021 年 7 ⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在该项⽬中同样采⽤全后端分离架构，该项⽬中不同之处在于使⽤架构发⽣改变，增加使⽤接⼝获取数据、动态切换数据源等。</p>\n</li>\n<li><p>项⽬架构：</p>\n<p>前端 + 展示服务后台 + 数据抓取服务端 + 定时器数据处理服务端 + 接⼝获取数据端 + 第三⽅数据获取服务端组成。</p>\n<p>在前端开发中，项⽬使⽤ 4 层架构进程⻚⾯处理，临时数据存储使⽤ session 进⾏，使⽤有效⻚⾯数据传输保证⻚⾯独⽴性、依赖性降低、项⽬可扩展性增加、便与开发进⾏。</p>\n<p>在定时器数据处理服务端不同之处，在于其需要兼容多中不同数据源，主要包 oracle、db2 (及其 as400 版本)、MySQL 等，兼容其不同语法进⾏处理，连接⼯具类处理，初始化连接等问题，后台数据报⽂传输使⽤某某加密⽅式实现。</p>\n<p>第三⽅接⼝程序实现主要是提供于第三⽅进⾏对接数据，汇总返回数据，进⾏数据统计，完成展示。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、SpringSecurity、oauth2、Sqlite、MySQL、redis 等。</p>\n</li>\n</ul>\n</li>\n<li><p>神玥软件 - 公积⾦监督管理云平台 - 2019 年 8 ⽉⾄ 2020 年 5 ⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在公积⾦监督管理云平台开发中，使⽤前后端分离架构。</p>\n</li>\n<li><p>项⽬架构： 前端 + 展示服务后台 + 数据抓取服务端 + 定时器数据处理服务端组成。在前端开发中，使⽤ React 开发框架辅助 antd、amap、echarts、mobx、Axios 等，借助 webpack 打包压缩⽂件等技术实现前端开发任务。</p>\n<p>在后端技术⽀撑⽅⾯使⽤ SpringBoot 微服务框架，进⾏数据展示层⾯服务服务端程序编写。</p>\n<p>在数据获取⽅⾯，数据均来⾃于各现场数据库，编写定时器服务端程序，使⽤频率为 5 分钟到 1 ⼩时不等等⽅法策略实现，适⽤于各种不同的核⼼版本库，通过 sqlite 轻量级数据库进⾏数据暂存，等待公司客户端服务器抓取数据，该技术由于公司限制使⽤该⽅法策略实现，在程序实现⽅⾯使⽤ mybatis 解析 SQL ⽅式编写，xml 配置⽂件进⾏ SQL 配置，通过 dao4j 进⾏ xml 解析获取对应 sql，使⽤ XMLScriptBuilder 进⾏获取 SQL 处理⽣成 sqlSource 资源，根据 sqlSource 获取 boundSql 对象获取编译后带有占位符资源对象，获取占位符信息数据，替换对应参数完成可执⾏ sql。</p>\n<p>在数据抓取客户端使⽤ 5 分钟频率去更新数据，实时抓取数据与数据可进⾏⽐较并且进⾏更新。</p>\n<p>对接使⽤微型前端服务框架，加载第三⽅服务程序。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、Sqlite、MySQL、redis 等。</p>\n</li>\n</ul>\n</li>\n<li><p>个人项目 - 微信⼩程序 API + 停⻋场客户端编写 - 2018 年 11 ⽉⾄ - 2019 年 1 ⽉</p>\n<ul>\n<li>职 责：项⽬设计、需求、开发、部署等</li>\n<li>内 容：该项⽬主要使⽤微信⼩程序、Django 框架、H5 前端完成。后端基于 Django 框架，主要是在 Django 框架中进⾏ setting.py 配置，url 编写，数据库模型创建、映射⽂件，view 视图编写，服务代码编写。Api 返回数据序列化处理、json 数据处理。进⾏停⻋场实时数据监控数据处理。并且使⽤ window 2008 server R2 进⾏环境部署，服务器搭建使⽤ nginx+fastCGI+Django 进⾏配置，使⽤ https 进⾏数据访问。</li>\n<li>职 责：负责编写 model、admin、view、API 编写、⽀付接⼝编写；</li>\n<li>开发⼯具、语⾔及框架：JetBrains PyCharm、MySQL、Dreamweaver、Photoshop、Python、Django、HTML、CSS、JavaScript、Ajax、jQuery、Bootstrap 以及 Python 开源框架。</li>\n</ul>\n</li>\n<li><p>个人项目 - 爬取 wikipedia 深度为 3 的超链接</p>\n<ul>\n<li>内 容：Wikipedia 深度为 3 的所有 URL 资源链接的获取（1000 万条记录），采取进程的⽅法进⾏访问 Wikipedia，根据深度优先策略进⾏ URL 第⼆层资源遍历获取第三层 URL 资源。在数据处理过程中，使⽤ request2 技术获取源码、解析拦截⽆⽤⽂件，使⽤ lxml 技术进⾏分离出需要数据，并且检测出可⽤链接， 后进⾏ URL 保存到本地资源。</li>\n<li>难 点：在获取 Wikipedia 网站数据的时候需要处理反爬虫、过滤网站数据、获取需要的资源进行解析。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"获奖经历\"><a href=\"#获奖经历\" class=\"headerlink\" title=\"获奖经历\"></a>获奖经历</h4><ul>\n<li>博彦科技 - 技术之星</li>\n<li>信息安全一级证书</li>\n</ul>\n<hr>\n<h4 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h4><ul>\n<li><a href=\"https://note.batype.com/\">https://note.batype.com/</a></li>\n</ul>\n<h4 id=\"⾃我评价\"><a href=\"#⾃我评价\" class=\"headerlink\" title=\"⾃我评价\"></a>⾃我评价</h4><ul>\n<li>爱 好：骑⾏、登⼭、旅游、⽻⽑球、篮球、乒乓球。</li>\n<li>评 价：在我的从事计算机⾏业学习到⼯作也有 6 年之久，从刚开始对计算机的感兴趣到现在的⼯作，以及它成为了我⽣活不可或缺的⼀部分，都是⼀个变化和不多学习的过程，在这个过程中，经历了太多太多的苦难，从刚开始的⼀窍不通到现在的应⽤⾃如以及更深层次的了解，都是在不断⾃学中成⻓起来。需要这般⾃学就必须要有⾃学的动⼒和持之以恒的坚持都是不可缺少的。学习过程中不断的纠正⾃⼰学的⽅向，处理存在的问题以及快速处理问题的解决⽅法，都是⼀个能⼒的提升。 后还有就是对这个⾏业的热爱。</li>\n</ul>\n"},{"title":"archives","url":"/archives/index.html","content":""},{"title":"categories","url":"/categories/index.html","content":""},{"title":"浏览器原理","url":"/browser/index.html","content":"<p>学习流程</p>\n<h2 id=\"v8引擎\"><a href=\"#v8引擎\" class=\"headerlink\" title=\"v8引擎\"></a>v8 引擎</h2><p><a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间</a><br><a href=\"/browser/v8/GarbageCollection.html\">垃圾回收</a><br><a href=\"/browser/v8/CompilerInterpreter.html\">编译器和解释器</a><br><a href=\"/browser/v8/ScavengeAlgorithm.html\">Scavenge 算法</a><br><a href=\"/browser/v8/MarkSweep.html\">Mark-Sweep 算法</a><br><a href=\"/browser/v8/MarkCompact.html\">Mark-Compact 算法</a><br><a href=\"/browser/v8/IncrementalMarking.html\">Incremental Marking 算法</a></p>\n"},{"title":"schedule","url":"/schedule/index.html","content":""},{"title":"Tags","url":"/tags/index.html","content":""},{"title":"编译器和解释器：V8 是如何执行一段 JavaScript 代码的？","url":"/browser/v8/CompilerInterpreter.html","content":"<p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p>\n<p>今天这篇文章我们就继续 “向下” 分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>\n<p>前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>\n<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的<strong>编译器（Compiler）</strong>、<strong>解释器（Interpreter）</strong>、<strong>抽象语法树（AST）</strong>、<strong>字节码（Bytecode）</strong>、<strong>即时编译器（JIT）</strong>等概念，都是你需要重点关注的。</p>\n<h2 id=\"编译器和解释器\"><a href=\"#编译器和解释器\" class=\"headerlink\" title=\"编译器和解释器\"></a>编译器和解释器</h2><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码 “翻译” 成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>\n<p><strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了</strong>。比如 C/C++、GO 等都是编译型语言。</p>\n<p><strong>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p>\n<p>那编译器和解释器是如何 “翻译” 代码的呢？具体流程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663058170ea9cb140383de2e.png\" alt=\"编译器和解释器“翻译”代码\"></p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<ol>\n<li><p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p>\n</li>\n<li><p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>\n</li>\n</ol>\n<h2 id=\"V8是如何执行一段JavaScript代码的\"><a href=\"#V8是如何执行一段JavaScript代码的\" class=\"headerlink\" title=\"V8是如何执行一段JavaScript代码的\"></a>V8 是如何执行一段 JavaScript 代码的</h2><p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来 “一览全局”，参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6630587f0ea9cb14038486dc.png\" alt=\"V8执行一段代码流程图\"></p>\n<p>从图中可以清楚地看到，V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>，那么它们是如何配合去执行一段 JavaScript 代码的呢？下面我们就按照上图来一一分解其执行流程。</p>\n<h3 id=\"1-生成抽象语法树（AST）和执行上下文\"><a href=\"#1-生成抽象语法树（AST）和执行上下文\" class=\"headerlink\" title=\"1. 生成抽象语法树（AST）和执行上下文\"></a>1. 生成抽象语法树（AST）和执行上下文</h3><p>将源代码转换为<strong>抽象语法树</strong>，并生成<strong>执行上下文</strong>，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>\n<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>\n<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>\n<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">23</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">myName = <span class=\"string\">\"geektime\"</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码经过<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuam9pbnRqcy5jb20vZGVtb3MvYWJzdHJhY3Qtc3ludGF4LXRyZWU=\"> javascript-ast<i class=\"fa fa-external-link-alt\"></i></span>站点处理后，生成的 AST 结构如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305a090ea9cb1403871aee.png\" alt=\"抽象语法树（AST）结构\"></p>\n<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>\n<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>\n<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>\n<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>\n<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 <strong>token</strong>。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305a8d0ea9cb140388354f.png\" alt=\"分解token示意图\"></p>\n<p>从图中可以看出，通过 <code>var myName = “极客时间”</code> 简单地定义了一个变量，其中关键字 “var”、标识符 “myName” 、赋值运算符 “=”、字符串 “极客时间” 四个都是 token，而且它们代表的属性还不一样。</p>\n<p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个 “语法错误”。</p>\n<p>这就是 AST 的生成过程，先分词，再解析。</p>\n<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>\n<h3 id=\"2-生成字节码\"><a href=\"#2-生成字节码\" class=\"headerlink\" title=\"2. 生成字节码\"></a>2. 生成字节码</h3><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>\n<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>\n<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>\n<p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行</strong>。</p>\n<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305b360ea9cb14038948ae.png\" alt=\"字节码和机器码占用空间对比\"></p>\n<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>\n<h3 id=\"3-执行代码\"><a href=\"#3-执行代码\" class=\"headerlink\" title=\"3. 执行代码\"></a>3. 执行代码</h3><p>生成字节码之后，接下来就要进入执行阶段了。</p>\n<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。到了这里，相信你已经发现了，解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>\n<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码 “翻译” 为机器码的过程。</p>\n<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>\n<p>对于 JavaScript 工作引擎，除了 V8 使用了 “字节码 + JIT” 技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>\n<p>这么多语言的工作引擎都使用了 “字节码 + JIT” 技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305ba20ea9cb140389facd.png\" alt=\"即时编译（JIT）技术\"></p>\n<p>JavaScript 的性能优化<br>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>\n<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p>\n<ol>\n<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p>\n<ul>\n<li>首先我们介绍了编译器和解释器的区别。</li>\n<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>\n<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>\n<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。<br>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</li>\n</ul>\n<h2 id=\"思考时间\"><a href=\"#思考时间\" class=\"headerlink\" title=\"思考时间\"></a>思考时间</h2><p>最后留给你个思考题：你是怎么理解 “V8 执行时间越久，执行效率越高” 这个性质的？</p>\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n"},{"title":"垃圾回收：垃圾数据是如何自动回收的？","url":"/browser/v8/GarbageCollection.html","content":"<p>在<a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间：数据是如何存储的</a>文章中，我们提到了 JavaScript 中的数据是如何存储的，并通过例子分析了<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。通过这种分配方式，我们解决了数据的内存分配的问题。</p>\n<p>不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p>\n<h2 id=\"不同语言的垃圾回收策略\"><a href=\"#不同语言的垃圾回收策略\" class=\"headerlink\" title=\"不同语言的垃圾回收策略\"></a>不同语言的垃圾回收策略</h2><p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>\n<p>如 C/C++ 就是使用手动回收策略，<strong>何时分配内存、何时销毁内存都是由代码控制的</strong>，你可以参考下面这段 C 代码：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在堆中分配内存</span></span><br><span class=\"line\"><span class=\"type\">char</span>* p =  (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">2048</span>);  <span class=\"comment\">//在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//使用p指向的内存</span></span><br><span class=\"line\"> {</span><br><span class=\"line\">   <span class=\"comment\">//....</span></span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//使用结束后，销毁这段内存</span></span><br><span class=\"line\"><span class=\"built_in\">free</span>(p)；</span><br><span class=\"line\">p = <span class=\"literal\">NULL</span>；</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</p>\n<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>\n<p>对于 JavaScript 而言，也正是这个 “自动” 释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>\n<p>那么在本文，我们将围绕 “JavaScript 的数据是如何回收的” 这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍 “栈中的垃圾数据” 和 “堆中的垃圾数据” 是如何回收的。</p>\n<h2 id=\"调用栈中的数据是如何回收的\"><a href=\"#调用栈中的数据是如何回收的\" class=\"headerlink\" title=\"调用栈中的数据是如何回收的\"></a>调用栈中的数据是如何回收的</h2><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客邦\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">showName</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"number\">2</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> d = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"title function_\">showName</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f5a4b0ea9cb1403b921c4.png\" alt=\"执行到showName函数时的内存模型\"></p>\n<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>\n<p>在<a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间：数据是如何存储的</a>文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>\n<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>\n<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f63c40ea9cb1403ce7e6c.png\" alt=\"从栈中回收showName执行上下文\"></p>\n<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>\n<p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p>\n<h2 id=\"堆中的数据是如何回收的\"><a href=\"#堆中的数据是如何回收的\" class=\"headerlink\" title=\"堆中的数据是如何回收的\"></a>堆中的数据是如何回收的</h2><p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f64080ea9cb1403cf0d91.png\" alt=\"foo函数执行结束后的内存状态\"></p>\n<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p>\n<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>\n<h2 id=\"代际假说和分代收集\"><a href=\"#代际假说和分代收集\" class=\"headerlink\" title=\"代际假说和分代收集\"></a>代际假说和分代收集</h2><p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下<strong>代际假说（The Generational Hypothesis）</strong>的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>\n<p>代际假说有以下两个特点：</p>\n<ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul>\n<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>\n<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>\n<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>\n<p>所以，在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>\n<p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li><strong>副垃圾回收器</strong>，主要负责新生代的垃圾回收。</li>\n<li><strong>主垃圾回收器</strong>，主要负责老生代的垃圾回收。</li>\n</ul>\n<h2 id=\"垃圾回收器的工作流程\"><a href=\"#垃圾回收器的工作流程\" class=\"headerlink\" title=\"垃圾回收器的工作流程\"></a>垃圾回收器的工作流程</h2><p>现在你知道了 V8 把堆分成两个区域 —— 新生代和老生代，并分别使用两个不同的垃圾回收器。其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>\n<h2 id=\"副垃圾回收器\"><a href=\"#副垃圾回收器\" class=\"headerlink\" title=\"副垃圾回收器\"></a>副垃圾回收器</h2><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用 <a href=\"/browser/v8/ScavengeAlgorithm.html\">Scavenge 算法</a>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f65610ea9cb1403d18a1c.png\" alt=\"新生区要划分为对象区域和空闲区域\"></p>\n<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>\n<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为<strong>了执行效率，一般新生区的空间会被设置得比较小</strong>。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h2 id=\"主垃圾回收器\"><a href=\"#主垃圾回收器\" class=\"headerlink\" title=\"主垃圾回收器\"></a>主垃圾回收器</h2><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<a href=\"/browser/v8/MarkSweep.html\">标记 - 清除（Mark-Sweep）</a>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p><strong>首先</strong>是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>\n<p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f668e0ea9cb1403d39fec.png\" alt=\"标记过程\"></p>\n<p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f66c50ea9cb1403d40a6a.png\" alt=\"标记清除过程\"></p>\n<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法 —— <a href=\"/browser/v8/MarkCompact.html\">标记 - 整理（Mark-Compact）</a>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f66f60ea9cb1403d463dc.png\" alt=\"标记整理过程\"></p>\n<h2 id=\"全停顿\"><a href=\"#全停顿\" class=\"headerlink\" title=\"全停顿\"></a>全停顿</h2><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>\n<p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f67750ea9cb1403d54c0e.png\" alt=\"全停顿\"></p>\n<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<a href=\"/browser/v8/IncrementalMarking.html\">增量标记（Incremental Marking）算法</a>。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f67b70ea9cb1403d5c414.png\" alt=\"增量标记算法\"></p>\n<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我们就来总结下今天的主要内容。</p>\n<p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>\n<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>\n<p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p>\n<p>生活中处理事情的原则也与之类似，古人很早就说过 “两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>\n"},{"title":"垃圾回收：增量标记（Incremental Marking）算法","url":"/browser/v8/IncrementalMarking.html","content":"<p>增量标记（Incremental Marking）算法是为了解决传统标记 - 清除和标记 - 整理算法中的长暂停时间（Stop-The-World）问题而设计的一种垃圾回收策略。在增量标记中，标记阶段被分割成许多小的步骤，这些步骤交错执行，夹杂在应用程序的运行过程中，从而确保每次停顿时间都比较短。</p>\n<h2 id=\"增量标记算法的逻辑过程\"><a href=\"#增量标记算法的逻辑过程\" class=\"headerlink\" title=\"增量标记算法的逻辑过程\"></a>增量标记算法的逻辑过程</h2><ol>\n<li><p><strong>初始标记（Initial Mark）</strong>：</p>\n<ul>\n<li>这是一个快速标记过程，标记所有从根对象直接可达的对象。</li>\n</ul>\n</li>\n<li><p><strong>增量标记（Incremental Mark）</strong>：</p>\n<ul>\n<li>在此阶段，垃圾回收器断续运行，每次执行一小部分标记工作，标记从已标记对象间接可达的对象。</li>\n<li>为了允许应用程序和垃圾回收器交错执行，标记工作被分割成很多小的任务。</li>\n</ul>\n</li>\n<li><p><strong>最终标记（Final Mark）</strong>：</p>\n<ul>\n<li>这个阶段完成了增量标记中尚未完成的工作，确保所有可达对象都已标记。</li>\n</ul>\n</li>\n<li><p><strong>清除（Sweep）</strong>：</p>\n<ul>\n<li>经过标记阶段后，所有未标记的对象都是不可达的，可以被清除。</li>\n<li>清除同样可以分割成小的任务，以减少应用的停顿时间。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-JavaScript-代码模拟增量标记算法\"><a href=\"#使用-JavaScript-代码模拟增量标记算法\" class=\"headerlink\" title=\"使用 JavaScript 代码模拟增量标记算法\"></a>使用 JavaScript 代码模拟增量标记算法</h2><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IncrementalGC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">objects</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = objects; <span class=\"comment\">// 模拟对象堆</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span> = []; <span class=\"comment\">// 标记队列，模拟待处理的标记工作</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始标记：标记从根可达的对象</span></span><br><span class=\"line\">  <span class=\"title function_\">initialMark</span>(<span class=\"params\">rootRefs</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> rootRef <span class=\"keyword\">of</span> rootRefs) {</span><br><span class=\"line\">      rootRef.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"title function_\">push</span>(rootRef);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">processQueue</span>(); <span class=\"comment\">// 处理一部分标记队列</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 增量标记：每次调用标记一部分对象</span></span><br><span class=\"line\">  <span class=\"title function_\">incrementallyMark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">processQueue</span>();</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Incremental marking complete'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟处理标记队列的过程</span></span><br><span class=\"line\">  <span class=\"title function_\">processQueue</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"title function_\">shift</span>(); <span class=\"comment\">// 取出第一个待处理对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从这个对象出发，模拟标记它的引用（通常这会需要判断对象的属性值）</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了简化模型，我们这里忽略对象间的引用关系</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 清除未标记的对象</span></span><br><span class=\"line\">  <span class=\"title function_\">sweep</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> obj.<span class=\"property\">marked</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objects = [<span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(<span class=\"string\">'obj1'</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(<span class=\"string\">'obj2'</span>)]; <span class=\"comment\">// 模拟的对象堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">IncrementalGC</span>(objects);</span><br><span class=\"line\"><span class=\"keyword\">const</span> roots = [objects[<span class=\"number\">0</span>]]; <span class=\"comment\">// 模拟根引用集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">gc.<span class=\"title function_\">initialMark</span>(roots); <span class=\"comment\">// 初始标记阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟运行时环境，逐步完成标记</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  gc.<span class=\"title function_\">incrementallyMark</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (gc.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> === <span class=\"number\">0</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">    gc.<span class=\"title function_\">sweep</span>(); <span class=\"comment\">// 清除阶段，这也可以分步进行</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(objects); <span class=\"comment\">// 这里应该只有被标记的objects[0]</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的代码中，我们定义了 <code>HeapObject</code> 类来表示堆中的对象。我们还定义了一个 <code>IncrementalGC</code> 类，它拥有一系列对象，一个标记队列用于增量标记过程，并实现了 <code>initialMark</code>, <code>incrementallyMark</code>, 和 <code>sweep</code> 方法来执行垃圾回收的各个阶段。</p>\n<p><code>initialMark</code> 方法将模拟根对象直接可达的对象标记为存活，这些对象则被放入 <code>markQueue</code> 中以进行后续的增量标记阶段。</p>\n<p><code>incrementallyMark</code> 方法在特定的时间间隔运行（例如，它可以由 JavaScript 事件循环在其他任务之间定期触发），每次执行时它会处理一部分标记队列。真实的垃圾回收器可能会使用更复杂的方法来确定何时进行增量标记，以及每次应该标记多少对象，但在这个模拟中，我们在每个间隔只处理队列中的一个对象。</p>\n<p><code>processQueue</code> 方法模拟处理标记队列，并将计划标记的对象标记为存活。在这个简化的模型中，我们没有模拟对象引用其他对象的情况，这通常在真实的增量标记中非常重要。</p>\n<p><code>incrementallyMark</code> 方法在标记完所有对象后输出完成标记的消息。随后，清除阶段开始，<code>sweep</code> 方法过滤出所有未标记的对象，模拟了清除这些对象的垃圾回收过程。</p>\n<p>在最后，我们通过 <code>setInterval</code> 函数周期性地调用 <code>incrementallyMark</code> 方法，模仿增量标记中的 “工作时间切片”。一旦所有的标记任务完成，清除 <code>intervalId</code> 定时器，执行 <code>sweep</code> 方法，结束垃圾回收。</p>\n<p>在控制台输出中，我们应该只看到之前被标记为存活的对象，模拟了这些对象是如何被保留下来的，而未标记的对象则被过滤掉，模拟了它们的内存被回收。</p>\n<p>请记住，这只是一个非常基础的模拟，旨在帮助理解增量标记算法的基本思想。真实世界中，垃圾回收器更加复杂，会涉及优化技术、堆内存的结构和管理、对象的分代收集等多个方面，而且通常是由底层语言实现的，并且完全隐藏在 JavaScript 运行时环境中。</p>\n"},{"title":"垃圾回收：标记 - 整理（Mark-Compact）算法","url":"/browser/v8/MarkCompact.html","content":"<p>标记 - 整理（Mark-Compact）算法，又称为压缩（Compaction）算法，是一种垃圾回收机制，用于解决标记 - 清除算法导致的内存碎片问题。与标记 - 清除算法类似，标记 - 整理算法分为两个阶段：标记阶段和整理阶段。</p>\n<h2 id=\"标记阶段\"><a href=\"#标记阶段\" class=\"headerlink\" title=\"标记阶段\"></a>标记阶段</h2><p>在标记阶段，垃圾回收器遍历所有从根集合可达的对象，并标记这些对象。</p>\n<h2 id=\"整理阶段\"><a href=\"#整理阶段\" class=\"headerlink\" title=\"整理阶段\"></a>整理阶段</h2><p>在整理阶段，垃圾回收器会移动标记为活动的对象，将它们压缩到内存的一端，从而消除碎片并释放出一整块连续的未使用内存。</p>\n<p>标记 - 整理算法的核心优势是它保留了所有存活对象，同时减少了内存碎片。但这个过程的缺点是需要更多的时间，因为移动对象涉及更多的内存操作。</p>\n<p>我们可以用 JavaScript 来模拟标记 - 整理算法的基本步骤，但请注意，这个模拟是为教育目的，并不是实际的垃圾回收器实现。下面是用 JavaScript 来模拟的代码示例：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">forwardingAddress</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 用于压缩时的定位</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Heap</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addObject</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(data);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">compact</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> liveObjects = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> deadObjects = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分离标记为活动和非活动的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">        liveObjects.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        deadObjects.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有活动对象移动至内存前端，并更新其转发地址</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> liveObjects) {</span><br><span class=\"line\">      obj.<span class=\"property\">forwardingAddress</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">addObject</span>(obj.<span class=\"property\">data</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置标记状态</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> liveObjects) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deadObjects.<span class=\"property\">length</span>; <span class=\"comment\">// 返回清理对象的数量</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">heap</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span> = heap;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span> = []; <span class=\"comment\">// 根引用数组</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟创建对象</span></span><br><span class=\"line\">  <span class=\"title function_\">createObject</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">addObject</span>(data);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟删除根引用</span></span><br><span class=\"line\">  <span class=\"title function_\">deleteObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">indexOf</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">mark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> root <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">markRecursive</span>(root);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 递归标记方法</span></span><br><span class=\"line\">  <span class=\"title function_\">markRecursive</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果对象有引用其他对象，递归地标记那些对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 在这个模拟中被忽略了</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 整理并重新分配对象</span></span><br><span class=\"line\">  <span class=\"title function_\">compact</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">compact</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行标记-整理垃圾回收</span></span><br><span class=\"line\">  <span class=\"title function_\">collectGarbage</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">mark</span>(); <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">compact</span>(); <span class=\"comment\">// 整理阶段</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例使用：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建模拟堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> heap = <span class=\"keyword\">new</span> <span class=\"title class_\">Heap</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建垃圾回收器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title function_\">GC</span>(heap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一些对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj3 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除一个对象的引用</span></span><br><span class=\"line\">gc.<span class=\"title function_\">deleteObject</span>(obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行垃圾回收</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> collected = gc.<span class=\"title function_\">collectGarbage</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`收集到 <span class=\"subst\">${collected}</span> 个不可达对象。`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查堆中剩余的对象</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(heap.<span class=\"property\">objects</span>.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> obj.<span class=\"property\">data</span>)); <span class=\"comment\">// 应该只显示 'obj1' 和 'obj3'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的示例中，我们定义了三个类：<code>HeapObject</code>、<code>Heap</code> 和 <code>GC</code>。</p>\n<ol>\n<li><code>HeapObject</code> 类代表堆中的对象，包括它的数据、一个标记位（用于标记清除），以及一个转发地址（在整理阶段使用）。</li>\n<li><code>Heap</code> 类代表内存堆，有一个添加对象的方法和一个紧凑（压缩）方法。紧凑方法会将所有标记的对象移动到数组开始的位置，并更新它们的转发地址。</li>\n<li><code>GC</code> 类是模拟垃圾收集器。它可以创建对象、删除对象的根引用、进行标记和整理。标记的递归方法假设对象间没有相互引用。在真实的情况下，这可能涉及到一个复杂的引用图。</li>\n</ol>\n<p>当 <code>collectGarbage</code> 方法被调用时，它首先执行 <code>mark</code> 方法来标记所有可从根对象集合到达的对象。标记完成后，<code>compact</code> 方法会移动所有标记的对象并压缩堆，以减少内存碎片。</p>\n<p>此模拟例示提供了对标记 - 整理（压缩）算法核心工作原理的基本了解。在真正的编程环境中，这个算法的实现细节会非常复杂，且会由底层语言运行时或虚拟机来完成，不会暴露给开发者。</p>\n"},{"title":"垃圾回收：标记 - 清除（Mark-Sweep）算法","url":"/browser/v8/MarkSweep.html","content":"<p>标记 - 清除（Mark-Sweep）算法是一种常见的垃圾回收（GC）机制，主要用于自动管理编程语言的内存。这种算法通过两个阶段的操作来回收内存：标记（Mark）阶段和清除（Sweep）阶段。</p>\n<h2 id=\"标记阶段\"><a href=\"#标记阶段\" class=\"headerlink\" title=\"标记阶段\"></a>标记阶段</h2><p>在标记阶段，垃圾回收器遍历所有的活动对象，即那些从根集合（root set，通常包括全局变量、在执行栈上的变量等）可达的对象。遍历的过程中，垃圾回收器 “标记” 这些被访问的对象。标记通常是通过在对象的元数据中设置一个位来完成的，以表示该对象是活动的，不应被回收。</p>\n<h2 id=\"清除阶段\"><a href=\"#清除阶段\" class=\"headerlink\" title=\"清除阶段\"></a>清除阶段</h2><p>标记完成后，清除阶段开始。在清除阶段，垃圾回收器再次遍历堆内存中的所有对象，这次是为了查找未被标记的对象。未被标记的对象被认为是不可达的，即它们不再被程序使用或者无法从根集合访问到。这些未标记的对象随后会被回收，释放它们占用的内存以供程序后续使用。</p>\n<h2 id=\"特点与挑战\"><a href=\"#特点与挑战\" class=\"headerlink\" title=\"特点与挑战\"></a>特点与挑战</h2><p>优点：标记 - 清除算法的主要优点在于它的概念相对简单，可以有效地回收不再被需要的内存空间。与引用计数（另一种内存回收机制）相比，它能够回收循环引用的对象。<br>暂停时间：一个挑战是标记 - 清除算法在执行期间会引起程序的暂停（Stop-The-World），尤其是在较大的堆或者大量存活对象的情况下，这可能导致程序响应性降低。<br>内存碎片：标记 - 清除算法可能会导致内存碎片化，因为它仅仅清除了不可达的对象，没有移动存活的对象。这可能将可用内存分割成小的片段，影响到后续内存分配的效率。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>为了减少暂停时间和解决内存碎片化问题，现代的垃圾回收器经常结合使用多种策略和算法，如：</p>\n<p>增量标记（Incremental Marking）：将标记阶段分成多个小步骤执行，交替执行程序代码和标记代码，减少长时间的暂停。<br>并发标记（Concurrent Marking）：在程序运行的同时进行标记阶段，通过多线程技术实现。<br>压缩（Compaction）：在清除阶段或之后进行，将存活的对象移动到内存的一端，以此减少内存碎片。</p>\n<h2 id=\"js代码模拟标记-清除（Mark-Sweep）算法\"><a href=\"#js代码模拟标记-清除（Mark-Sweep）算法\" class=\"headerlink\" title=\"js代码模拟标记-清除（Mark-Sweep）算法\"></a>js 代码模拟标记 - 清除（Mark-Sweep）算法</h2><p>要使用 JavaScript 代码模拟标记 - 清除垃圾回收算法，我们需要模拟内存管理和跟踪对象引用。以下是一个简化模拟代码示例，以帮助了解如何实现标记 - 清除算法。</p>\n<p>首先，我们将创建几个类以表示对象、堆和垃圾回收器：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Heap</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">removeObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">indexOf</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GarbageCollector</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">heap</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span> = heap;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>(); <span class=\"comment\">// 根集合</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟应用程序创建一个对象，并把它添加到根集合中</span></span><br><span class=\"line\">  <span class=\"title function_\">newObject</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">addObject</span>(obj);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">add</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟删除根集合中的引用</span></span><br><span class=\"line\">  <span class=\"title function_\">removeObjectFromRoots</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">delete</span>(obj);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">mark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> (obj.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>)); <span class=\"comment\">// 清除旧的标记</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">root</span> =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">markFrom</span>(root)); <span class=\"comment\">// 从根集合开始标记</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从一个对象开始递归地标记所有可达对象（在真实的垃圾回收器中这通常更复杂）</span></span><br><span class=\"line\">  <span class=\"title function_\">markFrom</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果此对象有引用其他对象，我们需要递归标记</span></span><br><span class=\"line\">      <span class=\"comment\">// 由于我们的模型很简单，这里我们忽略了这一部分</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 清除阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">sweep</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>.<span class=\"property\">length</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">removeObject</span>(obj); <span class=\"comment\">// 清除未标记的对象</span></span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行完整的标记-清除过程</span></span><br><span class=\"line\">  <span class=\"title function_\">gc</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">mark</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">sweep</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个模拟堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> heap = <span class=\"keyword\">new</span> <span class=\"title class_\">Heap</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个垃圾收集器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">GarbageCollector</span>(heap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟对象的创建和垃圾收集</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = gc.<span class=\"title function_\">newObject</span>(); <span class=\"comment\">// 创建一个新对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = gc.<span class=\"title function_\">newObject</span>(); <span class=\"comment\">// 创建另一个新对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">gc.<span class=\"title function_\">removeObjectFromRoots</span>(obj1); <span class=\"comment\">// 移除 obj1 的引用</span></span><br><span class=\"line\">gc.<span class=\"title function_\">gc</span>(); <span class=\"comment\">// 运行垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(heap.<span class=\"property\">objects</span>); <span class=\"comment\">// 只包含 'obj2'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上述模拟示例中，HeapObject 类表示堆中的对象，每个对象都有一个 marked 属性，用于标记阶段。Heap 类模拟堆内存，提供添加和移除对象的方法。GarbageCollector 类是我们的简化垃圾回收器，它使用标记和清除的方法来管理堆内存中的对象。</p>\n<p>在这个模拟中，我们假设所有的对象都是单独的，没有关系或属性连接它们。在现实中，标记过程会递归遍历所有可从根集合到达的对象。同样，这个简化的模型没有考虑对象间的关联或对象的特定数据结构，这些都在真实世界的标记 - 清除垃圾回收算法中非常重要。</p>\n<p>需要注意的是，这个模拟仅用于演示目的，以帮助理解标记 - 清除算法的基本原理，它并不反映实际的 JavaScript 垃圾回收行为。在实际的 JavaScript 引擎中，垃圾回收过程是隐藏在底层的，且具有许多复杂性，包括内存管理、对象追踪和内存分配优化等。</p>\n<p>总之，在这个简易的模拟中，垃圾回收器通过两个阶段进行工作：</p>\n<p>标记（Mark）阶段：垃圾回收器从根集合出发去标记所有可以到达的对象，意味着这些对象目前被程序使用中，所以不应该被清除。</p>\n<p>清除（Sweep）阶段：垃圾回收器遍历堆中所有的对象，检查它们是否被标记。未被标记的对象会在这个阶段被清除收回，因为它们已经不再被程序使用。</p>\n<p>请注意，此模拟中的 GarbageCollector 对象提供了一个手动触发垃圾回收的方法 gc ()，这不是在实际 JavaScript 应用程序中可以做的。真实的 JavaScript 垃圾回收器会根据内存压力和其他启发式算法自动触发垃圾回收。</p>\n<p>此外，为了增加真实感，代码中可能加入对象之间的关联（例如对象属性引用其他对象），从而在标记过程中需要进行递归遍历。由于 JavaScript 的特性和环境限制，这里的模拟只能提供一个原理层面的理解，而不是一个可以实际运行的垃圾回收器。在 JS 中，创建和管理内存是被隐藏起来的，由 JS 引擎自身处理。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>标记 - 清除算法是理解现代垃圾回收器工作原理的基础，而实际的垃圾回收器往往通过结合多种技术来优化性能和减少对程序执行的干扰。</p>\n"},{"title":"垃圾回收：Scavenge 算法","url":"/browser/v8/ScavengeAlgorithm.html","content":"<p>Scavenge 算法是一种特定于垃圾回收（Garbage Collection, GC）技术的算法，主要在一些现代编程语言的运行时环境中被实现，例如在 V8 JavaScript 引擎中。它是一种采用分代回收（Generational Collection）策略的垃圾回收机制的一部分，着重于快速高效地回收年轻代（Young Generation）中的对象。</p>\n<h2 id=\"垃圾回收与分代假说\"><a href=\"#垃圾回收与分代假说\" class=\"headerlink\" title=\"垃圾回收与分代假说\"></a>垃圾回收与分代假说</h2><ul>\n<li>垃圾回收：垃圾回收是自动管理内存的过程，它追踪哪些对象不再被程序需要，并释放这些对象占用的内存。</li>\n<li>分代假说：大多数编程语言的垃圾回收器基于分代假说，这个假说认为大多数对象在内存中存活时间很短，而只有少数对象需要长时间存活。</li>\n</ul>\n<h2 id=\"Scavenge算法主要特点\"><a href=\"#Scavenge算法主要特点\" class=\"headerlink\" title=\"Scavenge算法主要特点\"></a>Scavenge 算法主要特点</h2><ul>\n<li><p>简单高效：Scavenge 算法通过将堆内存分为两部分（通常称为半空间，semispaces），在对象很少从年轻代晋升到老年代的情况下，可以非常快速地进行垃圾回收。</p>\n</li>\n<li><p>复制算法：在一个半空间（活动空间）中分配对象，当这个空间满了的时候，Scavenge 算法会检查存活的对象，并将它们复制到另一个半空间（空闲空间），同时回收原空间的所有内存。这一过程中，活着的对象也可能根据其存活时间被晋升到老年代空间。</p>\n</li>\n<li><p>暂停时间短：Scavenge 算法在执行垃圾回收期间需要暂停程序的执行（Stop-The-World），但由于只作用于年轻代（这部分空间相对较小），导致回收过程中的暂停时间很短，这对于需要高响应性的应用程序非常重要。</p>\n</li>\n<li><p>空间换时间：由于 Scavenge 算法使用了两个半空间，并且一次只能使用一个半空间进行对象分配，实际上它牺牲了一半的堆内存空间以换取垃圾回收的速度和效率。这种方法对于内存不是非常紧张的现代应用通常是可接受的。</p>\n</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>Scavenge 算法（尤其是其改进版本，如 V8 引擎中的 Orinoco 垃圾回收器）在提供快速回收和减少暂停时间方面表现出色，特别适用于需要处理大量短命对象且对暂停时间敏感的场景，如 Web 服务器和交云性高的前端应用等。</p>\n<h2 id=\"js模拟算法实现\"><a href=\"#js模拟算法实现\" class=\"headerlink\" title=\"js模拟算法实现\"></a>js 模拟算法实现</h2><p>实现一个完整的 Scavenge 算法或任何一种垃圾回收算法在 JavaScript 中是不切实际的，因为 JavaScript 语言本身并不允许直接控制内存分配或回收细节。垃圾回收是由 JavaScript 引擎（比如 V8、SpiderMonkey 或 JavaScriptCore）在底层实现的，开发者通常无法（也不需要）直接操作这个过程。</p>\n<p>但是，我们可以试着模拟一个简化版的 Scavenge 垃圾回收算法的行为来帮助理解其工作原理。Scavenge 算法使用两块大小相等的内存区域（称为 semispaces）—— 一块是活动空间，另一块是空闲空间。对象最初分配在活动空间中，当活动空间填满时，算法会遍历活动空间，将存活的对象复制到空闲空间中，并清理整个活动空间。</p>\n<p>请注意，下面的代码示例是一个极度简化的模型，用于教育目的，不能用于生产环境中的垃圾回收。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ScavengeGC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">size</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">size</span> = size; <span class=\"comment\">// 内存空间的大小</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(); <span class=\"comment\">// 活动空间</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(); <span class=\"comment\">// 空闲空间</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">allocate</span>(<span class=\"params\">object</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"property\">size</span> &gt;= <span class=\"variable language_\">this</span>.<span class=\"property\">size</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">scavenge</span>(); <span class=\"comment\">// 如果活动空间已满，运行垃圾回收</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"property\">size</span> &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">size</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 分配对象到活动空间</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> objectId = <span class=\"title class_\">Symbol</span>(); <span class=\"comment\">// 生成一个唯一标识符作为对象的ID</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"title function_\">set</span>(objectId, object);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> objectId;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'Out of memory'</span>); <span class=\"comment\">// 内存不足</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">scavenge</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 将存活的对象从活动空间复制到空闲空间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [id, obj] <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">isAlive</span>(obj)) { <span class=\"comment\">// 假设有一个方法来判断对象是否存活</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>.<span class=\"title function_\">set</span>(id, obj);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 清理活动空间并交换活动空间和空闲空间</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\">    [<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>] = [<span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">isAlive</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 为简化模型，假设所有对象都是存活的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个简单的测试实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">ScavengeGC</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 假设空间大小为10个对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟分配和回收过程</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) {</span><br><span class=\"line\">  gc.<span class=\"title function_\">allocate</span>({ <span class=\"attr\">data</span>: i }); <span class=\"comment\">// 分配20个对象来观察垃圾回收行为</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个示例中的 ScavengeGC 类实例化时创建了两块 “内存空间”（实际上是使用 Map 对象模拟的），并通过 allocate 方法来模拟对象分配。当活动空间满了，scavenge 方法模拟了垃圾回收过程：存活对象被复制到空闲空间中，然后清理和交换两个空间。</p>\n<p>请记住，这只是一个非常基础和简化的模型，真实的 Scavenge 算法要复杂得多，且具体实现细节因 JavaScript 引擎的不同而异。</p>\n"},{"title":"栈空间和堆空间：数据是如何存储的？","url":"/browser/v8/StackAndHeap.html","content":"<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p>\n<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p>\n<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>\n<p>今天我们讲述第一部分的内容 ——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。</p>\n<h2 id=\"让人疑惑的代码\"><a href=\"#让人疑惑的代码\" class=\"headerlink\" title=\"让人疑惑的代码\"></a>让人疑惑的代码</h2><p>首先，我们先看下面这两段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    a.<span class=\"property\">name</span> = <span class=\"string\">\"极客邦\"</span> </span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>\n<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>\n<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 {name:” 极客邦”}。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>\n<p>要彻底弄清楚这个问题，我们就得先从 “JavaScript 是什么类型的语言” 讲起。</p>\n<h2 id=\"JavaScript是什么类型的语言\"><a href=\"#JavaScript是什么类型的语言\" class=\"headerlink\" title=\"JavaScript是什么类型的语言\"></a>JavaScript 是什么类型的语言</h2><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"type\">char</span>* b = <span class=\"string\">\"极客时间\"</span>;</span><br><span class=\"line\">   <span class=\"type\">bool</span> c = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。<strong>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言</strong>。</p>\n<p>相反地，<strong>我们把在运行过程中需要检查数据类型的语言称为动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>\n<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">c = a</span><br></pre></td></tr></tbody></table></figure>\n\n<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为<strong>隐式类型转换</strong>。而<strong>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</strong>。在这点上，C 和 JavaScript 都是弱类型语言。</p>\n<p>对于各种语言的类型，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f08c70ea9cb14030a18d5.png\" alt=\"语言类型图\"></p>\n<h2 id=\"JavaScript的数据类型\"><a href=\"#JavaScript的数据类型\" class=\"headerlink\" title=\"JavaScript的数据类型\"></a>JavaScript 的数据类型</h2><p>现在我们知道了，<strong>JavaScript 是一种弱类型的、动态的语言</strong>。那这些特点意味着什么呢？</p>\n<ul>\n<li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>\n<li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。<br>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</li>\n</ul>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar</span><br><span class=\"line\">bar = <span class=\"number\">12</span> </span><br><span class=\"line\">bar = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">bar = <span class=\"literal\">true</span></span><br><span class=\"line\">bar = <span class=\"literal\">null</span></span><br><span class=\"line\">bar = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>\n<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用 “typeof” 运算符。具体使用方式如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar)  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">bar = <span class=\"number\">12</span> </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//number</span></span><br><span class=\"line\">bar = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar)<span class=\"comment\">//string</span></span><br><span class=\"line\">bar = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//boolean</span></span><br><span class=\"line\">bar = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//object</span></span><br><span class=\"line\">bar = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//object</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>\n<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td> Boolean</td>\n<td> 只有 true 和 false 两个值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td> 只有一个值 null。</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td> 一个没有被赋值的变量会有个默认值 undefined，变量提升时的默认值也是  undefined。</td>\n</tr>\n<tr>\n<td>Number</td>\n<td> 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值，-（263-1） 到 263-1。</td>\n</tr>\n<tr>\n<td>BigInt</td>\n<td>JavaScript 中一个新的数字类型，可以用任意精度表示整数。使用 BigInt，即使超出 Number 的安全整数范围限制，也可以安全地存储和操作。</td>\n</tr>\n<tr>\n<td>String</td>\n<td> 用于表示文本数据。不同于类 C 语言，JavaScript 的字符串是不可更改的。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td> 符号类型是唯一的并且是不可修改的，通常用来作为 Object 的 key。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td> 在 JavaScript 里，对象可以被看作是一组属性的集合。</td>\n</tr>\n</tbody></table>\n<p>了解这些类型之后，还有三点需要你注意一下。</p>\n<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>\n<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myObj = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">'极客时间'</span>,</span><br><span class=\"line\">    <span class=\"attr\">update</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>){....}</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>\n<p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>\n<h2 id=\"内存空间\"><a href=\"#内存空间\" class=\"headerlink\" title=\"内存空间\"></a>内存空间</h2><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f365a0ea9cb140367ced0.png\" alt=\"JavaScript内存模型\"></p>\n<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间</strong>、<strong>栈空间</strong>和<strong>堆空间</strong>。</p>\n<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>\n<h3 id=\"栈空间和堆空间\"><a href=\"#栈空间和堆空间\" class=\"headerlink\" title=\"栈空间和堆空间\"></a>栈空间和堆空间</h3><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d = c</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f39710ea9cb1403700ee8.png\" alt=\"执行到第3行时的调用栈状态图\"></p>\n<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>\n<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在 “堆” 中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f39c70ea9cb140370a882.png\" alt=\"对象类型是“堆”来存储\"></p>\n<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>\n<p>好了，现在你应该知道了<strong>原始类型的数据值都是直接保存在 “栈” 中的，引用类型的值是存放在 “堆” 中的</strong>。不过你也许会好奇，为什么一定要分 “堆” 和 “栈” 两个存储空间呢？所有数据直接存放在 “栈” 中不就可以了吗？</p>\n<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3adb0ea9cb140372c501.png\" alt=\"调用栈中切换执行上下文状态\"></p>\n<p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>\n<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p>\n<p>所以 <code>d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3b720ea9cb140373eef6.png\" alt=\"引用赋值\"></p>\n<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>\n<h2 id=\"再谈闭包\"><a href=\"#再谈闭包\" class=\"headerlink\" title=\"再谈闭包\"></a>再谈闭包</h2><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>\n<p>例如下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test1 = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> test2 = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerBar = { </span><br><span class=\"line\">        <span class=\"attr\">setName</span>:<span class=\"keyword\">function</span>(<span class=\"params\">newName</span>){</span><br><span class=\"line\">            myName = newName</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"attr\">getName</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test1)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> myName</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerBar</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"title function_\">foo</span>()</span><br><span class=\"line\">bar.<span class=\"title function_\">setName</span>(<span class=\"string\">\"极客邦\"</span>)</span><br><span class=\"line\">bar.<span class=\"title function_\">getName</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar.<span class=\"title function_\">getName</span>())</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>\n<p>但是在那篇文章中，我们介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p>\n<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>\n<ol>\n<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>\n<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个 “closure (foo)” 的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>\n<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到 “closure (foo)” 对象中。这时候堆中的 “closure (foo)” 对象中就包含了 myName 和 test1 两个变量了。</li>\n<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。<br>通过上面的分析，我们可以画出执行到 foo 函数中 “return innerBar” 语句时的调用栈状态，如下图所示：</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3cce0ea9cb140376c689.png\" alt=\"闭包的产生过程\"></p>\n<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 “closure (foo)” 对象，所以即使 foo 函数退出了，“ closure (foo)” 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 <code>bar.setName</code> 或者 <code>bar.getName</code> 时，创建的执行上下文中就包含了 “closure (foo)”。</p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p>\n<p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类 —— 原始类型和引用类型。</p>\n<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>\n<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>\n<p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>\n"},{"title":"V8 学习流程","url":"/browser/v8/index.html","content":"<p>学习流程</p>\n<p><a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间</a><br><a href=\"/browser/v8/GarbageCollection.html\">垃圾回收</a><br><a href=\"/browser/v8/CompilerInterpreter.html\">编译器和解释器</a><br><a href=\"/browser/v8/ScavengeAlgorithm.html\">Scavenge 算法</a><br><a href=\"/browser/v8/MarkSweep.html\">Mark-Sweep 算法</a><br><a href=\"/browser/v8/MarkCompact.html\">Mark-Compact 算法</a><br><a href=\"/browser/v8/IncrementalMarking.html\">Incremental Marking 算法</a></p>\n"}]