[{"title":"RESTful和RPC的区别","url":"/songs-note//browser/restful/and/rpc.html","content":"<h4 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h4><p>RESTful是一种基于HTTP协议，通过URL、HTTP方法和参数等方式来访问和操作资源的设计风格和架构方法。它是一种轻量级的、高效的、无状态的Web服务架构，可以用于设计和开发各种类型的Web应用程序和分布式系统。</p>\n<p>RESTful的核心思想是资源的定义和管理，将系统中的资源抽象为一组URI（统一资源标识符），通过HTTP方法来对资源进行访问和操作。常用的HTTP方法有GET、POST、PUT、DELETE等，它们分别对应着资源的查询、新增、更新和删除操作。</p>\n<p>RESTful的优势在于它简单、灵活、可伸缩、易于维护和扩展。它采用标准的HTTP协议和常见的数据格式（如JSON、XML等），使得开发人员可以快速地开发出高效、可靠的Web服务，并且可以方便地与其他系统进行集成和交互。</p>\n<h4 id=\"RPC（Remote-Procedure-Call）\"><a href=\"#RPC（Remote-Procedure-Call）\" class=\"headerlink\" title=\"RPC（Remote Procedure Call）\"></a>RPC（Remote Procedure Call）</h4><p>RPC（Remote Procedure Call）即远程过程调用，是一种分布式系统中的通信协议。RPC允许一个程序在另一个计算机上运行的程序请求服务，而不需要了解底层网络细节，就像本地调用一样。</p>\n<p>RPC的原理是客户端发送请求给服务端，服务端执行相应的操作并返回结果给客户端。RPC框架隐藏了底层的网络细节和通信协议，使得开发者可以像使用本地函数一样方便地调用远程函数。</p>\n<p>RPC的优势在于它提供了高效、简单、可靠的远程调用机制，使得分布式系统开发更加便捷。同时，RPC框架支持多种编程语言和跨平台，使得开发者可以使用不同的编程语言和技术栈来实现分布式系统。一些常用的RPC框架有gRPC、Apache Thrift、Dubbo等。</p>\n<h4 id=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"><a href=\"#RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\" class=\"headerlink\" title=\"RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：\"></a>RESTful和RPC是两种不同的远程调用方式，它们的区别主要包括以下几个方面：</h4><ol>\n<li><h5 id=\"设计理念：\"><a href=\"#设计理念：\" class=\"headerlink\" title=\"设计理念：\"></a>设计理念：</h5><ul>\n<li><p>RESTful：是基于HTTP协议设计的，着重于资源的定义和管理，通过URL、HTTP方法和参数等方式进行资源的访问和操作。</p>\n</li>\n<li><p>RPC：是基于函数调用的，着重于接口的定义和数据传输格式的规范，通过序列化和反序列化来实现远程调用。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"通信协议：\"><a href=\"#通信协议：\" class=\"headerlink\" title=\"通信协议：\"></a>通信协议：</h5><ul>\n<li><p>RESTful：使用HTTP协议进行通信，支持GET、POST、PUT、DELETE等HTTP方法。</p>\n</li>\n<li><p>RPC：使用自定义的协议进行通信，可以使用TCP、UDP等网络协议，也可以使用HTTP作为传输协议。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"数据传输格式：\"><a href=\"#数据传输格式：\" class=\"headerlink\" title=\"数据传输格式：\"></a>数据传输格式：</h5><ul>\n<li><p>RESTful：通常使用JSON、XML等文本格式进行数据传输。</p>\n</li>\n<li><p>RPC：通常使用二进制格式进行数据传输，传输效率更高。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"调用方式：\"><a href=\"#调用方式：\" class=\"headerlink\" title=\"调用方式：\"></a>调用方式：</h5><ul>\n<li><p>RESTful：通过HTTP方法进行资源的访问和操作，支持无状态的请求，可以使用缓存等机制提高性能和可伸缩性。</p>\n</li>\n<li><p>RPC：通过函数调用进行接口的访问和操作，需要保持请求和响应之间的状态，不支持缓存等机制。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，RESTful更加适用于Web应用程序和分布式系统的开发，而RPC更加适用于高性能和低延迟的系统调用。</p>\n","categories":["浏览器","协议"],"tags":["前端","浏览器","RESTful","RPC","HTTP"]},{"title":"网络劫持有哪几种，如何防范？","url":"/songs-note//browser/network/hijack.html","content":"<h5 id=\"⽹络劫持\"><a href=\"#⽹络劫持\" class=\"headerlink\" title=\"⽹络劫持\"></a>⽹络劫持</h5><ol>\n<li>DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于dns 劫持)</li>\n</ol>\n<ul>\n<li>DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器</li>\n<li>302 跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302 跳转的回复，引导⽤户获取内容</li>\n</ul>\n<ol start=\"2\">\n<li>HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)</li>\n</ol>\n<h5 id=\"如何防范网络劫持？\"><a href=\"#如何防范网络劫持？\" class=\"headerlink\" title=\"如何防范网络劫持？\"></a>如何防范网络劫持？</h5><p>DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http 劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>\n<p>网络劫持指的是网络中的某个节点对数据进行恶意篡改和篡改，以达到非法获取用户信息或者控制用户设备的目的。以下是预防网络劫持的几个方法：</p>\n<ol>\n<li><p>使用HTTPS：HTTPS是一个安全的协议，对通信进行加密和身份验证，防止劫持者对数据进行篡改。使用HTTPS之前，可以使用SSL证书来验证服务器的身份。</p>\n</li>\n<li><p>使用VPN：VPN可以加密数据并建立一个虚拟私人网络，从而保护用户的数据和隐私。使用VPN可以防止网络劫持和嗅探攻击。</p>\n</li>\n<li><p>使用防火墙和反病毒软件：网络劫持者可能会通过恶意软件或病毒对用户设备进行攻击，使用防火墙和反病毒软件可以防止这种攻击。</p>\n</li>\n<li><p>更新操作系统和软件程序：最新版本的操作系统和软件程序通常包含了修复安全漏洞的补丁。不定期更新操作系统和软件程序可以减少遭受网络攻击的风险。</p>\n</li>\n<li><p>警惕钓鱼网站和不安全的链接：劫持者可能会伪造合法的网站或链接，引导用户向其提供个人信息或下载恶意软件。不要轻信不安全的链接，要时刻保持警惕。</p>\n</li>\n</ol>\n","categories":["浏览器","网路安全"],"tags":["前端","浏览器","网路安全"]},{"title":"浏览器缓存的全过程","url":"/songs-note//browser/mechanism/cache.html","content":"<h3 id=\"浏览器缓存的全过程\"><a href=\"#浏览器缓存的全过程\" class=\"headerlink\" title=\"浏览器缓存的全过程\"></a>浏览器缓存的全过程</h3><p><img src=\"https://pic.imgdb.cn/item/65323b8ec458853aef72a6ad.png\" alt=\"浏览器缓存的全过程\"></p>\n<p>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</p>\n<p>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上次返回 200 的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取数据资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</p>\n<p>如果资源已过期，则标明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</p>\n<p>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</p>\n<p>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间作对比，一致则命中协商缓存，返回 304；</p>\n<p>不一致则返回新的 last-modified 和文件并返回200；</p>\n","categories":["浏览器","缓存"],"tags":["前端","浏览器"]},{"title":"浏览器的渲染进程的线程","url":"/songs-note//browser/render/process.html","content":"<h4 id=\"浏览器的渲染进程的线程\"><a href=\"#浏览器的渲染进程的线程\" class=\"headerlink\" title=\"浏览器的渲染进程的线程\"></a>浏览器的渲染进程的线程</h4><p><img src=\"https://pic.imgdb.cn/item/6532800ac458853aef6782e0.png\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"GUI-渲染线程\"><a href=\"#GUI-渲染线程\" class=\"headerlink\" title=\"GUI 渲染线程\"></a>GUI 渲染线程</h5><p>GUI 渲染线程是在 GUI 应用程序中负责界面渲染的线程。负责渲染浏览器页面，解析 HTML、CSS，构建DOM 树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</p>\n<p>在许多 GUI 应用程序中，渲染线程通常会在主线程中运行，这可能会导致界面卡顿或响应时间过长。为了避免这种情况，一些框架和库已经实现了将 GUI 渲染线程与主线程分离的机制，例如 Android 中的 UI 线程和渲染线程分离机制。</p>\n<p>当渲染线程与主线程分离时，它可以专注于绘制和更新屏幕上的内容，而主线程则可以处理用户输入和其他逻辑。这样可以提高应用程序的响应速度和用户体验。</p>\n<p><strong>注意</strong>：GUI 渲染线程和 JS 引擎线程是互斥的，当JS 引擎执行时GUI线程会被挂起，GUI 更新会被保存在一个队列中等到JS 引擎空闲时立即被执行。</p>\n<h5 id=\"JS-引擎线程\"><a href=\"#JS-引擎线程\" class=\"headerlink\" title=\"JS 引擎线程\"></a>JS 引擎线程</h5><p>JS 引擎线程也称为 JS 内核，负责处理Javascript 脚本程序，解析Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个JS 引擎线程在运行 JS 程序。</p>\n<p>在浏览器环境中，JavaScript 引擎线程负责解释和执行 JavaScript 代码，并将执行结果返回给主线程。JavaScript 引擎线程通常是单线程的，这意味着它只能同时执行一个任务。这就是为什么一些耗时的 JavaScript 代码可以阻止页面的渲染和响应。</p>\n<p>为了解决这个问题，浏览器引入了 Web Workers，使得可以使用多个 JavaScript 引擎线程来执行 JavaScript 代码。这些工作线程可以并行地执行 JavaScript 代码，并在完成任务后将结果返回给主线程，从而防止 JavaScript 代码阻塞页面的渲染和响应。</p>\n<p><strong>注意</strong>：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果JS 执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<h5 id=\"时间触发线程\"><a href=\"#时间触发线程\" class=\"headerlink\" title=\"时间触发线程\"></a>时间触发线程</h5><p>时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当JS引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。</p>\n<p>时间触发线程在浏览器中起着非常重要的作用，因为它们可以帮助网站实现许多不同的功能，包括：</p>\n<ul>\n<li><p>启动定时器：当网页需要执行一些定时任务时，可以使用时间触发线程来启动定时器。</p>\n</li>\n<li><p>处理事件：当用户与网页交互时，例如点击按钮或提交表单，时间触发线程将负责处理这些事件并执行相应的回调函数。</p>\n</li>\n<li><p>处理异步请求：当网页需要从服务器获取数据时，可以使用时间触发线程来处理异步请求并执行回调函数。</p>\n</li>\n</ul>\n<p><strong>注意</strong>：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）。</p>\n<h5 id=\"定时器触发进程\"><a href=\"#定时器触发进程\" class=\"headerlink\" title=\"定时器触发进程\"></a>定时器触发进程</h5><p>浏览器定时器触发进程是指浏览器中用来触发定时器的进程。在浏览器中，定时器可以使用 JavaScript 的 setTimeout() 和 setInterval() 方法来创建。当设置的时间到达后，浏览器会触发定时器，并执行对应的函数。</p>\n<p>定时器触发进程通常由内核管理，它会在特定时间间隔内不断运行，并检查是否有定时器需要触发。当定时器触发时，该进程会将需要执行的任务推入待执行队列中，然后通知主线程执行。主线程会不断检查待执行队列，如果有任务待执行，则将其取出并执行。</p>\n<p>需要<strong>注意</strong>的是，如果执行的任务需要较长时间才能完成，会导致主线程阻塞，影响页面的响应速度。因此，应该尽可能避免在定时器中执行复杂的任务，或者使用 Web Worker 在后台执行任务，以避免阻塞主线程。</p>\n<p><strong>注意</strong>：W3C 在 HTML 标准中规定，定时器的定时时间不能小于4ms，如果是小于 4ms，则默认为 4ms。</p>\n<h5 id=\"异步-http-请求线程\"><a href=\"#异步-http-请求线程\" class=\"headerlink\" title=\"异步 http 请求线程\"></a>异步 http 请求线程</h5><p>在浏览器中，异步 HTTP 请求线程通常由浏览器内部的 JavaScript 引擎处理。当 JavaScript 代码发起一个异步 HTTP 请求时，浏览器会创建一个新的线程来处理该请求，该线程通常是浏览器的网络线程。在该线程中，浏览器会向服务器发送 HTTP 请求，并等待服务器返回响应。</p>\n<p>在等待服务器响应的同时，JavaScript 引擎会继续执行其他代码，不会被阻塞。当服务器返回响应后，浏览器会将响应数据传递给 JavaScript 引擎，在 JavaScript 线程中执行相应的回调函数，用来处理响应数据。</p>\n<p>需要注意的是，由于浏览器对跨域请求进行了限制，在异步 HTTP 请求线程中发起的跨域请求需要经过浏览器的安全机制进行处理，一般需要设置相关的请求头或者使用 JSONP 等技术来解决。</p>\n","categories":["浏览器","渲染"],"tags":["前端","浏览器","GUI"]},{"title":"如何实现浏览器内多个标签页之间的通信?","url":"/songs-note//browser/tab/to/tab.html","content":"<p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>\n<ul>\n<li>使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>\n<li>使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>\n<li>使用localStorage 的方式，我们可以在一个标签页对localStorage的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候localStorage对象就是充当的中介者的角色。</li>\n<li>使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用 postMessage 方法，进行通信。</li>\n</ul>\n","categories":["浏览器","通讯"],"tags":["前端","浏览器","性能优化"]},{"title":"Hexo 开启 RSS","url":"/songs-note//hexo/config/rss.html","content":"<h5 id=\"安装hexo-generator-feed-插件\"><a href=\"#安装hexo-generator-feed-插件\" class=\"headerlink\" title=\"安装hexo-generator-feed 插件\"></a>安装hexo-generator-feed 插件</h5><h6 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h6><p><code>npm install hexo-generator-feed -d</code></p>\n<h6 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h6><p><code>yarn add hexo-generator-feed</code></p>\n<h5 id=\"配置-config-themes-yml\"><a href=\"#配置-config-themes-yml\" class=\"headerlink\" title=\"配置_config.[themes].yml\"></a>配置_config.[themes].yml</h5><h6 id=\"增加导航栏菜单\"><a href=\"#增加导航栏菜单\" class=\"headerlink\" title=\"增加导航栏菜单\"></a>增加导航栏菜单</h6><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">RSS:</span> <span class=\"string\">/atom.xml</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h6><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">atom</span>  <span class=\"comment\"># 类型为atom</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">atom.xml</span> <span class=\"comment\"># 访问路径</span></span><br><span class=\"line\">    <span class=\"attr\">limit:</span> <span class=\"number\">20</span> <span class=\"comment\"># 分页</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"清除重启\"><a href=\"#清除重启\" class=\"headerlink\" title=\"清除重启\"></a>清除重启</h5><p><code>hexo clean &amp;&amp; hexo generate</code></p>\n<h5 id=\"页面效果\"><a href=\"#页面效果\" class=\"headerlink\" title=\"页面效果\"></a>页面效果</h5><p><img src=\"https://pic.imgdb.cn/item/6533d473c458853aefb79c42.png\" alt=\"atom.xml\"></p>\n","categories":["前端","框架","Hexo"],"tags":["前端","Hexo","RSS"]},{"title":"什么是 CSRF 攻击？","url":"/songs-note//web/cross/site/request/forgeries.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>CSRF（Cross-Site Request Forgeries） 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>\n<p>CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>常见的 CSRF 攻击有三种：</p>\n<ul>\n<li>GET 类型的 CSRF 攻击，比如在网站中的一个img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交；</li>\n<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>\n<li>链接类型的 CSRF 攻击，比如在 a 标签的href 属性里构建一个请求，然后诱导用户去点击。</li>\n</ul>\n<h5 id=\"如何防御-CSRF-攻击？\"><a href=\"#如何防御-CSRF-攻击？\" class=\"headerlink\" title=\"如何防御 CSRF 攻击？\"></a>如何防御 CSRF 攻击？</h5><p>CSRF 攻击可以使用以下方法来防护：</p>\n<p>进行同源检测，服务器根据 http 请求头中origin 或者referer信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer字段会告诉服务器该网页是从哪个页面链接过来的）</p>\n<p>使用 CSRF Token 进行验证，服务器向用户返回一个随机数Token，当网站再次发起请求时，在请求参数中加入服务器端返回的token，然后服务器对这个 token 进行验证。这种方法解决了使用cookie单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个token，操作比较繁琐。</p>\n<p>还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的session中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</p>\n<p>对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到URL参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用cookie，但是不能访问获取 cookie 的特点。并且这种方法比CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>\n<p>在设置 cookie 属性的时候设置 Samesite ，限制cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是GET 请求，且会发生页面跳转的请求所使用。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","CSRF"]},{"title":"什么是 XSS 攻击？","url":"/songs-note//web/cross/site/script.html","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>\n<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>\n<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>\n<ol>\n<li>获取页面的数据，如 DOM、cookie、localStorage；</li>\n<li>DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>\n<li>破坏页面结构；</li>\n<li>流量劫持（将链接指向某网站）</li>\n</ol>\n<h5 id=\"攻击类型\"><a href=\"#攻击类型\" class=\"headerlink\" title=\"攻击类型\"></a>攻击类型</h5><p>XSS 可以分为存储型、反射型和 DOM 型：</p>\n<ul>\n<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>\n<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成XSS 攻击。</li>\n<li>DOM 型指的通过修改页面的 DOM 节点形成的XSS。</li>\n</ul>\n<h6 id=\"存储型-XSS-的攻击步骤：\"><a href=\"#存储型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"存储型 XSS 的攻击步骤：\"></a>存储型 XSS 的攻击步骤：</h6><ol>\n<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>\n<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>\n<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。<br>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</li>\n</ol>\n<h6 id=\"反射型-XSS-的攻击步骤：\"><a href=\"#反射型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"反射型 XSS 的攻击步骤：\"></a>反射型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从URL中取出，拼接在 HTML 中返回给浏览器。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在URL ⾥。</p>\n<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>\n</li>\n</ol>\n<h6 id=\"DOM-型-XSS-的攻击步骤：\"><a href=\"#DOM-型-XSS-的攻击步骤：\" class=\"headerlink\" title=\"DOM 型 XSS 的攻击步骤：\"></a>DOM 型 XSS 的攻击步骤：</h6><ol>\n<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>\n</li>\n<li><p>⽤户打开带有恶意代码的 URL。</p>\n</li>\n<li><p>⽤户浏览器接收到响应后解析执⾏，前端JavaScript 取出URL中的恶意代码并执⾏。</p>\n</li>\n<li><p>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</p>\n<p><strong>DOM 型 XSS 跟前两种 XSS 的区别</strong>：DOM 型XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>\n</li>\n</ol>\n<h5 id=\"如何防御-XSS-攻击？\"><a href=\"#如何防御-XSS-攻击？\" class=\"headerlink\" title=\"如何防御 XSS 攻击？\"></a>如何防御 XSS 攻击？</h5><p>可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，具体措施如下：</p>\n<p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p>\n<p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p>\n<ol>\n<li><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p>\n</li>\n<li><p>通常有两种方式来开启 CSP，一种是设置HTTP 首部中的Content-Security-Policy，一种是设置meta 标签的方式&lt;metahttp-equiv&#x3D;”Content-Security-Policy”&gt;<br>对一些敏感信息进行保护，比如 cookie 使用http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p>\n</li>\n</ol>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全","XSS"]},{"title":"有哪些可能引起前端安全的问题?","url":"/songs-note//web/security/question.html","content":"<h5 id=\"跨站脚本-Cross-Site-Scripting-XSS\"><a href=\"#跨站脚本-Cross-Site-Scripting-XSS\" class=\"headerlink\" title=\"跨站脚本 (Cross-Site Scripting, XSS)\"></a><a href=\"https://blog.csdn.net/qq_35490191/article/details/132212266\">跨站脚本 (Cross-Site Scripting, XSS)</a></h5><p>⼀种代码注⼊⽅式,为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等；</p>\n<h5 id=\"iframe-的滥⽤\"><a href=\"#iframe-的滥⽤\" class=\"headerlink\" title=\"iframe 的滥⽤\"></a>iframe 的滥⽤</h5><p>iframe 中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在 iframe 中运⾏JavaScirpt 脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</p>\n<h5 id=\"跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\"><a href=\"#跨站点请求伪造（Cross-Site-Request-Forgeries，CSRF）\" class=\"headerlink\" title=\"跨站点请求伪造（Cross-Site Request Forgeries，CSRF）\"></a><a href=\"https://blog.csdn.net/qq_35490191/article/details/132220538\">跨站点请求伪造（Cross-Site Request Forgeries，CSRF）</a></h5><p>指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击恶意</p>\n<h5 id=\"第三⽅库\"><a href=\"#第三⽅库\" class=\"headerlink\" title=\"第三⽅库\"></a>第三⽅库</h5><p>⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</p>\n","categories":["浏览器","网络安全"],"tags":["前端","浏览器","网络安全"]},{"title":"如何对项目中的图片进行优化?","url":"/songs-note//web/image/perform.html","content":"<h5 id=\"优化步骤方案\"><a href=\"#优化步骤方案\" class=\"headerlink\" title=\"优化步骤方案\"></a>优化步骤方案</h5><ol>\n<li><p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片<br>完全可以用 CSS 去代替。</p>\n</li>\n<li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪<br>费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然<br>后去请求相应裁剪好的图片。</p>\n</li>\n<li><p>小图使用 base64 格式</p>\n</li>\n<li><p>将多个图标文件整合到一张图片中（雪碧图）</p>\n</li>\n<li><p>选择正确的图片格式：</p>\n<ul>\n<li><p>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</p>\n</li>\n<li><p>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</p>\n</li>\n<li><p>照片使用 JPEG</p>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"常见的图片格式及使用场景\"><a href=\"#常见的图片格式及使用场景\" class=\"headerlink\" title=\"常见的图片格式及使用场景\"></a>常见的图片格式及使用场景</h5><ol>\n<li><p>BMP：是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。</p>\n</li>\n<li><p>GIF：是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行<br>编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画<br>以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格<br>式适用于对色彩要求不高同时需要文件体积较小的场景。</p>\n</li>\n<li><p>JPEG：是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF更大。</p>\n</li>\n<li><p>PNG-8：是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF并不支持。除非需要动画的支持，否则没有理由使用 GIF而不是 PNG-8。</p>\n</li>\n<li><p>PNG-24：是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8大得多。</p>\n</li>\n<li><p>SVG 是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。这意味着 SVG 图片在放大时，不会失真，所以它非常适合用来绘制 Logo、Icon 等。</p>\n</li>\n<li><p>WebP：是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera浏览器支持 WebP 格式，兼容性不太好。</p>\n</li>\n</ol>\n<p>在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小26%；<br>在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%；</p>\n<p>WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22%的格外文件大小。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","图片"]},{"title":"前端懒加载是什么?","url":"/songs-note//web/lazy/loading.html","content":"<h5 id=\"懒加载的概念\"><a href=\"#懒加载的概念\" class=\"headerlink\" title=\"懒加载的概念\"></a>懒加载的概念</h5><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。<br>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>\n<h5 id=\"懒加载的特点\"><a href=\"#懒加载的特点\" class=\"headerlink\" title=\"懒加载的特点\"></a>懒加载的特点</h5><ul>\n<li>减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li>\n<li>提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li>\n<li>防止加载过多图片而影响其他资源文件的加载：会影响网站应用的正常使用。</li>\n</ul>\n<h5 id=\"懒加载的实现原理\"><a href=\"#懒加载的实现原理\" class=\"headerlink\" title=\"懒加载的实现原理\"></a>懒加载的实现原理</h5><p>图片的加载是由 src 引起的，当对 src 赋值时，浏览器就会请求图片资源。根据这个原理，我们使用 HTML5 的data-xxx 属性来储存图片的路径，在需要加载图片的时候，将 data-xxx 中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。</p>\n<p><strong>注意</strong>：data-xxx 中的 xxx 可以自定义，这里我们使用data-src来定义。</p>\n<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>\n<p>使用原生 JavaScript 实现懒加载：</p>\n<p><strong>知识点</strong>：</p>\n<p>window.innerHeight 是浏览器可视区的高度</p>\n<p>document.body.scrollTop</p>\n<p>document.documentElement.scrollTop 是浏览器滚动的过的距离</p>\n<p>imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>\n<p>图片加载条件 ： img.offsetTop &lt; window.innerHeight+document.body.scrollTop;</p>\n<p><img src=\"https://pic.imgdb.cn/item/6533ccf1c458853aef92497a.png\" alt=\"在这里插入图片描述\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;container&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;loading.gif&#x27;</span> <span class=\"attr\">data-src</span>=<span class=\"string\">&#x27;pic.png&#x27;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> imgs = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">&#x27;img&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">lazyLoad</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> scrollTop = <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> winHeight = <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; imgs.<span class=\"property\">lenght</span>; i++) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">if</span>(imgs[i].<span class=\"property\">offsetTop</span> &lt; scrollTop + winHeight) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                imgs[i].<span class=\"property\">src</span> = imgs[i].<span class=\"title function_\">getAttribute</span>(<span class=\"string\">&#x27;data-src&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onsrcoll</span> = <span class=\"title function_\">lazyLoad</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"节流和防抖","url":"/songs-note//web/lodash/dubounce.html","content":"<h4 id=\"对节流与防抖的理解\"><a href=\"#对节流与防抖的理解\" class=\"headerlink\" title=\"对节流与防抖的理解\"></a>对节流与防抖的理解</h4><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件<br>又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因<br>为用户的多次点击向后端发送多次请求。<br>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发<br>事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只<br>有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件<br>节流来降低事件调用的频率。</p>\n<p>防抖函数的应用场景：</p>\n<ul>\n<li>按钮提交场景：防止多次提交按钮，只执行最后一次提交</li>\n<li>服务端验证场景： 表达验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有索联想词功能类似生存环境可以使用lodash.debounce</li>\n</ul>\n<p>节流函数的适用场景：</p>\n<ul>\n<li>拖拽场景：固定实际内只执行一次，防止超高频次触发位置变动</li>\n<li>缩放场景：监控浏览器resize</li>\n<li>动画场景：避免短时间内多次触发动画引起性能问题</li>\n</ul>\n<h4 id=\"实现节流函数和防抖函数\"><a href=\"#实现节流函数和防抖函数\" class=\"headerlink\" title=\"实现节流函数和防抖函数\"></a>实现节流函数和防抖函数</h4><h5 id=\"函数防抖的实现\"><a href=\"#函数防抖的实现\" class=\"headerlink\" title=\"函数防抖的实现\"></a>函数防抖的实现</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, wait</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>, args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 如果此时存在定时器则取消之前的定时器重新计时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(timer) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"函数节流的实现\"><a href=\"#函数节流的实现\" class=\"headerlink\" title=\"函数节流的实现\"></a>函数节流的实现</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 时间戳版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fn, delay</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>],</span><br><span class=\"line\">        nowTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nowTime - preTime &gt;= delay) &#123;</span><br><span class=\"line\">            preTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定时器版</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fu, wait</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>,</span><br><span class=\"line\">        args = [...<span class=\"variable language_\">arguments</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                fu.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">                <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"浅谈回流与重绘","url":"/songs-note//web/reflux/and/redrawing.html","content":"<h5 id=\"回流\"><a href=\"#回流\" class=\"headerlink\" title=\"回流\"></a>回流</h5><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。<br>下面这些操作会导致回流：</p>\n<ul>\n<li>页面的首次渲染</li>\n<li>浏览器的窗口大小发生变化</li>\n<li>元素的内容发生变化</li>\n<li>元素的尺寸或者位置发生变化</li>\n<li>元素的字体大小发生变化</li>\n<li>激活 CSS 伪类</li>\n<li>查询某些属性或者调用某些方法</li>\n<li>添加或者删除可见的 DOM 元素</li>\n</ul>\n<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的 DOM 元素重新排列，它的影响范围有两种：<br>全局范围：从根节点开始，对整个渲染树进行重新布局<br>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</p>\n<h5 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h5><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。</p>\n<p>下面这些操作会导致重绘：<br>color、background 相关属性：background-color、background-image等<br>outline 相 关 属 性 ： outline-color 、outline-width、text-decoration<br>border-radius、visibility、box-shadow</p>\n<p>注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</p>\n<h5 id=\"如何避免回流与重绘？\"><a href=\"#如何避免回流与重绘？\" class=\"headerlink\" title=\"如何避免回流与重绘？\"></a>如何避免回流与重绘？</h5><p>减少回流与重绘的措施：</p>\n<p>操作 DOM 时，尽量在低层级的 DOM 节点进行操作不要使用 table 布局， 一个小的改动可能会使整个table 进行重新布局</p>\n<p>使用 CSS 的表达式</p>\n<p>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</p>\n<p>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</p>\n<p>避免频繁操作 DOM，可以创建一个文档片段documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</p>\n<p>将元素先设置 display: none，操作结束后再把它显示出来。因为在display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</p>\n<p>浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>\n<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化"]},{"title":"如何⽤webpack 来优化前端性能?","url":"/songs-note//web/webpack/perform.html","content":"<h5 id=\"如何⽤webpack-来优化前端性能？\"><a href=\"#如何⽤webpack-来优化前端性能？\" class=\"headerlink\" title=\"如何⽤webpack 来优化前端性能？\"></a>如何⽤webpack 来优化前端性能？</h5><p>⽤webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>\n<ul>\n<li>压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩 css；</li>\n<li>利⽤CDN 加速: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤webpack 对于 output 参数和各 loader 的publicPath 参数来修改资源路径；</li>\n<li>Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现；</li>\n<li>Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存；</li>\n<li>提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取, 利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码。</li>\n</ul>\n<h5 id=\"如何提⾼webpack-的构建速度？\"><a href=\"#如何提⾼webpack-的构建速度？\" class=\"headerlink\" title=\"如何提⾼webpack 的构建速度？\"></a>如何提⾼webpack 的构建速度？</h5><ol>\n<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码；</li>\n<li>通过 externals 配置来提取常⽤库；</li>\n<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过DllReferencePlugin 将预编译的模块加载进来；</li>\n<li>使⽤ Happypack 实现多线程加速编译；</li>\n<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度；</li>\n<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码。</li>\n</ol>\n","categories":["浏览器","性能优化"],"tags":["前端","浏览器","性能优化","Webpack","插件"]},{"title":"Fiber 架构的起源","url":"/songs-note//react/fiber.html","content":"<h1 id=\"Fiber-架构的起源\"><a href=\"#Fiber-架构的起源\" class=\"headerlink\" title=\"Fiber 架构的起源\"></a>Fiber 架构的起源</h1><p>Fiber 架构的起源可以追溯到 React 团队在 2017 年提出的一项重大改进计划。在过去的 React 版本中，渲染过程是基于递归的，即组件树的遍历是通过递归函数来完成的。这种方式在大规模复杂应用中可能会引发一些性能问题，例如长时间的主线程阻塞，导致用户体验下降。</p>\n<span id=\"more\"></span>\n<p>为了解决这些性能问题，React 团队开始着手设计一种新的渲染架构，即 Fiber 架构。Fiber 架构的目标是使 React 的渲染过程可中断和恢复，从而实现更好的任务调度、优先级管理和增量更新。</p>\n<p>Fiber 这个名字来源于计算机科学中的 “Fiber”（纤程）概念，指的是一种轻量级的执行单元，可以在多个任务之间切换，并且可以中断和恢复执行。React 中的 Fiber 也是类似的概念，表示渲染过程中的任务单元，可以根据任务的优先级和时间片进行灵活的调度和中断。</p>\n<p>通过 Fiber 架构，React 实现了一个基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。同时，React 还引入了优先级调度算法，通过动态调整任务的优先级，可以根据不同任务的重要性和紧急程度来合理地分配渲染资源。</p>\n<p>Fiber 架构的引入使得 React 在渲染过程中可以更加灵活地响应用户交互，提供更好的用户体验。它为 React 提供了更强大的渲染能力，能够支持更复杂、更大规模的应用程序。</p>\n<p>值得一提的是，Fiber 架构的设计和实现是一个非常复杂的过程，并且在不同版本的 React 中可能会有一些细节上的差异。React 团队在不断地改进和优化 Fiber 架构，以进一步提升 React 应用的性能和可靠性。</p>\n<h1 id=\"Fiber的含义\"><a href=\"#Fiber的含义\" class=\"headerlink\" title=\"Fiber的含义\"></a>Fiber的含义</h1><blockquote>\n<p>总的来说，Fiber 是 React 中的一种渲染架构和调度算法，通过将渲染过程划分为可中断和恢复的任务单元，实现了增量更新和优先级调度。Fiber 架构的引入使得 React 能够更加高效地处理渲染任务，提供更好的用户体验和更高的性能。</p>\n</blockquote>\n<p>Fiber 是 React 中的一个概念，它有多个含义和作用：</p>\n<ul>\n<li><p>渲染任务单元：在 React 中，Fiber 表示渲染过程中的任务单元。传统的递归渲染方式可能会导致长时间的主线程阻塞，影响用户体验。而 Fiber 架构将渲染过程划分为一系列小的任务单元（Fiber 节点），可以根据任务的优先级和时间片进行灵活的调度和中断，实现增量更新和任务的并发处理。</p>\n</li>\n<li><p>调度和优先级管理：Fiber 架构引入了一套调度算法，用于根据任务的优先级和时间片来动态调整任务的执行顺序。通过优先级调度，React 可以根据任务的重要性和紧急程度合理地分配渲染资源，从而提供更好的用户体验。优先级调度还使得 React 可以在不同任务之间进行中断和恢复，避免了长时间的阻塞。</p>\n</li>\n<li><p>组件结构表示：Fiber 架构引入了基于链表结构的 Fiber 树，用于表示组件的层级关系和渲染顺序。每个 Fiber 节点表示一个组件或 DOM 元素，并通过 child、sibling 和 return 等属性建立起节点之间的关联。通过 Fiber 树的结构，React 可以更加高效地遍历和更新组件树，实现增量渲染。</p>\n</li>\n<li><p>增量更新：Fiber 架构支持增量更新，即仅更新发生变化的部分，而不需要重新渲染整个组件树。通过对比 Fiber 树的两个状态，React 可以确定哪些组件需要更新，并且可以跳过不需要更新的部分，从而提高渲染性能。</p>\n</li>\n</ul>\n","categories":["React","Fiber"],"tags":["前端","react","JavaScript","Fiber"]},{"title":"Fiber 架构实现流程","url":"/songs-note//react/fiber/implement.html","content":"<p>Fiber 架构是 React 中用于实现虚拟 DOM 的一种算法架构。它的目标是提高渲染性能和用户体验，通过将渲染工作分割成多个小任务，在不阻塞主线程的情况下逐步完成整个渲染过程。</p>\n<p>下面是 Fiber 架构的简要实现过程：</p>\n<ul>\n<li><p>构建 Fiber 树：在进行首次渲染时，React 会构建一棵 Fiber 树，用于表示组件的层级结构和渲染顺序。每个 Fiber 节点对应一个组件实例，其中包含组件的状态、属性和其他相关信息。</p>\n</li>\n<li><p>初始渲染阶段：React 通过递归遍历 Fiber 树，在每个 Fiber 节点上执行渲染操作，生成对应的虚拟 DOM 元素。</p>\n</li>\n<li><p>任务拆分：在渲染过程中，React 根据时间片（Time Slicing）的概念将渲染任务拆分为多个小任务（Fiber），每个小任务执行时间有限，并且可以中断和恢复。</p>\n</li>\n<li><p>优先级调度：React 使用优先级调度算法确定哪些任务具有更高的优先级，并按照顺序执行这些高优先级的任务，以保证用户界面的流畅度。</p>\n</li>\n<li><p>增量更新：在执行每个小任务时，React 会比较前后两次渲染结果，找出需要更新的部分，并对其进行增量更新。这样可以避免全量重新渲染，提高性能。</p>\n</li>\n<li><p>渲染结果提交：当所有小任务完成后，React 将最终渲染结果提交给浏览器进行绘制，完成整个渲染过程。</p>\n</li>\n</ul>\n<p>Fiber 架构的实现使得 React 能够在多任务之间动态地切换，并根据任务的优先级和时间片进行灵活的调度。这样可以更好地响应用户的交互，提供更流畅的用户体验。</p>\n","categories":["React","Fiber"],"tags":["前端","react","JavaScript","Fiber"]},{"title":"FiberNode结构解析","url":"/songs-note//react/fiber/node.html","content":"<h1 id=\"FiberNode结构解析\"><a href=\"#FiberNode结构解析\" class=\"headerlink\" title=\"FiberNode结构解析\"></a>FiberNode结构解析</h1><p>FiberNode（也称为 Fiber 节点）是 React Fiber 架构中的核心概念之一，用于表示组件的层级结构和渲染过程中的任务。</p>\n<span id=\"more\"></span>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">FiberNode</span>(<span class=\"params\">tag, pendingProps, key, mode</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Instance</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">tag</span> = tag;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">key</span> = key;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">elementType</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">stateNode</span> = <span class=\"literal\">null</span>; <span class=\"comment\">// Fiber</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">return</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">child</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sibling</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">ref</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">pendingProps</span> = pendingProps;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedProps</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">updateQueue</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">memoizedState</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">dependencies</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">mode</span> = mode; <span class=\"comment\">// Effects</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">flags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">subtreeFlags</span> = <span class=\"title class_\">NoFlags</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">deletions</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">lanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">childLanes</span> = <span class=\"title class_\">NoLanes</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">alternate</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: The following is done to avoid a v8 performance cliff.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Initializing the fields below to smis and later updating them with</span></span><br><span class=\"line\">    <span class=\"comment\">// double values will cause Fibers to end up having separate shapes.</span></span><br><span class=\"line\">    <span class=\"comment\">// This behavior/bug has something to do with Object.preventExtension().</span></span><br><span class=\"line\">    <span class=\"comment\">// Fortunately this only impacts DEV builds.</span></span><br><span class=\"line\">    <span class=\"comment\">// Unfortunately it makes React unusably slow for some applications.</span></span><br><span class=\"line\">    <span class=\"comment\">// To work around this, initialize the fields below with doubles.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// Learn more about this here:</span></span><br><span class=\"line\">    <span class=\"comment\">// https://github.com/facebook/react/issues/14365</span></span><br><span class=\"line\">    <span class=\"comment\">// https://bugs.chromium.org/p/v8/issues/detail?id=8538</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"title class_\">Number</span>.<span class=\"property\">NaN</span>; <span class=\"comment\">// It&#x27;s okay to replace the initial doubles with smis after initialization.</span></span><br><span class=\"line\">    <span class=\"comment\">// This won&#x27;t trigger the performance cliff mentioned above,</span></span><br><span class=\"line\">    <span class=\"comment\">// and it simplifies other profiler code (including DevTools).</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">actualStartTime</span> = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">selfBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">treeBaseDuration</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This isn&#x27;t directly used but is handy for debugging internals:</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugSource</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugOwner</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugNeedsRemount</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_debugHookTypes</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasBadMapPolyfill &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"title class_\">Object</span>.<span class=\"property\">preventExtensions</span> === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h5 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h5><p>表示 FiberNode 的类型，可以是 HostComponent、ClassComponent、FunctionComponent 等。</p>\n<h5 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h5><p>表示组件的唯一标识符，用于在列表渲染中进行元素的重用。</p>\n<h5 id=\"elementType\"><a href=\"#elementType\" class=\"headerlink\" title=\"elementType\"></a>elementType</h5><p>表示组件元素的类型。大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹。</p>\n<h5 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h5><p>type 属性表示 FiberNode 对应的组件类型，可以是字符串（原生组件）或函数&#x2F;类（自定义组件）。对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName。</p>\n<h5 id=\"stateNode\"><a href=\"#stateNode\" class=\"headerlink\" title=\"stateNode\"></a>stateNode</h5><p>每个 FiberNode 包含一个 stateNode 属性，它指向组件实例。stateNode 可以是一个 DOM 元素（对于原生组件），也可以是一个类实例（对于自定义组件）。</p>\n<blockquote>\n<p>​\tFiberNode 使用链表结构来表示组件的层级关系</p>\n</blockquote>\n<h5 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h5><p>return 指向父节点。</p>\n<h5 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child\"></a>child</h5><p>  child 属性指向第一个子节点。</p>\n<h5 id=\"sibling\"><a href=\"#sibling\" class=\"headerlink\" title=\"sibling\"></a>sibling</h5><p>  sibling 属性指向下一个兄弟节点。</p>\n<h6 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      i am</span><br><span class=\"line\">      &lt;span&gt;SongShao&lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>对应的<code>Fiber树</code>结构</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">   App</span><br><span class=\"line\">   ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span></span><br><span class=\"line\">||</span><br><span class=\"line\"> --------div ----------------</span><br><span class=\"line\">      ||  \t\t\t ||</span><br><span class=\"line\">child || <span class=\"built_in\">return</span>  child || <span class=\"built_in\">return</span> </span><br><span class=\"line\">         ||\t\t\t\t ||</span><br><span class=\"line\">        i am ----------- span</span><br><span class=\"line\">               sibling    ||</span><br><span class=\"line\">           \t\t   child || <span class=\"built_in\">return</span></span><br><span class=\"line\">           \t\t \t     ||</span><br><span class=\"line\">           \t\t      SongShao</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里需要提一下，为什么父级指针叫做<code>return</code>而不是<code>parent</code>或者<code>father</code>呢？因为作为一个工作单元，<code>return</code>指节点执完<code>completeWork</code>（本章后面会介绍）后会返回的下一个节点。子<code>Fiber节点</code>及其兄弟节点完成工作后会返回其父级节点，所以用<code>return</code>指代父级节点。</p>\n</blockquote>\n<h5 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h5><p>在父节点中的索引位置。</p>\n<h5 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h5><p>用于引用组件。</p>\n<h5 id=\"pendingProps\"><a href=\"#pendingProps\" class=\"headerlink\" title=\"pendingProps\"></a>pendingProps</h5><p>组件的待处理属性。</p>\n<h5 id=\"memoizedProps-和-memoizedState\"><a href=\"#memoizedProps-和-memoizedState\" class=\"headerlink\" title=\"memoizedProps 和 memoizedState\"></a>memoizedProps 和 memoizedState</h5><p>这些属性保存了组件的当前状态（props 和 state）。在渲染过程中，React 使用 memoizedProps 和 memoizedState 保存组件的最新状态，并通过比较前后两次状态的差异，确定是否需要更新组件。</p>\n<h5 id=\"updateQueue\"><a href=\"#updateQueue\" class=\"headerlink\" title=\"updateQueue\"></a>updateQueue</h5><p>用于存储组件的更新队列。</p>\n<h5 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h5><p>表示组件的依赖项。</p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><p>表示渲染模式。</p>\n<h5 id=\"flags-和-subtreeFlags\"><a href=\"#flags-和-subtreeFlags\" class=\"headerlink\" title=\"flags 和 subtreeFlags\"></a>flags 和 subtreeFlags</h5><p>表示 FiberNode 的状态标志。</p>\n<h5 id=\"deletions\"><a href=\"#deletions\" class=\"headerlink\" title=\"deletions\"></a>deletions</h5><p>表示待删除的节点。</p>\n<h5 id=\"lanes-和-childLanes\"><a href=\"#lanes-和-childLanes\" class=\"headerlink\" title=\"lanes 和 childLanes\"></a>lanes 和 childLanes</h5><p>表示调度的优先级。</p>\n<h5 id=\"alternate\"><a href=\"#alternate\" class=\"headerlink\" title=\"alternate\"></a>alternate</h5><p>alternate 属性指向 FiberNode 的替代节点。在渲染过程中，React 会创建两个 FiberNode，一个表示当前渲染状态，另一个表示下一次渲染状态。通过 alternate 属性，React 在两个状态之间进行比较，找出需要更新的节点。</p>\n<h5 id=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"><a href=\"#actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\" class=\"headerlink\" title=\"actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration\"></a>actualDuration、actualStartTime、selfBaseDuration、treeBaseDuration</h5><p>用于记录组件的实际渲染时间和基准时间。</p>\n<h5 id=\"debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\"><a href=\"#debugSource、-debugOwner、-debugNeedsRemount、-debugHookTypes\" class=\"headerlink\" title=\"__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes\"></a>__debugSource、__debugOwner、__debugNeedsRemount、__debugHookTypes</h5><p>用于调试和内部记录。</p>\n","categories":["React","Fiber"],"tags":["前端","react","JavaScript","Fiber"]},{"title":"React 获取服务器端时间","url":"/songs-note//react/service/time.html","content":"<h2 id=\"React-获取服务器端时间\"><a href=\"#React-获取服务器端时间\" class=\"headerlink\" title=\"React 获取服务器端时间\"></a>React 获取服务器端时间</h2><p><strong>思路</strong>：React获取服务器端时间，本质上就是给服务器端发送一个请求，然后从返回数据里面的headers里面获取到服务器date，然后更新服务器时间去格式化，获取服务器时间结束。按秒进行数据刷新，其实也很简单，就是使用定时器，进行动态递增即可，直接上代码。</p>\n<span id=\"more\"></span>\n<p>获取服务器时间的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">changeTime = async () =&gt; &#123;</span><br><span class=\"line\">    let leftTime = await axios.get(&#x27;/&#x27;).then(response =&gt; &#123;</span><br><span class=\"line\">        console.log(response.headers)</span><br><span class=\"line\">        return new Date(response.headers.date).getTime()</span><br><span class=\"line\">     &#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">        console.log(error)</span><br><span class=\"line\">        return 0</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">        time: moment(leftTime).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自动增加的方法（以秒为单位）:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">addTime = date =&gt; &#123;</span><br><span class=\"line\">      let newDate = new Date(date)</span><br><span class=\"line\">      newDate.setSeconds(newDate.getSeconds() + 1)</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        time: moment(newDate).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      window.time = &#123;</span><br><span class=\"line\">        date: this.state.time,</span><br><span class=\"line\">        timestamp: Date.parse(new Date(this.state.time))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后根据react  state状态进行页面渲染。</p>\n","categories":["React"],"tags":["前端","react","JavaScript"]},{"title":"React 使用合成事件（SyntheticEvent）","url":"/songs-note//react/synthetic/event.html","content":"<h1 id=\"React-使用合成事件\"><a href=\"#React-使用合成事件\" class=\"headerlink\" title=\"React 使用合成事件\"></a>React 使用合成事件</h1><p>React 使用合成事件（SyntheticEvent）来处理浏览器原生事件的跨浏览器兼容性问题。合成事件是一个封装了原生事件的对象，提供了一致的跨浏览器接口，使您能够在不同浏览器中以一致的方式处理事件。</p>\n<span id=\"more\"></span>\n<p>在 React 中，您可以通过在组件中定义事件处理函数并将其传递给相应的元素来处理合成事件。例如，您可以在一个按钮上定义一个点击事件处理函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  handleClick = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span>&gt;</span>Click me!<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的示例中，我们定义了一个名为handleClick的点击事件处理函数，并将其传递给按钮的onClick属性。当按钮被点击时，React 将自动创建一个合成事件对象，并将其作为参数传递给handleClick函数。您可以在事件处理函数中访问合成事件对象，并使用其属性和方法进行操作。</p>\n<p>合成事件对象具有与原生事件对象相似的属性和方法，但也有一些额外的属性和方法，用于处理 React 特定的功能。例如，您可以使用event.target来访问触发事件的元素，event.preventDefault()来阻止默认行为，以及event.stopPropagation()来阻止事件冒泡。</p>\n<p>请注意，由于合成事件是 React 提供的跨浏览器抽象，它并不是浏览器原生事件对象。因此，某些浏览器特定的功能可能不可用或表现不一致。如果需要访问原生事件对象，您可以使用合成事件对象的nativeEvent属性。</p>\n<h1 id=\"React合成事件如何阻止事件传播\"><a href=\"#React合成事件如何阻止事件传播\" class=\"headerlink\" title=\"React合成事件如何阻止事件传播\"></a>React合成事件如何阻止事件传播</h1><p>React合成事件可以通过调用<code>e.stopPropagation()</code>来阻止事件传播。<br>当根容器接收到捕获事件时，先触发一次React事件的捕获阶段，然后再执行原生事件的捕获传播。所以，调用<code>e.stopPropagation()</code>可以阻止原生事件的传播。<br>合成事件是根据事件类型对原生事件的属性进行处理，并包装了关键方法，从而实现了事件的触发和处理。</p>\n","categories":["React"],"tags":["前端","react","JavaScript"]},{"title":"async/await 的理解","url":"/songs-note//javascript/async/await.html","content":"<h2 id=\"async-await-的理解\"><a href=\"#async-await-的理解\" class=\"headerlink\" title=\"async&#x2F;await 的理解\"></a>async&#x2F;await 的理解</h2><p>async&#x2F;await 其实是 Generator 的语法糖，它能实现的效果都能用then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解async用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在asnyc 函数中，先来看看 async 函数返回了什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\"><span class=\"title class_\">Promise</span> &#123;&lt;fulfilled&gt;: <span class=\"string\">&#x27;hello world;&#x27;</span>&#125;</span><br><span class=\"line\">[[<span class=\"title class_\">Prototype</span>]]: <span class=\"title class_\">Promise</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseState</span>]]: <span class=\"string\">&quot;fulfilled&quot;</span></span><br><span class=\"line\">[[<span class=\"title class_\">PromiseResult</span>]]: <span class=\"string\">&quot;hello world;&quot;</span></span><br></pre></td></tr></table></figure>\n<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个Promise对象，如果在函数中 return 一个直接量，async 会把这个直接量通过Promise.resolve() 封装成 Promise 对象。async 函数返回的是一个 Promise 对象，所以在最外层不能用await 获取其返回值的情况下，当然应该用原来的方式：then()链来处理这个 Promise 对象，就像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">testAsy</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">testAsy</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">result.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// hello world;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那如果 async 函数没有返回值，又该如何？很容易想到，他会返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"literal\">undefined</span>);</span><br></pre></td></tr></table></figure>\n<p>联想一下 Promise 的特点——无等待，所以在没有await 的情况下执行 async 函数，它会立即执行，返回一个Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回Promise 对象的函数并无二致。</p>\n<pre><code> 注意：Promise.resolve(x) 可以看作是new Promise(resolve=&gt;resolve(x)) 的简写\n 可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n</code></pre>\n<h2 id=\"async-await-的优势\"><a href=\"#async-await-的优势\" class=\"headerlink\" title=\"async&#x2F;await 的优势\"></a>async&#x2F;await 的优势</h2><p>单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">takeLongTime</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(n + <span class=\"number\">200</span>), n)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step1</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step2</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">step3</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">takeLongTime</span>(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在用 Promise 方式来实现这三个步骤的处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"title function_\">step1</span>(time1)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> <span class=\"title function_\">step2</span>(time2))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> <span class=\"title function_\">step3</span>(time3))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">\t\t&#125;);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>652s</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出结果 result 是 step3() 的参数 700 + 200 &#x3D; 900。doIt()顺序执行了三个步骤，一共用了 300 + 500 + 700 &#x3D; 1500 毫秒，和console.time()&#x2F;console.timeEnd() 计算的结果一致。如果用 async&#x2F;await 来实现呢，会是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">doIt</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">time</span>(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> <span class=\"title function_\">step1</span>(time1);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> <span class=\"title function_\">step2</span>(time2);</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title function_\">step3</span>(time3);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">timeEnd</span>(<span class=\"string\">&#x27;doIt&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">doIt</span>();</span><br><span class=\"line\">step1 <span class=\"keyword\">with</span> <span class=\"number\">300</span></span><br><span class=\"line\">step2 <span class=\"keyword\">with</span> <span class=\"number\">500</span></span><br><span class=\"line\">step3 <span class=\"keyword\">with</span> <span class=\"number\">700</span></span><br><span class=\"line\">result is <span class=\"number\">900</span></span><br><span class=\"line\"><span class=\"attr\">doIt</span>: <span class=\"number\">1.</span>515s</span><br></pre></td></tr></table></figure>\n\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h2 id=\"async-await-对比-Promise-的优势\"><a href=\"#async-await-对比-Promise-的优势\" class=\"headerlink\" title=\"async&#x2F;await 对比 Promise 的优势\"></a>async&#x2F;await 对比 Promise 的优势</h2><p>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</p>\n<p>Promise 传递中间值⾮常麻烦，⽽async&#x2F;await⼏乎是同步的写法，⾮常优雅</p>\n<p>错误处理友好，async&#x2F;await 可以⽤成熟的try&#x2F;catch，Promise的错误捕获⾮常冗余</p>\n<p>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"编写 Promise 方法","url":"/songs-note//javascript/promise.html","content":"<h5 id=\"Promise-是什么？\"><a href=\"#Promise-是什么？\" class=\"headerlink\" title=\"Promise 是什么？\"></a>Promise 是什么？</h5><p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步 操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调， 它比传统的解决方案回调函数和事件更合理和更强大。</p>\n<span id=\"more\"></span>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束 的事件(通常是一个异步操作)的结果。从语法上说，Promise 是一 个对象，从它可以获取异步操作的消息。Promise 提供统一的 API， 各种异步操作都可以用同样的方法进行处理。</p>\n<ol>\n<li>Promise 的实例有三个状态:</li>\n</ol>\n<ul>\n<li><p>Pending(进行中)</p>\n</li>\n<li><p>Resolved(已完成)</p>\n</li>\n<li><p>Rejected(已拒绝)</p>\n</li>\n</ul>\n<p>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了 状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</p>\n<ol start=\"2\">\n<li><p>Promise 的实例有两个过程:<br> pending -&gt; fulfilled: Resolved(已完成)<br> pending -&gt; rejected: Rejected(已拒绝)</p>\n<p> 注意:一旦从进行状态变成为其他状态就永远不能更改状态了。</p>\n</li>\n</ol>\n<h5 id=\"Promise-的特点\"><a href=\"#Promise-的特点\" class=\"headerlink\" title=\"Promise 的特点\"></a>Promise 的特点</h5><p>对象的状态不受外界影响。promise 对象代表一个异步操作，有三种 状态，pending(进行中)、fulfilled(已成功)、rejected(已失 败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他 操作都无法改变这个状态，这也是 promise 这个名字的由来——“承 诺”;</p>\n<p>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能:从 pending 变为 fulfilled，从 pending 变为 rejected。这时就称为 resolved(已定型)。如果改 变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这 个结果。这与事件(event)完全不同，事件的特点是:如果你错过 了它，再去监听是得不到结果的。</p>\n<h5 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h5><p>Promise 实现是通过js class编写，主要包括status、value、error、resolve、reject、then、catch、all、race、allSettled、any等组成。</p>\n<ol>\n<li>状态</li>\n</ol>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">&quot;pending&quot;</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">&quot;fulfilled&quot;</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">&quot;rejected&quot;</span>; <span class=\"comment\">// 已拒绝</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>resolve 创建一个已解决的Promise对象，将给定的值作为其参数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>reject 创建一个已拒绝的Promise对象，将给定的原因作为其参数</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>then 添加对Promise对象解决或拒绝时的处理程序</li>\n</ol>\n<ul>\n<li>单个方法调用</li>\n</ul>\n   <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> resolve = (<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_FULFILLED</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">//queueMicrotask:  主线程执行完毕之后立马执行</span></span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">resfn</span>(value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">const</span> reject = (<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">status</span> === <span class=\"variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">status</span> = <span class=\"variable constant_\">PROMISE_STATUS_REJECTED</span></span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"title function_\">errfn</span>(error)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">   <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resFn</span> = resFn;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFn</span> = errFn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>执行结果  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>)</span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;        <span class=\"comment\">//最终打印 1111</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>优化then 方法</li>\n</ul>\n<p>官方给与的then 方法是可以进行数组传值和链式调用的，而目前我们写的是不支持。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [] <span class=\"comment\">//1.多次调用then 时用数组 保存</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将then 方法修改为 </span></span><br><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">resfns</span>.<span class=\"title function_\">push</span>(resFn);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(errFn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolve修改为</span></span><br><span class=\"line\">resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// reject 修改为</span></span><br><span class=\"line\">reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  优化后then的运行结果<br>  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;res1:&quot;</span>, res) </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;err1:&quot;</span>, err)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;res2:&quot;</span>, res)</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;err2:&quot;</span>, err)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>运行结果：res2: 111  因为后面的.then 把前面的覆盖掉了 并不会执行res1 所在的代码块<br>*由此可见 then 方法调用时应该是个数组然后依次调用<br>下面改造我们的代码then,还需要优化执行resolve 时调用reject<br>   <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>然后执行：<br>  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"number\">111</span>);</span><br><span class=\"line\">    <span class=\"title function_\">reject</span>(<span class=\"number\">333333</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;res1:&quot;</span>, res);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;err1:&quot;</span>, err);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 调用then方法多次调用</span></span><br><span class=\"line\">p1.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;res2:&quot;</span>, res);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;err2:&quot;</span>, err);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">执行结果：</span><br><span class=\"line\"><span class=\"attr\">res1</span>: <span class=\"number\">111</span></span><br><span class=\"line\"><span class=\"attr\">res2</span>: <span class=\"number\">111</span></span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li><p>catch 添加对Promise对象拒绝时的处理程序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(errFn) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>finally 添加对Promise对象解决或拒绝时的最终处理程序，无论Promise对象是否已被解决或拒绝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>all 接收一个可迭代对象（如数组），并返回一个新的Promise对象。当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类型判断当前数组中的方法或者对象是否为Promise 对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;object&quot;</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;function&quot;</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">&quot;function&quot;</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">any[]</span>&#125; <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@desc</span> 实际上多个对象同步执行时，就相当于把所有的方法重新进行Promise一次。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当遍历到最后一个时，resolve 所有结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;传入参数必须是一个数组&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) &#123;</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>all 运行示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"number\">88888</span>,</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">运行结果: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">123</span>,  <span class=\"number\">88888</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>race Promise.race(iterable) 传入多个对象,当任何一个执行完成后 resolve 结果</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;传入参数必须是一个数组&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) &#123;</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>race 运行示例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"title class_\">MyPromise</span>.<span class=\"title function_\">race</span>([</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  res.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">运行结果： <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>完整代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// status</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span> = <span class=\"string\">&quot;pending&quot;</span>; <span class=\"comment\">// 进行中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> = <span class=\"string\">&quot;fulfilled&quot;</span>; <span class=\"comment\">// 已完成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> = <span class=\"string\">&quot;rejected&quot;</span>; <span class=\"comment\">// 已拒绝</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPromise</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">executer</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span> = [];</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span> = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">executer</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">resolve</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">reject</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//    创建一个已解决的Promise对象，将给定的值作为其参数。</span></span><br><span class=\"line\">  resolve = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = value;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>?.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">fn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个已拒绝的Promise对象，将给定的原因作为其参数。</span></span><br><span class=\"line\">  reject = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">queueMicrotask</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> !== <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> = <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">error</span> = error;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">en</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">en</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">//   添加对Promise对象解决或拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"title function_\">then</span>(<span class=\"params\">resFn, errFn</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnRejected</span> = (<span class=\"params\">err</span>) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    errFn = errFn || defaultOnRejected;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">defaultOnFulFilled</span> = (<span class=\"params\">value</span>) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    resFn = resFn || defaultOnFulFilled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_FULFILLED</span> &amp;&amp; !!resFn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_REJECTED</span> &amp;&amp; !!errFn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">statue</span> === <span class=\"variable constant_\">PROMISE_STATUE_PENDING</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!resFn) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">resFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">resFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!errFn) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">this</span>.<span class=\"property\">errFns</span>.<span class=\"title function_\">push</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> value = <span class=\"title function_\">errFn</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">error</span>);</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">reject</span>(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象拒绝时的处理程序。</span></span><br><span class=\"line\">  <span class=\"keyword\">catch</span>(errFn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>, errFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加对Promise对象解决或拒绝时的最终处理程序，无论Promise对象是否已被解决或拒绝。</span></span><br><span class=\"line\">  <span class=\"title function_\">finally</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isPromise = <span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    !!promise &amp;&amp;</span><br><span class=\"line\">    (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;object&quot;</span> || <span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;function&quot;</span>) &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> promise.<span class=\"property\">then</span> === <span class=\"string\">&quot;function&quot;</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收一个可迭代对象（如数组），并返回一个新的Promise对象。</span></span><br><span class=\"line\"><span class=\"comment\"> * 当所有Promise对象都已解决时，该Promise对象才将被解决，并返回一个包含所有解决值的数组。</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">any[]</span>&#125; <span class=\"variable\">iterable</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">all</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;传入参数必须是一个数组&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = iterable.<span class=\"property\">length</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> promise = iterable[i];</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(promise)) &#123;</span><br><span class=\"line\">        promise</span><br><span class=\"line\">          .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            results[i] = res;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count === len) &#123;</span><br><span class=\"line\">              <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">        results[i] = <span class=\"title function_\">promise</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        results[i] = promise;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当数据的所有项都不是promise实例，我们就在这判断多一次，然后resolve</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count === len) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(results);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">MyPromise</span>.<span class=\"property\">race</span> = <span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(iterable <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;传入参数必须是一个数组&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyPromise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    iterable.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"title function_\">isPromise</span>(p)) &#123;</span><br><span class=\"line\">        p.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> p === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"title function_\">p</span>());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(p);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// const p1 = new MyPromise((resolve, reject) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(&quot;状态pending&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//   resolve(&quot;22222&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//   reject(&quot;3333333&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// p1.then((res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   console.log(&quot;res1:&quot;, res);</span></span><br><span class=\"line\"><span class=\"comment\">//   return &quot;第二次的成功回调&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">//   .catch((error) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(&quot;err1:&quot;, error);</span></span><br><span class=\"line\"><span class=\"comment\">//     throw new Error(&quot;第二次的失败回调&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;)</span></span><br><span class=\"line\"><span class=\"comment\">//   .finally(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(&quot;finally&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// (async function() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.all([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;),</span></span><br><span class=\"line\"><span class=\"comment\">//     () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       return 123;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//     88888,</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (async function() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   const res = MyPromise.race([</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(1);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;),</span></span><br><span class=\"line\"><span class=\"comment\">//     new MyPromise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       resolve(2);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;),</span></span><br><span class=\"line\"><span class=\"comment\">//   ]);</span></span><br><span class=\"line\"><span class=\"comment\">//   res.then((res) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     console.log(res);</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)();</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Promise-的缺点\"><a href=\"#Promise-的缺点\" class=\"headerlink\" title=\"Promise 的缺点\"></a>Promise 的缺点</h5><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p>\n<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>\n<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始 还是即将完成)。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结:\"></a>总结:</h5><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。 一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变， 就凝固了，无法再被改变了。</p>\n<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在 异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原 型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的 改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的 末尾执行。</p>\n<p>注意:在构造 Promise 的时候，构造函数内部的代码是立即执行的。</p>\n","categories":["前端","es6"],"tags":["前端","JavaScript","es6"]},{"title":"404","url":"/songs-note//404.html","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">██╗  ██╗ ██████╗ ██╗  ██╗    ███╗   ██╗ ██████╗ ████████╗</span><br><span class=\"line\">██║  ██║██╔═████╗██║  ██║    ████╗  ██║██╔═══██╗╚══██╔══╝</span><br><span class=\"line\">███████║██║██╔██║███████║    ██╔██╗ ██║██║   ██║   ██║</span><br><span class=\"line\">╚════██║████╔╝██║╚════██║    ██║╚██╗██║██║   ██║   ██║</span><br><span class=\"line\">     ██║╚██████╔╝     ██║    ██║ ╚████║╚██████╔╝   ██║</span><br><span class=\"line\">     ╚═╝ ╚═════╝      ╚═╝    ╚═╝  ╚═══╝ ╚═════╝    ╚═╝</span><br><span class=\"line\"></span><br><span class=\"line\">    ███████╗ ██████╗ ██╗   ██╗███╗   ██╗██████╗</span><br><span class=\"line\">    ██╔════╝██╔═══██╗██║   ██║████╗  ██║██╔══██╗</span><br><span class=\"line\">    █████╗  ██║   ██║██║   ██║██╔██╗ ██║██║  ██║</span><br><span class=\"line\">    ██╔══╝  ██║   ██║██║   ██║██║╚██╗██║██║  ██║</span><br><span class=\"line\">    ██║     ╚██████╔╝╚██████╔╝██║ ╚████║██████╔╝</span><br><span class=\"line\">    ╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝╚═════╝</span><br></pre></td></tr></table></figure>\n"},{"title":"archives","url":"/songs-note/archives/index.html","content":""},{"title":"有关于我","url":"/songs-note//about/me.html","content":"<hr>\n<h4 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h4><ul>\n<li>性 别：男 \t\t\t\t\t\t\t\t\t\t\t  年 龄：27</li>\n<li>手 机：15594555052                           邮 箱：<a href=\"mailto:&#x73;&#111;&#110;&#103;&#115;&#x73;&#104;&#x61;&#111;&#x40;&#x66;&#111;&#x78;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;\">&#x73;&#111;&#110;&#103;&#115;&#x73;&#104;&#x61;&#111;&#x40;&#x66;&#111;&#x78;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a></li>\n<li>专 业：计算机科学与技术                    岗 位：研发工程师</li>\n</ul>\n<hr>\n<h4 id=\"工作及教育经历\"><a href=\"#工作及教育经历\" class=\"headerlink\" title=\"工作及教育经历\"></a>工作及教育经历</h4><ul>\n<li>博彦科技：前端开发⼯程师 \t\t\t\t\t          2021.08.16 ~ 至今</li>\n<li>神玥软件：软件开发⼯程师部⻔技术负责⼈\t2019.07.03 ~  2021.08.13</li>\n<li>安康学院 \t\t\t\t\t \t\t\t\t\t                    2015.09.01 ~ 2019.06.24</li>\n</ul>\n<hr>\n<h4 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h4><ul>\n<li>熟练使用：React、JavaScript、HTML、CSS、TypeScript、Java</li>\n<li>前端框架：Taro-UI、JQuery、Echarts、Antd、ThreeJS</li>\n<li>前端服务层：Mobx、Redux</li>\n<li>前端请求服务：Axios、Ajax、fetch</li>\n<li>前端资源加载&#x2F;打包⼯具：Webpack 、UmiJS、Vite</li>\n<li>后端微服务框架：SpringBoot</li>\n<li>后端服务框架：SpringMVC、Struct2</li>\n<li>后端Jdbc层：MyBatis、Hibernate</li>\n<li>框架：Django、Pillow、requests、urllib3、bs4、Selemiun、lxml</li>\n<li>数据库：MySQL、Oracle、Redis、SqLite、memcache</li>\n<li>服务器：Tomcat、Nginx</li>\n<li>算法：快速排序、深度优先策略、贪心算法</li>\n</ul>\n<hr>\n<h4 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h4><ol>\n<li><p>博彦科技 - 某某云开发平台 - 2020年9⽉⾄今</p>\n<ul>\n<li>职 责：主要负责项⽬开发、框架服务维护、⾃动化部署、处理程序紧急问题等职责</li>\n<li>内 容：在项⽬期间负责前端⻚⾯设计、开发、维护等。主要通过该项⽬对⾃⼰的个⼈技能有了⼀个较强的提升，对于⾃⼰的知识⾯有了⼀个更⾼层次的认知，使⽤第三⽅⼯具进⾏快速开发，采⽤React技术栈和其周边⼯具开发，项⽬架构采⽤umiJs + vite 协同开发模式。技术难度是项目系统结构复杂，系统代码老旧，改造升级难度大大增加。</li>\n</ul>\n</li>\n<li><p>神玥软件 - ⼴东动态监管平台 - 2020年6⽉⾄2021年7⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在该项⽬中同样采⽤全后端分离架构，该项⽬中不同之处在于使⽤架构发⽣改变，增加使⽤接⼝获取数据、动态切换数据源等。</p>\n</li>\n<li><p>项⽬架构：</p>\n<p>前端+展示服务后台+数据抓取服务端+定时器数据处理服务端+接⼝获取数据端+第三⽅数据获取服务端组成。</p>\n<p>在前端开发中，项⽬使⽤4层架构进程⻚⾯处理，临时数据存储使⽤session进⾏，使⽤有效⻚⾯数据传输保证⻚⾯独⽴性、依赖性降低、项⽬可扩展性增加、便与开发进⾏。</p>\n<p>在定时器数据处理服务端不同之处，在于其需要兼容多中不同数据源，主要包oracle、db2(及其as400版本)、MySQL等，兼容其不同语法进⾏处理，连接⼯具类处理，初始化连接等问题，后台数据报⽂传输使⽤某某加密⽅式实现。</p>\n<p>第三⽅接⼝程序实现主要是提供于第三⽅进⾏对接数据，汇总返回数据，进⾏数据统计，完成展示。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、SpringSecurity、oauth2、Sqlite、MySQL、redis等。</p>\n</li>\n</ul>\n</li>\n<li><p>神玥软件 - 公积⾦监督管理云平台 - 2019年8⽉⾄2020年5⽉</p>\n<ul>\n<li><p>职 责：主要负责项⽬的开发、开发技术⽀持、框架服务、部署、处理程序紧急问题等职责</p>\n</li>\n<li><p>内 容：在公积⾦监督管理云平台开发中，使⽤前后端分离架构。</p>\n</li>\n<li><p>项⽬架构： 前端+展示服务后台+数据抓取服务端+定时器数据处理服务端组成。在前端开发中，使⽤React开发框架辅助antd、amap、echarts、mobx、Axios等，借助webpack打包压缩⽂件等技术实现前端开发任务。</p>\n<p>在后端技术⽀撑⽅⾯使⽤SpringBoot微服务框架，进⾏数据展示层⾯服务服务端程序编写。</p>\n<p>在数据获取⽅⾯，数据均来⾃于各现场数据库，编写定时器服务端程序，使⽤频率为5 分钟到1⼩时不等等⽅法策略实现，适⽤于各种不同的核⼼版本库，通过sqlite轻量级数据库进⾏数据暂存，等待公司客户端服务器抓取数据，该技术由于公司限制使⽤该⽅法策略实现，在程序实现⽅⾯使⽤mybatis解析SQL⽅式编写，xml配置⽂件进⾏SQL配置，通过dao4j进⾏xml解析获取对应sql，使⽤XMLScriptBuilder进⾏获取SQL处理⽣成sqlSource资源，根据sqlSource获取boundSql对象获取编译后带有占位符资源对象，获取占位符信息数据，替换对应参数完成可执⾏sql。</p>\n<p>在数据抓取客户端使⽤5分钟频率去更新数据，实时抓取数据与数据可进⾏⽐较并且进⾏更新。</p>\n<p>对接使⽤微型前端服务框架，加载第三⽅服务程序。</p>\n</li>\n<li><p>技 术：React、antd、Spring、SpringBoot、mybatis、Sqlite、MySQL、redis等。</p>\n</li>\n</ul>\n</li>\n<li><p>个人项目 - 微信⼩程序API+停⻋场客户端编写 - 2018年11⽉⾄-2019年1⽉</p>\n<ul>\n<li>职 责：项⽬设计、需求、开发、部署等</li>\n<li>内 容：该项⽬主要使⽤微信⼩程序、Django框架、H5前端完成。后端基于Django框架，主要是在Django框架中进⾏setting.py 配置，url编写，数据库模型创建、映射⽂件，view视图编写，服务代码编写。Api返回数据序列化处理、json数据处理。进⾏停⻋场实时数据监控数据处理。并且使⽤window 2008 server R2 进⾏环境部署，服务器搭建使⽤ nginx+fastCGI+Django进⾏配置，使⽤https进⾏数据访问。</li>\n<li>职 责：负责编写model、admin、view、API编写、⽀付接⼝编写；</li>\n<li>开发⼯具、语⾔及框架：JetBrains PyCharm、MySQL、Dreamweaver、Photoshop、Python、Django、HTML、CSS、JavaScript、Ajax、jQuery、Bootstrap以及Python开源框架。</li>\n</ul>\n</li>\n<li><p>个人项目 - 爬取wikipedia深度为3的超链接</p>\n<ul>\n<li>内 容：Wikipedia 深度为3的所有URL资源链接的获取（1000万条记录），采取进程的⽅法进⾏访问Wikipedia，根据深度优先策略进⾏URL第⼆层资源遍历获取第三层URL资源。在数据处理过程中，使⽤request2技术获取源码、解析拦截⽆⽤⽂件，使⽤lxml技术进⾏分离出需要数据，并且检测出可⽤链接， 后进⾏URL保存到本地资源。</li>\n<li>难 点：在获取Wikipedia 网站数据的时候需要处理反爬虫、过滤网站数据、获取需要的资源进行解析。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"获奖经历\"><a href=\"#获奖经历\" class=\"headerlink\" title=\"获奖经历\"></a>获奖经历</h4><ul>\n<li>博彦科技 - 技术之星</li>\n<li>信息安全一级证书</li>\n</ul>\n<hr>\n<h4 id=\"⾃我评价\"><a href=\"#⾃我评价\" class=\"headerlink\" title=\"⾃我评价\"></a>⾃我评价</h4><ul>\n<li>爱 好：骑⾏、登⼭、旅游、⽻⽑球、篮球、乒乓球。</li>\n<li>评 价：在我的从事计算机⾏业学习到⼯作也有6年之久，从刚开始对计算机的感兴趣到现在的⼯作，以及它成为了我⽣活不可或缺的⼀部分，都是⼀个变化和不多学习的过程，在这个过程中，经历了太多太多的苦难，从刚开始的⼀窍不通到现在的应⽤⾃如以及更深层次的了解，都是在不断⾃学中成⻓起来。需要这般⾃学就必须要有⾃学的动⼒和持之以恒的坚持都是不可缺少的。学习过程中不断的纠正⾃⼰学的⽅向，处理存在的问题以及快速处理问题的解决⽅法，都是⼀个能⼒的提升。 后还有就是对这个⾏业的热爱。</li>\n</ul>\n"},{"title":"categories","url":"/songs-note/categories/index.html","content":""},{"title":"docs","url":"/songs-note/docs/index.html","content":""},{"title":"schedule","url":"/songs-note/schedule/index.html","content":""},{"title":"Tags","url":"/songs-note/tags/index.html","content":""}]